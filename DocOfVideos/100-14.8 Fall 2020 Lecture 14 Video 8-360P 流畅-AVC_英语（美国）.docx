in this next i'm going to ask you to build a circuit that determines if an 8-bit number is identically zero so why would i do this why this kind of specialized thing well it turns out that you often design circuitry depending on what the computer is being asked to do and i don't think it will surprise you to learn that you often will check to see if the number is zero so imagine you're counting down imagine if you want to know should i divide by this thing is it zero or not and i'm willing to bet if you go back and look at all the code you've written at some point you've checked if some variable is equal to zero and sometimes it's useful to have highly specialized circuitry that does just one thing very specific that is very common because you can put that in the in the in the overall circuit board in a place that's very efficient and you can design it in a way that's as efficient as possible it's always having general purpose circuitry so let's do this one uh very specialized circuit and it's just a good exercise also of turning the crank of working through our four-step process so first things first what is our input output that's always the case i have a single 8-bit binary number which means i have eight inputs corresponding to a0 to a7 the bit positions and i want to know if this number is equal to that number that is all of the numbers are 0. so a0 0 a1 is 0 and so on and so forth okay so i could write so one way to do this is i could say okay let's write a one bit compare for zero build that circuit and then wire everything together because it seems like maybe well that's been the trend we went from a one big compare for a quality to a four bit compare for a quality we went from a one bit adder to a four bit adder and this seems like a lot of inputs because if i have eight inputs how many rows am i going to have in my table 2 to the power 8 256 i'm not writing a truth table 256 entries and i don't think you should either but before we try to design the one bit compare for zero and then generalize it let's think through this truth table for a second so i know that i have to enumerate every single possible row for all possible inputs and i know that there are 256 of those but what do i also know that's going to happen in step two i'm going to go through this output column and what am i going to do i'm going to find all the places where there's a 1 and i'm going to build a sub expression using and and not and then i'm going to combine those sub expressions using ors all right but let's think through that think through any row here that is not zero zero zero zero zero zero to that what is the value of i going to be zero it's not zero there is one row in one row only zero zero zero zero zero zero zero zero where there's a one so in fact this isn't nearly as bad as it seems because every row and it's the first row by the way on top of that every row after that will have a zero in the i i don't have to worry about those rows because i'm not going to build a sub expression for them so in fact this truth table is incredibly simple there's only one row that is relevant to us because all the other rows will come for free because there is a zero in the i column well once i have this i've got a pretty easy expression let's write it out okay so what is the sub expression for this well again we're going to combine all the inputs with a combination of and and not all right how do i get a 1 when i have eight zeros it's not a and not b and not c up to not h i take the not of everything if they're all zero all of those will be one and if they're all one well then the whole express sub expression will be a one and if any one of these is a one to begin with when i knot it it flips to a zero and they have veto power the whole thing will evaluate to zero and that's 255 rows below this all right so this turns out to be pretty easy the sub expression which is also the expression because there's only one of them is just not a not and not b and not c up to not h all right now we can draw the circuit i've got my eight inputs here corresponding to each of the bits of my eight bit number i'm gonna shove them each of them into a not gate you see them lined up right here and now i've just got to start anding them now be careful here and can only take two inputs right you can't shove all of these things into some big fat and gate so you got to start pairing them off a little bit and there's you can do it in any different way you can pair these two these two these two these two and then combine them it doesn't matter because as long as they're all coming into the same and gates eventually it doesn't matter the order in which them so let me pair them off two at a time so a and b go through their knots they go into and so at this point i've pairwise and everything and now i'm going to do the same thing i'm going to pairwise and pairwise and and then of course i just need one more at the very end here and then i'm done and notice follow through make sure that this logic works for you let let's say they're all zero except for this one okay so that g is a one let's walk through the circuitry that's a one coming through it gets knotted it gets knotted so this is a zero now so into this and becomes a zero what comes out i don't even care what h is if this is a zero zero comes out all right zero comes out the whole thing is zero notice how any one of these flips to one it propagates through the entire circuitry and i get a zero out and the only way i get a one there is if these are all zero they all flip to one and then i propagate only ones through the series of uh okay so simple little trick is that because the sub expressions we only care about the one in the output column if you have a really sparse set of ones you in fact don't have to enumerate the entire truth table those zeros are eventually going to get kicked out it's nice to have them there when you have a small number of inputs just so you can see everything but as your inputs get bigger and bigger you can be fairly strategic on how you build those uh truth tables good so that's a simple step in the last lecture i'm going to talk about what are called karnoff maps and these are now a slightly different design that allows us to try to reduce the number of gates why do i want to reduce the number of gates because that reduces the number of transistors which means i can pack more and more power and so there's lots of different optimizations we can talk for months about that i'm going to just show you one very simple idea to give you some intuition on how some of the circuitry optimization works all right we'll pick it up in a few 