lecture number 14 q a here we go man that is a hard question how do you think abstractly well let me i i don't know the answer that let me give you a couple of thoughts and then we'll see what john thinks so first of all i think computer science is very different than other fields um there's not in a lot of fields you know memorization and pattern matching sort of work right you you say things like you know a biologist you just have to memorize a whole bunch of stuff and just tell me what i taught you and that's that's not really we're in the problem-solving business and every problem is a little bit different yes you learn these basic skills that come to bear so break out of the habit of trying to sort of remember a solution to your problem right that that's not really going to work um it's really about taking the parts of the solution and putting them together in a distinct and novel way so it's more of the if you will the the the the raw material and then you're gonna sort of mix it all together in new ways so so so break free of the you know oh i've seen this before i've seen this before that's number one number two for me and everybody's a little bit different on this i don't like to think in front of the computer like when i'm thinking about problem solving i need a piece of paper and pencil or i need to go for a walk and just get away from the computer because once you start coding you get really bogged down in the you know all the little nitty-gritty things you got to make sure that the solution to the problem is clear in your head and the implementation is separate in some ways for me in fact it's very different you know because i can think of all kinds of solutions that would take me days months to implement so get clear in your head what the problem is and don't worry too much about the underlying implementation um and then the last thing i'll say is it's just practice it's just you just you know the more problems you solve the better you get at it so this is your first class in fact it's only week five of your first class in your first four years and i mean nobody expects you to like out of the gate you know be um solving these problems off the top of your head so it's just it's sort of a slow process it'll take time next year you'll be better at it the year after that you'll be better at it and you'll keep getting better at it because you'll keep solving problems and the problems will get bigger and bigger so be patient yeah i think that's great advice actually what hani said reminds me that there's something really different about an online version of 61a from the on-campus version which is how people approach discussion where we used to print out the discussion worksheets and everyone would put away their laptops and pull out a pen and kind of start writing down first diagrams and then a description of what they're trying to achieve and eventually code but code is just one language to describe the process that you're trying to to capture right in a recursion problem or anything else you could also describe it in english you could try to describe it in figures or diagrams and all of these are helpful because that's uh how people really think right is that they um you know nobody like thinks in code we we think in um you know physical metaphors and uh we rely on language that we've been learning since we were babies and stuff like that so um yeah so pulling out a piece of paper isn't as common i think now but it's still a good idea and going back to the original question of like how do you think abstractly it's um that's very broad but there is a more specific skill relevant to this class and all the computer science classes you might take later which is to accurately describe the things you have to work with and then a lot of the problem solving that happens in computer science is how do i get some new things done with some pieces that i already have available and the weird thing is that unlike carpentry where like your set of tools is basically always the same in computer science your set of tools is always different you have like a different set of functions that you can call in recursion you're kind of like building the tool as you're using it which is a weird thing but knowing those things that you can do is really the first step to trying to do anything new with them and so every function really just has three things that you need to know about it it's domain so like what kinds of things can you call it on do you call it on trees do you call it on numbers do you call it on positive numbers do you call it on lists of numbers whatever its range like what kind of thing will it return and then its behavior and its behavior is a concise description of what it does what's the relationship between the input and the output and if you can think of a function in terms of those three things then it's much easier to use because you can check and see like oh can i call this function well if it's a function that takes trees is it arguments and i don't have any trees then i can't call it and when i do call it i better call it on a tree not the trees label or the trees branches or something like that and uh after i call it what do i have left well that's the range and um and exactly what is this new thing oh it's a tree that's bigger or whatever the function does so um yeah thinking in terms of those three elements can help you get to know the functions that you have to work with and then you can reason about like oh exactly how do i want to put these pieces together i'll add one more piece to that i like that description a lot which is that problem solving and coding is not linear you don't just you know start here and end up here and you just take equal steps it's a very meandering process you know often what happens is you go down the shore and you're like oh scrap i screwed up this data structure's not right the subtraction barrier is not right i need to pull back a little bit and try so it's a very sort of iterative process you know you sort of build a little bit you realize ah you know we didn't really think through this issue over here let's back up a little bit fix this little thing go forward and let it build so it's nobody expect you to start here and end up here or just take a straight straight shot so don't worry if there is this sort of back and forth deleting code it's like writing i mean think about writing a five-page essay you don't just start at the beginning at least i don't and in writing get to the end and be like done right i mean let's see what do the editors say the best writers are the ones who know how to delete um right so i think it's a very sort of iterative [Music] fits and burst type of thing so don't get discouraged if you find yourself doing that and actually this relates back to the question in the chat before we started recording which is like how often do you correct uh old code and i find one of the best ways to debug something is actually just to rewrite it even if it's my own work to think like oh is there a different way i could have expressed this and if so what would it look like in that case and sometimes it turns out that you find like oh this piece that i thought i needed i don't need because i'm writing it a different way and that can clarify the implementation a lot so um so the strategy of like start with something and then continue adding to it until it works might succeed for some simple problems but basically doesn't succeed well for more and more complex problems as you proceed through the course and instead like getting rid of everything except for the essence is usually the way to go the next question was what is an exclusive or gate or an xor gate and can you build up everything from that so i showed you one construction of a circuit that starts with a two table and says build a boolean expression for each of the outputs using only and and not yeah that is not the only way you can do it there are other ways of doing that what i like about that one is that it's a very sort of methodical process right uh express the problem build the truth table and or and not rather and then pour everything together draw the circuit it is by no means the only way to do it um it is by no means the optimal way to do it right so an x or is let's see if i can get this right it's um true if one of the one or the other of the inputs are are true but not if both of them are true right so think of the truth table 0 0 would be false did i get that right john xor yes yeah 1 1 is false and then 1 0 is true 0 1 is true yeah so which is another boolean out it's just another boolean operator and you can build expressions like that it's just that the process that i described is a little bit different um i off the top of my head i don't know how to build an xor out of transistors but i'm sure you can um i think it's probably two transistors in a resistor or something like that but i'd have to sort of sketch it out to see it but yes you can you can you can physically implement an xor um and there are other types of operators too that are beyond and or not those are sort of the building blocks and then there are these things that go off to the side but perfectly fine by the way and i'm sure and absolutely there are in this computer right here there are xor gates those are very useful um i just described one particularly simple way to design circuits because it led to a very clean formulation without having to do a lot of things you know the next question was would courses cover circuit design is it 61c or 16a and b um the circuit design is mostly in 16a and 16b um 61c has an interesting level of abstraction that's between python and circuits which is called assembly language and um yeah the details there are that you need to do more than just describe the relationship between inputs and outputs you also need to describe for example like what to do next and whether to load something in from memory that was stored before and whether to store something and where to store it so these primitives actually also have circuitry associated with them so if you want to do more than add but you also want to like manipulate memory and have sequences of instructions and decide oh i'm done doing this for a while i'm going to do this other function and implement function calls and stuff like that well there's circus associated with all that and hardware associated with all that but then you need a language to describe exactly what to do and then you get a programmable computer and that language that is implemented not in software but in circuitry is called an assembly language which is kind of the lowest level programming language so that's what you get in the 61c so if you really want kind of the whole stack 61ab gives you the high level software programming 61c gives you this very low level but still software representation of an assembly language and then 16a 16b will tell you about the circuits and by the way back in the day this was before my time people programmed in assembly language there were no high level languages there was no python no c no java none of this stuff and so people programmed in that what we would now consider a low level um description and so you had to know like where are the registers for the store and what is the address and it was incredibly difficult uh to do and so we've been creating these abstraction barriers right where now we have this high level language where we just put in some some code and then it gets compiled down it gets converted to assembly and then it interacts with the hardware so there are several levels still between you and things actually happening on the computer um and you can i think that that sequence is really interesting to sort of see how it all unfolds the next question was if you pass all the tests for the cats project but the gui still doesn't work should you submit or keep trying to debug it if you pass all the tests you might have bugs in your code but we won't know about them so in that sense they won't affect your ability to get credit um it's less interesting to have a program that doesn't seem to work now it's hard to tell whether when the gui doesn't work that's because there's some issue with your code or whether there's some issue with our code because we provided the gui uh it seems to have worked pretty robustly in the past but i'm not sure um yeah i didn't teach this course over the summer they always make changes maybe they broke something and then it might be that actually that there's a configuration issue with your computer that we didn't anticipate um or yeah so like the way in which it connects to the server or something like that is um is uh hard to get around yeah so we have had students in the past that have like particular antivirus software that interrupts the multiplayer server or something like that so yeah if i had to guess probably if you're passing all the tests then the problem is not with your code but i can't guarantee you that's the case but that's probably what's going on and um will we debug it hopefully yeah so there's definitely stuff that we don't check for that um is important and this is true of any test suite is that it's basically impossible to prove that a program does what it's supposed to do if that program is just written in python with no constraints there's an interesting branch of computer science called verification that is about making sure that you can prove that your program really does what it's supposed to do but the trick there is that you have to express what it's supposed to do in language that the computer can understand and then you also tend to have some restrictions on what how you write your program to make it easier to verify so these techniques still aren't used very often in practice except for with very low level programming like making sure that a circuit board does what it's supposed to do so anyway yeah it might be the case that there are some issues that we didn't detect but you could certainly just submit your project and not worry about that so yeah the question is about like how do you approach add trees which takes in two trees and returns a new tree where each corresponding node from the first tree is added with the node from the second tree if a node at any particular position is present in one tree but not the other it should be present in the new tree as well so you could kind of pretend that a tree that's missing some branches relative to the other tree just has zeros everywhere i think it's one way to think about it um and [Music] apparently this is a lot harder than previous tree problems that's exciting it's an ominous warning so let me just try to get set up here address i think since these are both trees they both must have a label they might have different lists of branches but they both must have a label so um we can guess at what's the label of the final thing that we want to build which is that the result label is the result of adding together the label of t1 and the label of t2 and i always like say in words what i'm trying to do to a tree before i start trying to program because that helps me make sure that i'm kind of combining the right types of values so you can't add two trees together if you do you won't get an error but you will get the wrong thing so instead you want to get the labels and add those together now what about all the elements i'm not going to use this built-in zip function because that seems like it's more complicated we could try that later if you want but i think we want to go through and um for each corresponding pair of branches we want to add those branches together and then we'll get uh new branches so um yeah so maybe we'll start with no branches and i think it would be helpful to have an index of which branch i'm on and then i want to go through all the branches that exist in both trees so one way to do that is to say well i is less than the len of the branches of t1 and i is less than the length of the branches of t2 and we might think of a more concise way to say that later but this is a a fine way to say i want to go through all the i's where they exist in d1 and they exist in tt and what would we get we'd get a new branch that is the result of adding together uh branches t1 r with branches t2 i i'm doing this in kind of the most explicit way possible now what does it mean to add these two things together well we actually need to like add their labels and add all of the elements in the rest of them fortunately we have a function that does that it's called add trees um so to make this fit on the screen i would call this b1 and b2 maybe and then we'll just call add trees on b1 and b2 uh what do we do with the new branch um we'll learn in friday's lecture that there's other ways to do it but one way is just to redefine result branches to have all the branches that were in there before plus there's a new branch so we'll build a list containing just that branch and um add that in so that will give me a longer list that's got all the elements of this plus one new element which is this new branch now we have a bunch of branches and if we had some guarantee that t1 and t2 had the same structure then we'd be done i'd say but being done means we need to return a tree that's what add trees does so we'd call this on result label and result branches the tricky part is that maybe it was the case that i was didn't didn't capture all the branches in t1 because there were fewer branches in t2 or something like that um so what do you do about that i think that um any branch that's in one but not the other doesn't really need to be added to anything it just needs to be included in the result um so which ones did we leave out we left out i think all the branches of t1 from i onwards so let's just kind of check with an example if this had four branches and this had two branches then after you do this iteration i will be equal to two and will reach here and if t1 had four branches then we do want branch two and branch three which is exactly what would be captured by this slicing expression so we could write something like that and what if it was the case that um there were more branches in t2 than they were in t1 well then we'd need to put those in the result something like that might work the question to ask yourself is why are both of them there if only one of those can be true right you can either have extra in t1 or t2 so why are we allow why are we allowing both of those in there yeah there's the implementation again if you want to think about that and i think i'll just quickly check and see if this works except i'm not sure that i have print tree to find anywhere i might have to grab that yeah i gotta get print tree where's print tree oh it's in there somewhere there you are print tree i'll put that in my file of important functions related to trees gonna try this all again what am i trying again i want to run these oh runs forever that's not good let's see why that is oh you're not incrementing i john in the while loop rookie mistake okay now it works so i mean there's lots of ways to clean this up uh we could um for example have this like be a minimum of these two values we got it slightly better um we got the coleman we could have given names to branches t1 and branches t2 because it seems like we call that just a ton of times and it might just simplify things if we'd given them names we could replace this while statement with a for statement the whole story about zip i think um we could talk about really quick so uh what zip does if you give it to this is give you a way of iterating over both of those lists um kind of uh concurrently so the one and the seven go together and the two and the eight go together and the three and the nine go together the nice thing is that if you zip lists of different links then it just kind of works its way up until you get to the to the part that you want so um right so instead of all of this we could have gone through uh b1 and b2 and the result of zipping together the branches of t1 and the branches of t2 and we'd end up getting rid of that line now we've kind of lost track of our notion of i and that can be worrisome but we could reconstruct it actually so i could be just the len of the result branches and then this would probably work yeah it looks pretty good um and yeah finally could you somehow like get this into one line and usually it's the case that if you ever start with a list and then you are adding just one element at a time to that list you could instead write it as a list comprehension so this could have been add trees b1 b2 we're going to have to give it some shorter name for b1 b2 in this zip still doesn't fit how disappointing make it fit okay so those are the result branches now i'm just fiddling around but whatever you probably get the idea um and then you can delete all this stuff there's a great line by um i think it was um one of the guys who wrote c in unix and he said debugging is twice as hard as writing code so if you are as clever as you can be when you write code you will by definition not be able to debug your code um yeah so and i mentioned this because john did something really nice here he he wrote code that was not particularly elegant sorry john a little bit longer than you might want but it was very logical you could see what he was doing in every step he got that to work we make sure and now you can go back and start tightening it up and cleaning it up and making it more elegant if you want to but sometimes that slightly longer code slightly more explicit is actually preferred because it's a little bit easier to deal with i'm like if i looked at this i'd have a hard time parsing this code whereas the previous code was you could see what was going on it was good yeah i was just trying to show this kind of different ways of solving the problem and there was a tint about zip so i forgot i'd tell you what it was you know zip is an abstraction that most python programmers really get used to because it shows up a lot that you want to like pair things together in this way but if you're unfamiliar with it then this looks completely confusing so it just like takes a while to get used to or familiar with this notion that you would take you know the first two elements first elements and pair them together in the second elements put them together in the third elements to get them together once you're used to that notion because you've seen it a dozen times then this idea of like oh call ad trees on all the corresponding pairs is easy to read but at the beginning if you've never seen the term zip before then it's really hard to read so kind of depending on your comfort level and the comfort level of whoever might read your code it can make a lot more sense to kind of write things out explicitly um or you know if you've all been programming together in python for years in your community then you could write it this way because zip is kind of a common verb in that community and it's not necessarily confusing and this works for assignments too i mean we may tie your hands and say you have to use zip that doesn't mean your first implementation has to do it just figure out how it works and then you can back your way into the constraints and that sort of helps you think about you know how we're solving the problem without one hand tied behind your back if you're not comfortable with a particular concept but at least you have it working at that point and it's worth noting that a lot of expressions that existed in the other implementation still exist here like we didn't actually have to change this code as long as we kind of captured what was going on so that's generally true there's lots of different ways to write the same thing but they often share the same elements a follow-up question was whether you could write the same implementation just using recursion yeah great question so we are using recursion already in the sense that we're calling ad trees within the body of fat trees there's one part that we're not doing recursively which is that we're iterating over the branches so this is kind of a mixture of iteration and recursion could we make that part recursive too the answer is yes but we'd basically just write a helper function that does this process of building up the result branches we just build it up recursively um so it's actually not so bad what do we need we need the branches of one and the branches of two we pass those in or actually let's just stay consistent we'll pass in t1 and t2 um and if it's the case that the one of these is empty then there are no branches in the result otherwise we're going to have to construct uh the like first add tree and then add that on to the the rest so the first thing i think would be the result of calling ad trees on branches t1 0 almost got it right and branches t1 2 0 and then what do we do with that okay i'm going to move this in just so it fits um we want a list that that has that as its first element and then the result of build result branches on oh i guess we do need a list of branches here so here bs1 and bs2 are the branches of two trees are the remaining branches of trees well i'll leave it like that uh so we're getting close you see there is like a fair amount of iteration here to get it right that's not right and that's not right and that's right maybe uh and then we just need to kind of forget about the first element of both of these make it fit and then we get rid of this expression and replace it with a call to the helper function that we built and perhaps we've then built something that works we did not build something that works john i don't want to put pressure on you but you got three minutes okay so now it works uh yeah so if you really wanted like to take some iteration and turn into a recursion there's always a way here's one possible way um this would be done rarely in practice i think uh if you just like are going through a sequence of something then use a list comprehension or for statement or a while statement or something like that recursion is really wonderful for recursively processing trees so uh the the add trees here is really an important recursive call that's the reason we learned recursion and uh this is just kind of an exercise in knowing that it's possible a student then suggested that instead of returning an empty list in the base case you return the rest of the other tree fine idea yeah although now you have to know which one is you can't just do the min though yeah it might work there you go good idea yeah all right that saves some effort okay we added a lot of trees thanks folks 