Strings are objects. And  so strings have attributes.  The string 'Hello' has a method called  upper, which makes it uppercase. That's   part of the behavior of being  a string. You can lowercase it,   you can even swap cases. Now, none  of these things have changed s.  S is still Hello.
Each of these method   invocations has returned a new string based on  the old string. But it does something very string   like. So these aren't general functions. These  are things that are just particular to strings.   And that's why they're methods as opposed to  functions that are built into the language.  Now, strings are an abstraction that  allows us to represent text. But there   is an encoding of those strings as numbers.
And actually, this encoding is not specific   to Python. It's shared among  many programming languages.  So I'll just tell you a  little bit about it for fun.  An original encoding, not the first one ever  invented, but one of the first standards to take   hold in computing was called ASCII, American  Standard Code for Information Interchange.  This was a table that laid out which numbers  corresponded to which letters and symbols.  There are eight rows. And eight is important  because that's how many different rows you can   represent using three bits, three ones,  and zeros. And there are 16 columns,   which you can represent using four bits.
The layout was chosen to support sorting by   character code. So if you've ever used  a computer and found that it's sorts,   capital letters, before, lowercase letters, and  puts things with an exclamation mark at the top,   and things with a tilde at the end, that's  because of the order in the ASCII Code Chart.  It was also designed so that if you didn't  have enough bits to represent the entire   table. There will be a useful subset right  there in the middle. It meant you had to type   in all caps. Well, that's better than nothing.
The control characters at the top, here in red,   are designed for transmission or Information  Interchange. They have original meanings,   most of which aren't used today. But some of  them still are. So the line feed called LF,   was supposed to tell the printer on the other end,  to go to the next line. And if you wanted to get   somebody's attention after some Information  Interchange, you might ring the bell on their   printer. And these things still exist today.  So if I say a is the capital letter 'A', I can   figure out what number corresponds to that A. It's  number 65, which in hexadecimal format, is 41.  41 tells me the row and column of the  capital letter A in my ASCII table.  Oh, there it is. Row four, column one.
If I print the line feed character many   times, I'll get multiple lines. And if  I print the bell character, many times,   I should get a sound coming out of my computer.
Now, there are more characters than just these.   The ASCII standard was English specific. But  the Unicode standard was designed in order to   have one character set that would be used for  all different languages. So it's the case that   for every character, in every language, in every  script that's being used anywhere in the world,   there's meant to be a Unicode code point for it  or a number ascribed to it that lets us refer to   that character as a number and use that for any  kind of Information Interchange among computers,   among different programming languages, etc.
There are currently 109,000 characters,   at least last time I checked, in 93 different  scripts. And they're organized by script. So   it's more than just a numerating all the different  symbols that people use in language. They're also   marked with what's capitalized, what's not  capitalized, what language they're used in,   etc. And it even supports bidirectional  display order. English is written left   to right, but Arabic is written right to left.
And every character has a name. The letter X   is called Latin capital letter X. Now there are  a lot of different characters, 109,000 of them,   including a smiling face, and a frowning face  which are just letters in some alphabet. And   most programming languages support Unicode,  and so you can access the characters directly.  So I type from unicodedata import name, and  lookup. Name gives you the name of a Unicode   character. That's Latin capital letter A. And  that's a Latin small letter A. Lookup does the   opposite. I start with the name, and it gives me  the character. So if I look up the smiling face,   there's that smiling face. I can make it even  bigger, so you can see just how smiley it is.  And there are many more characters  that are a little bit quirky.  There's a snowman. There is a  soccer ball. There's even a baby.  Hello, baby.
Now, depending on the   font on your computer, these will be displayed  in different ways. So I think only on the Mac,   do you see a baby that looks in this particular  way with this haircut. But it could exist on   other operating systems as well. The point  is, there's a character representing baby.   How exactly it's displayed might vary from machine  to machine. But the idea that there is a baby out   there with a particular encoding is universal  to lots of different programming languages. And   you can look at that encoding by encoding it in  bytes. And you see these are the four bytes that   it takes to represent a baby. Whereas the  letter A is encoded just as the letter A.
