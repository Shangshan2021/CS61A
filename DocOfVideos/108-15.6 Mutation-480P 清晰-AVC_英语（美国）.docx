Mutation. Let's talk about what it means for  something to be the same and what it means   for something to change. Once upon a time, we  never modified objects. And at those times,   a compound object was just the totality  of its pieces. There was nothing more to   being a rational number than just what was your  numerator, what's your denominator. But this view   that the whole is nothing but the sum of its  parts, is no longer valid in the presence of   change. A compound data object such as a list has  an identity, in addition to the pieces of which it   is composed of its elements. So a list might still  be the same list even if we change its contents.  So if I have a bound to 10, and b then bound  to that same list a. So what happens here,   a gets evaluated to the list containing  10 and then b is bound to that list.  a is equal to b. If I a.append(20), a is still  equal to b because a is 10, 20 and b is 10, 20.  b and a were bound to the same list even  though we changed its contents. However,   we could have two lists that happen to have the  same contents but are different in their identity.   They are not the same, they just might be equal.
So if I say a is the list 10 and b is another   list 10, a equals b is true. So far, not  too different. But if I append(20) to b,   a is now 10, b is 10, 20. And these two are  no longer equal. They were equal before,   we never reassigned a or b to anything. So  there's no a equals this or b equals that   statement. But it's just that these happen to  have the same contents before so they were equal,   but they were never the same. And so  when one change, the other didn't.
Now, how do you figure out  whether two things are the same?  Well, there's something called an identity  operator, which looks like the word is   and the opposite of is is called is not. So one  expression is another expression if. Both of   those expressions evaluate to the same object.  Equality is true if both expressions evaluate   to equal values. So any list containing 10  is equal to any other list containing 10,   but they may or may not be the same list.  Identical objects are always equal values,   but not the other way around. So it will  always be that 10 is 10. And if a is 10,   and b is a list containing 10, then a and  b will be equal but they won't be the same   list. When two things aren't the same, changes  to one don't affect the other. But c being bound   to b means that c really is b. They're just  two different names for the same thing. So   if I pop something off of c, I've also popped  it off of b. But nothing has changed about a.
Now, one lesson, something to look out  for, is that mutable default arguments   are very dangerous. So as soon as you learn  about mutation, you have to learn about its   risks. A default argument value, when you define  a function, is part of that function value, not   generated anew every time you call the function.
So let's say I define a function f, which takes   some sequence s. And by default, it takes the  empty sequence. And what it does is it appends   5 to that and then returns the length of the  sequence s, after that 5 has been appended. So   you call f, it uses the default argument value,  which is an empty list, appends 5 to it, and   returns the length of that list which contains 5  and you get 1. If you call it again, you get 2. If   you call it again, you get 3. And that's  because every time you call it, s will be   bound to the same value. That's how default  arguments work. And if that default argument   value is mutable and you mutate it in the middle  of your function, then that change will still   be around the next time you call the function  and you get that same default argument value.  So something that looks pretty simple, will  actually have strange behavior, where it's   different every time you call the function. And  that's definitely something to look out for.
In the first call, s is bound to an  empty list. And that list is then   mutated to contain 3. The next time I  call f, s is bound to that same list,   which is mutated again to add another 3. And the  third time, you get the third 3. There it is,   and that's why we get different return  values each time 1 then 2, then 3.
