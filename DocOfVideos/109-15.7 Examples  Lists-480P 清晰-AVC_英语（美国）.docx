Let's review list mutation and environment  diagrams. Names can refer to lists,   and assignment statements can change which names  refer to which lists. In addition, the contents of   a list can change, the length of a list can grow  or shrink, even if the names that refer to those   lists don't change. An environment diagrams help  keep track of all this change as it's happening   throughout the course of execution of a program.  So let's work with an example where s is bound to   the list 2, 3, t is bound to the list 5, 6,  and we perform various mutation operations,   have some example calls and show the result. And  we'll start with the append operation, which adds   one element to the end of a list. So if I append t  to the list s, here's what happens. I started out   with the global frame with s bound to the list  2, 3, and t bound to the list 5, 6. s.append(t)   adds one element to the end of s that refers  to this list containing 5 and 6. It's important   that this arrow doesn't point to the name t. It  has to contain a value. It's the value that you   get when you evaluate the name t, which is the  list containing 5 and 6. Now when I assign the   name t to something else, like 0, that means t is  bound to 0. It's no longer bound to the list 5, 6,   but that does not affect s. s is now 2, 3, and a  list 5, 6. That's a three-element list containing   two numbers in a list, and t is bound to 0.  Okay, let's start over and take a look at extend.   Extend adds all elements in one list to another  list. So s.extend(t) will add to the end of s,   the elements 5 and 6. Now if I assign t(1) equal  to 0, I will change this element to 0. But that   won't affect what's in s, because s just contains  a bunch of numbers. Let's start over once more and   take a look at addition and slicing. Addition of  two lists creates a new list and slicing creates a   new list. These lists contain the elements of the  lists that were added or sliced. And here we'll   do a longer example. We're going to assign a to s  plus a list containing t. We're going to assign b   to a slice of a and then we'll make some changes  to a and b and see what happens to s and t.   Starting at the top. If I added s and t together,  I'd get a list 2, 3, 5, 6. But this is different.   This says build a one element list containing t.  So let's go ahead and do that, even though we're   not going to give it a name. Instead, we're going  to add this list and this list, building a new   list containing the elements 2, 3, and the list  5, 6. So the result of this expression s plus   list t builds a three-element list with 2, 3 and  a list. And we give this the name a. Now before   we move on, we should probably figure out what  to do with this floating one-element list that   has no name. You could leave it there. You could  also erase it because it can't be reached. It was   created during evaluation, but never given a name.  Okay, under the second line, b is a slice of a   starting at element one and going to the end. That  creates a new list containing 3 and the list 5, 6.  Now we can make some changes. a's element 1 is 9.  Here's a. Here's element one that changes to 9.   B's element 1's element 1 is 0. Here's b. Here is  b's element 1. Here's b's element 1's element 1,   and we change that to 0, that actually affects  t. So the result now is that s is a list 2,   3. t is a list 5, 0. a is a list 2, 9 containing  5, 0, and b is a list 3 containing 5, 0. The fact   that this addition and this slice all contained  t, means that a change to t affects all three of   them and therefore, we see three different zeros  referring to the same element of a list. Okay,   let's start over. The list function creates a new  list containing existing elements. So if I say t   equals list s, I get a new list containing  2 and 3. That replaces what T used to refer   to. If I set s element 1 equal to 0, then I'm  changing s, but I'm not changing t because we   copied it. So the result is that s is 2 and 0,  and t is 2 and 3. What about slice assignment?   Here as an example. If s is2 and 3, t is 5 and 6,  and I assign to the list s from 0 to 0 equals t,   I'm saying that right in here, I should have all  the elements of t. Since this slice had length 0,   and this list had length 2, I had to shift  everything else over. Slice assignment from   3 onwards means that this value is going to  change. But since I'm replacing a slice of   length 1 with a list of length 2, I put the  elements 5 and 6 in place. Now t(1) equals 0   changes this value. But it does not change this  value, because the last element of s is just a   number. So those are ways of extending or changing  a list. It's also possible to shrink a list. I'm   not going to draw environment diagrams for these  because I think they're pretty straightforward,   but let's go through the operations. Pop removes  and returns the last element. So if I start with   s is 2, 3, and t is 5, 6, and then assign t to  s.pop, that removes the 3 and changes t to refer   to that 3. So the result is that s is a list  containing only 2 because I popped off the 3,   and the 3 is now the value of the name t. We've  lost track of the list 5, 6. Starting over with   s is 2, 3 and t is 5, 6. What if I remove?  Well, remove removes the first element equal   to the argument. So if I write t.extend(t), that  means t is now 5, 6, 5, 6. And if I remove 5,   then I'm left with just 6, 5, 6. s has not changed  at all. And finally, let's do another example of   slice assignment. That's the same as the thing  we looked at in the last slide. We can remove   elements from a list by assigning empty lists to  a slice. So the slice from 0 to 1 is empty means   that all those elements in the slice 0 to 1 are  removed, leaving only 3 in s. And in fact, if I   remove all the elements from 0 to 2 of t, then  I'm left with no elements at all. So let's put   them together into a couple of more complicated  examples. Let's say I assign t to the list 1, 2,   3. And then I perform slice assignment where the  slice from 1 to 3, that includes elements 1 and 2   is assigned to a list containing t. So let's build  that list containing t. And then we'll replace two   and three with the contents of this list, which is  just a reference to the whole list 1, 2, 3. So we   replaced that with the reference to this list.
Now we have a list that contains itself,   that doesn't make Python explode. And  so we can keep going. t.extend(t) says,   put all the elements of t into t, and all the  elements are 1, and then a reference to t. And   if you print this out, you'd get something that  looks like this. Okay, let's do one more. t is 1,   2, 3, 4. A list with two elements, which are  both lists. If I look at t[0], that's this list,   and I append to it a slice of t. A slice of t from  1 to 2 is a list containing just 3, 4. And that's   what I append. So I build that slice, and I append  it, and I've constructed the result, which looks   like this. I think it's very challenging to move  straight from code to the eventual result without   drawing a box and pointer diagram showing  what's going on. And so I'd recommend that   you get comfortable with this notation so  that you can solve these kinds of problems 