61a lecture 15 q and a uh so the question was what does it mean to reference a list and in the last video there were a bunch of examples of different expressions that evaluate to the same list and each way of evaluating you can think of as a reference so this notice of a reference is i can refer to hani as hani or professor of cs61a or coolest guy i know and these are all like different ways of referring to the same thing and so different references and the same story holds for any object in python but it's really important for lists because lists change and so if you have multiple references to the same list and that list changes then the value that you'll see when you evaluate any of those expressions that refer to that list is going to change as well so we see this in simple examples and moderately complicated examples and really complicated examples so maybe we'll start with a moderately complicated one and then we'll decide whether we should go simpler or more complicated so if you have a list one with another list in it two three and then you have b equals a and c equals a one and then you append four to c this will actually change b and let's see why so if we print b we won't get one two three but instead one two three four in this case a and b are both references to the same list it's this list this box which happens to have as its contents 1 and another list 2 3. 3 c is a reference or a name for the element at index 1 of a which is also the same as the element at index 1 of b because a and b are just two different names for the same thing and that means if i append to c i've really changed a and b as well even though i'm my expression says c that append for anything that contains this value of c is going to be affected as well so when we print b we'll see one two three four as opposed to the original one two three that we typed in because we mutated or changed part of it so let me just inject something here so the the the most important line here is the b equals a line right so that before we were doing this if i had said for example a equals five and b equals six if i changed a b doesn't change yeah so that that's sort of what's a little confusing here but with lists and with objects when you assign one var one list one variable to another variable each of which are now list there's only one copy of the data yeah that's the important part but when i say a equals five b equals a there's sort of two fives out there in space and this is what's nice about these environment diagrams so right after you and you can see it here in the environment diagram b is not pointing to its own list it's pointing there's only there's only one list in memory now both a and b are pointing to it and now i can modify this is sort of what's sort of terrifying and interesting about it is either if a modifies it modifies b if b modifies it modifies a they're just there it's there's only one list in memory and that's the thing to keep in mind when you do what's on line two is you're not making a copy of the list great question so the question is about this example from lecture that involved printing out t and seeing some dots let's see if we can find them oh there they are what is that well let me give you kind of a simpler example that doesn't involve slice assignment just so make sure everyone can follow along so i'm just going to comment those out and make a new t which is a list containing one and then i'll append t to it like what should this look like this should be a list that has one and then within it it has a list that has one and within it it has a list that has one and within it it has a list that has one and within it it has a list that has and this could go on for you know a little while what's interesting is that there is some logic built into python about how values are displayed so for example the fact that a list appears with just one space after the comma is part of how python works now that part about how python works is actually just a function that says whenever it's time to display a list you should display it in this particular way and that function has the following behavior if at any time you want to display the entire list that you're in the process of displaying then don't display it but instead display this dot dot dot to say you know this would kind of go on forever because t contains itself but we don't want to fill your screen with ones and so we'll stop there so uh yeah i i guess we'll study this in more depth later in the course but one of the interesting things is that there's a relationship between this object which is weirdly self-referential and the way it is displayed and the relationship is some function that's built into python but we could write it ourselves if we wanted to that takes in t and starts displaying it since t is a list it has an open bracket since the first element is one it writes one since there's another element it writes the comma and the space and then since the next element is t again it has this special case where it says okay time to draw a list but not display its contents because that would take forever so maybe we'll then go back to this particularly bizarre thing you could do in python which is slice assignment so slice assignment basically says take a piece of the list there's the slice from one to three and replace it with the contents of another list so i could replace it with five six seven and then the two and the three would go away and the five six seven would be there and i would get one five six seven if instead you replace it with something that has a t in it then you get that dot dot dot but i i mean this could have been five six seven and then t and then the dot dot would appear at the end by the way notice too that i mean i mean john said it exactly right that there's a distinction between how the data is being stored and how the data is being printed so in the print it looks like the list goes on forever but in storage it doesn't because that last element is just a pointer back so it's not like we blew out memory having to store this huge list it's not until you go to print this thing that you have to be like oh what's that last element oh it's the first list oh what's the last time of that and now you have sort of a problem but from a storage capacity from a representation capacity no problem at all i just have a self-referential and it's it you can somebody asked in the question can you think of this as sort of recursion you can you can think of sort of like you're defining a list in terms of yourself yeah exactly the list is recursive in the sense that it contains itself also the function that prints out a list is recursive in the sense that what it does is it prints some brackets and then it displays all of the elements and so to display the whole thing you display each of the elements that sounds like recursion to me and it happens to have this bass case which says if it's ever time to display the whole thing again just uh return this special dot dot thing instead of continuing all right great that's good somebody's asking the chat what kind of situation would this kind of self reference be applied that's a good question yeah so um if you wanted to represent a website where each the website is like a list of the things it links to sometimes websites link to themselves and so if you want to simulate the idea of clicking on that link nine times which kind of just cycles back to itself over and over again well you could do that using a python list so there are things in the world that refer to themselves that's why you would use this i don't see like another good reason why you'd use this though maybe there is but i think that's the main one yeah and there's another question is the dot dot dot because of a quote unquote infinite loop that calls t or because it calls itself yeah it is essentially an infinite loop um you can think about it like that exactly so i would say the function that displays the list yeah would loop infinitely if it weren't for the fact that we had this special case and that would be bad so the object itself is finite like it refers to itself but it's really just a list with one two three four five elements but displaying it could take forever if you're not careful so there's that really it's a really interesting distinction i can have something that is finite but that takes an infinite amount of time to display because it's self-referential that's fine right it's like chasing your tail yeah and it's like uh well okay so this shows up in mathematics sometimes i guess we're going too far straight but you could define a sequence of numbers like it starts with 1 zero and then one and then each element is the sum of the previous two is the fibonacci sequence that description was finite yet the sequence is infinite if i wanted to write it out that's kind of what's going on here nice very nice good question so the question is what's the relationship between a selector function and data abstraction versus a dot expression that refers to an attribute of an object in uh object-oriented programming which is kind of what we're building up to and the answer is there's no difference so in a typical program you wouldn't have both you kind of pick how you're going to do things the selector function was there to show you that through data abstraction you could bundle stuff together and break it apart using a constructor and selector functions and this functionality doesn't actually require you to define your own functions it's built into python and we're seeing that for the first time with the objects video today is that lots of different values are in fact abstractions that have their own components and those components and the object system are called attributes you access them through dot notation and so like in a typical python program you don't write a lot of constructors and selectors instead you write a bunch of uh dot expressions that access particular attributes and that's fine uh you know python could have been built another way and you know it is built with a constructor for lists where like you can build a list out of something like a tuple um so that looks basically like the constructors that we had in data abstraction but instead of having just a bunch of functions to access the elements of this value the way python is built internally is that you access the components not through selector functions but through dot expressions that get particular characteristics like uh i i i guess there's this like for list there's this special syntax where you use square brackets but for a lot of different things i guess i should have talked about dates with dates you use uh dot expressions to access the parts so same concept two different ways of doing it you could roll your own which is to define functions so select your functions and constructor functions or you can use the built-in functionality within python in order to use attributes and access them through dot expression and you're basically doing the same thing with slightly different code yeah it's important to understand that that square bracket notation is a selector it's just a syntactically different selector right so all of these it's sort of like um using the plus sign as opposed to the add function same thing it's just a different syntax that just a little bit more convenient because we use it so often so a great question the question is about how slice assignment works which is the weirdest thing in python maybe we shouldn't even teach it in this course but i did so now we'll learn about it it's called slice assignment because we have a slice and an assignment statement and this has its own behavior it's not like you can think about this as you're like first computing the slice and then you're assigning to it instead this whole thing is kind of its own construction and so it has its unique behavior that you have to learn and it's different from how all other assignment works the way that this works is that this must be something you can slice like a list and something you can change well like a list this must have elements so if for example i put five here i would run into an error it would say can only assign an iterable that's the problem is that five is here and that's not allowed in slice assignment it must be the case that you have something that's got elements in it like a list or a tuple or a string or whatever now what it does so we kind of have gotten the domain right we know that this needs to be something that we can slice and we need to decide how we're slicing it and we need some elements to insert now we have to talk about the behavior and the behavior is that s gets modified the way it gets modified is that whatever slice here is removed from s and then at the position that that slice was removed all of the elements of this are inserted into s so s actually doesn't have any elements from zero to zero because this is a zero length slice it does have a position it's like right here before the one but it doesn't include the one or the two or the three because it only goes from zero to zero so if for example i had just taken a slice from zero to zero i would get an empty list because there aren't any elements from the slice from zero to zero but that's not what we're doing we're assigning to this slice and we're assigning some new elements which means we're going to insert into s all of the elements in t which is 4 and 5 and 6 and we're going to put them in a particular position which happens to be at the beginning so we get 4 5 and 6 at the beginning if instead i had sliced from 1 to one that's still a zero length slice but it's in a different place so the four five six would have shown up starting at position one which is where this empty slice would have been it would have been like right in there and so that's where we put the four five six if we hadn't had a non-empty slice the slice from position one to position two covers the two this would remove the two and replace it with the four five six so we get one four five six three i think the reason this exists is that python tries to do this quite efficiently so if you like went through and removed all these elements and then you started inserting afterwards then sometimes that would be a little bit slower than kind of doing it all at once which is to remove the slice and slap in some replacement values instead but it does mean it's like one more piece of syntax that you might want to know and since we taught in the course i guess you need to know it although this is definitely not the most important thing you're supposed to learn from this lecture it just happens to be one more way that you can change the contents of a list good question so why isn't it that t becomes an element of s and the reason is that's just how slice assignment works is that it takes a container full of elements and it doesn't put that whole container in s instead of puts the elements of that container in s now it doesn't necessarily copy those over if for example t had lists in it so t has a list in it then the things i'm gonna do is i'm going to remove the two because that's the slice from one to two you can see the indices here and i'm gonna replace it with the number four this list and the number six so what we'd end up with is one for this list the number six and the number three which was in there before a question of the chat was why can you explain why you cannot insert an integer into a list again in general you can insert integers into lists if you're using something other than slice assignment so if i were just using element assignment then i could put the number five in there let's pick another number the number eight in there no problem and it would just change element number one of s to eight that's okay the reason that uh we ran into a problem is that we were using slice assignment which is this weird thing that takes multiple elements from s and replaces them with the elements from eight oh except eight doesn't have any elements that's why we ran into a problem here is that slice assignment only works if what's to the right hand side evaluates to something that has elements in it like a list so i could have put 910 in here or i could have put t both of those are lists and then what it does is it replaces what was in there before in this slice from one to three with these new elements 910 but it actually doesn't uh put a list containing nine and ten in there it puts the elements themselves and steve's asking why did you use s 0 colon 0 instead of s 0 colon 1. the difference is the s of 0 colon 0 is not replacing any elements it's inserting at position 0.
the s zero colon one is going to replace what's in the zeroth position with whatever's on the right hand side so he could have done that so it's a question of insertion versus replacement yeah so the second version lost the one and michael's asking is s sub zero the same as s zero colon zero yes and no um so if you say s sub zero is equal to something then you are not using that slice assignment operator so it's different then you're allowed to have whatever you want on the right hand side yeah so distinguish between list assignment with a simple index and the slicing assignment as john said earlier on is a thing in and of itself it is distinct from other types of assignments yeah let's just try to get these two things next to each other because they do have different pictures and the differences in the pictures is important but it's hard to keep a track of it all at the same time so slice assignment took all the elements in t and stuck them in s so now s which used to have three elements has six elements y6 well it had three and we put three more in it this which is not slice assignment but instead element assignment just replaced whatever was in position zero of s with a reference to t and so we lost the one remember in this one we didn't lose the one and here we lost the one because we replaced the one with a reference to t there's no fours and five fours and sixes in here anymore there's only t and this used to be three elements long it's still three elements long element assignment never changes the length of the list it just changes what's in it slice assignment is different it changes the length of the list it replaces an existing slice with some new elements audrey's asking when we do the list slicing does the iterable that we are setting the list sliced to need to be the same length longer or can it be shorter than the existing list slice it can be anything you want so so the iterable i'm sorry and the slice can be zero you're inserting it could be of length one two three or anything you want and what you're going to do is think about it this way so on the left hand side with the slicing you say grab those elements throw them out and then take whatever's on the right hand side and shove them into the position so they can be longer shorter it doesn't matter and something that does show up once in a while is that you'll have some long list and you realize oh i don't want some of those elements so you might slice them out which would mean uh finding the slice you want from element two to element five let's say so that's the three the five and the six and we could assign that to the empty list meaning take those elements out and replace them with nothing and then they're gone so that's the that's the most common use that i use for the slice assignment operator is to just annihilate things from a list that's actually not that uncommon to do something like that the next question was what's the difference between a tuple and a list and what does it mean for one to be mutable and want to be immutable and there's kind of an underlying question of what's the point of all this the unspoken question is why do i care  man i don't know how to answer that okay so if i call tuple on s which is a list you know it's a list because it has square brackets this says give me a tuple with the same elements as s so now we've got two different objects one's a list one's a tuple they got the same thing in it but they have slightly different behavior and the right way to think about a tuple is it's like a list except for it doesn't allow you to do a bunch of things that you would otherwise like to do slice assignment on a tuple not allowed so you don't have to know how it works because you can't do it anyway element assignment not allowed appending not allowed extending not allowed you can't change the content like the length or which elements are in a tuple so there's nothing i can write that would take this tuple and change this 3 to a 9 or change it to a reference to this list or something like that it cannot be changed i could do a lot of things anyway like i could reassign t to something else so i could say u equals t and t equals nine and for this reason it's not the name t that can never be changed it's the tuple itself that can never be changed the important consequence of this is that if i say u equals t and then i write some expression involving t it will not affect you unlike a list right look at the distinction here if those were lists they would have modified the list exactly but since this is a tuple can't be modified no matter what i do to t that's allowed which a lot of things aren't allowed you can't depend you can't slice a sign you can't element a sign or whatever but you can do some other stuff you can take slices or whatever won't affect t so if i slice this from element 3 to element 6 that is allowed and i could call that v but that hasn't changed u u is still one two three four sorry one three one two three five six seven uh i don't know what happened to four along the way but oh well um so uh that's the difference is that you know a list you can do a lot of different things with you can slice it you can get elements but you can also change it topple you can't do some of those things but you can do others you can still slice it you can still figure out its length you can still build a new one but you can't change it in any way that's what makes it immutable whereas a list is called mutable meaning mutation applies meaning you can change it but now i guess we should say something about why yeah and i guess there's there's really two reasons one is a little bit about efficiency sometimes a program will just run faster if it's using a bunch of tuples instead of a bunch of lists because they can take a little bit less space in the memory of the computer but the more common reason is that people are designing their programs so that they don't have to think about mutation back when you could just describe every function by its domain range and behavior life was easier i'm not saying it was easy there were plenty of like tricky recursion problems and stuff like that but at least you knew that if you called a function the only thing you really have to worry about is what does it return not what does it change and if you use tuples everywhere since they can't be changed you kind of don't have to think about what does it change you just have to think about what it returns whereas if you're using lists everywhere if you're not careful the consequence of calling a function will be not only that it changes something or that it returns something but also that it changes something and that's like twice as many things to keep track of when you're writing a big program and trying to understand how all the parts work so that's like the main reason to have some immutable version of a sequence is just to like make sure you write programs in such a way that nothing can change anything else except by passing in arguments and returning them it's it's called side effects the thing that's scary when you call a function is there some side effect that it that goes beyond just what was passed and what was returned it modified a list and i how did i how do i know that that how do i control that and so the tuples are nice or tuples which one do you call it john i want to call it the other one uh i've been calling it tuples all the time so you got to use tuple for a while all right i'll use that we'll switch in a couple minutes all right good so the tools are nice because it's essentially like you're locking your data right it's giving you data security yeah um a follow-up in the chat was what happens if my couple has a list in it so this temple is immutable in the sense that it will always be length three and it will always have this particular list in it so the the the aspect of this that's immutable is that it will always have three elements and they always will be the number one this list and the number seven that those facts cannot be changed however this list might change and the fact that it is part of a tuple will not control what's allowed it's still a list you can still do whatever you want to it so if i give it a name i say t is s1 and then i start mucking around with it i append five all right you know we've been well okay i wasn't i was about to do slice assignment but i think we've done that to death today okay then uh now in a sense the contents of this tuple has changed the tuple itself has not changed it's still one this list and seven but if you were to print it out you'd see something different than you did before because you'd see one three four five seven instead of one three four seven so being immutable doesn't mean that nothing about you can ever be altered it just means that this this particular part of the environment diagram never will change yeah good question so when is a value protected from mutation there is not a mechanism in python to take a mutable value and protect it from mutation somehow if a value can be changed then anything that can access that value can change it that's just a fact about how python's designed this is not true of other programming languages there are programming languages that keep track of for each function that can reference a value is it allowed to change it or is it not allowed to change it c plus plus is a good example of this and that is like another element that you could add to a programming language to give yourself kind of more control over whether something can be mutated or not but that's not something that python allows instead it's part of the value to say this value is something that can be changed or this value is something that cannot be changed and so lists can be changed temples cannot so what about writing python how do you make sure that you don't accidentally change something well if you have a list there are actually only so many ways that you can change it you can use element assignment or slice assignment that will change it you can use one of the mutation methods like append or extend that will change it um if you don't use any of those then you're not going to change it so for example if you just slice it that doesn't change it why not because we don't have an equals here if we don't have an equals we just have like t equals this this doesn't change s let's just build some new list with some of the elements of s so as long as you're not doing element assignment or slice assignment or appending or extending or removing or popping or all these other melt methods that perform mutation then s will not change and so that's the mechanism that you have to verify that you're not going to muck with something that you don't want to muck with is that you don't use any of these now to kind of be extra careful a lot of times what people will do is they just won't use s at all because they want to make sure they don't change s so they're not going to use s they could instead make a copy of s this is really building a new list with all the elements of s and then they write all their code about t the nice thing about this is that if you accidentally change t you haven't changed s so that's like a sort of uh heuristic mechanism for trying to guard against accidental mutation is that you could try to avoid using this list at all but instead use some other list um but that isn't like not really any kind of guarantee that it's impossible to mutate us uh it's just a way of avoiding it the next question was if you have two lists s and t and you append s to t and then change s to that effect t and if so how i think the answer is that it would if t is 4 5 6 and then you append s to t now t is 4 5 6 followed by the list 1 2 3 but this is a list that can be changed and whenever it's changed then all of the ways of referring to it are changed as well including looking at t's element at index three and so if you print out t at this point you'll get four five six followed by the list one two three four because you changed this list that's in it okay so the question is do you ever have a function f of x that takes some optional second argument that is something mutable and is this ever like a good idea my take is the answer is no this is never a good idea but i have seen people use it before they could for example try to write a function that returns the sum of everything f has ever been called on so we're gonna i guess we don't need to print we're gonna call f on 2 then we're going to call our f on 1 then we're going to call f on 3 then we're going to call f on 5 then we're going to call f on 7.
this first call is going to return 1.
the second call is going to return four the third call is going to return four plus five is nine this last call is going to turn 16.
you know don't do this but i've seen it done so i guess you might as well know that someone else might do it what's going on here is that we're using the default argument's value as some kind of persistent storage that's part of this function that's kind of keeping track of everything that this has ever been called on the reason this is extra weird is that you could call f on you know some new thing and then it wouldn't behave the way that you wanted it to behave at all like uh instead of summing one three five seven and nine it would sum nine and one is ten which just like is inconsistent with everything that's happened before so nasty nasty feature of python by the way i think it's ridiculous that it works this way yeah so this is this is something to avoid by knowing it exists as opposed to something to exploit or use by knowing it exists is that the default argument value is part of the function which means there's kind of only one of them and so if you wanted to mess with it you could but don't uh one quick question we'll get to the last hand raise the question is is the default value in a function defined in the global frame i don't know if it's actually defined in the global frame but it effectively is that's what it's doing it is true that this expression here is evaluated in the global framework shouldn't you use x just do something else because this is evaluated when the function is created not when it's called uh okay so like none of this would work anymore but we could like return y of x or something like that and uh could we refer to something globally i think the answer is yes see if i'm right yeah so when you create the function before you ever call it we never called it it not only creates the function but it creates the default argument value which means evaluating this expression if this expression is two square brackets that makes an empty list if this expression is some lambda then it creates a function yeah yeah i don't like it don't do that so the question is what is the difference between a class and an object the class is so here's how i think about it think about a blueprint for a house is the class and the house is the thing you build from the blueprint okay so i can have a class date um that is the sort of the definition of the data i'm storing and the functionality of it and then i can instantiate i can create as many of those objects as i want so they're essentially realizations of the thing that you've created so the class is just it's sort of like a definition nothing exists and then when you create an object well now i can sort of do things with it so there's a class of type list and then i can define lists i can define one list two lists 50 lists whatever i want yeah yeah and that analogy is nice because you can live in a house but you can't live in a blueprint right like if you just have the class you can't really do anything with it until you construct one of the things that it describes build the house and then you can go live and you can go live in it right and it's sort of like a function definition right you define a function but doesn't do anything it's just a definition it just hangs out in the global frame somewhere but then when you call it ah now we're actually doing something and uh you're not supposed to know this all i mean it's fine that you know it but we will cover this fact of the relationship between classes and objects next week so it's for those of you that are a little hazy on what's going on um that's because we haven't not yet in this class defined our own class or really looked at what's inside of one but we will yeah so what's to come is we've been using the built-in classes and of things like lists and dates but i don't think it'll surprise you that we can now start building our own classes and our own data representations and our own functionality i saw one more question in the chat let's see if we can get it is a range a couple it's kind of like a tuple but it's not a tuple it's range [Laughter] for the same reason that like you can make a really long range that goes from one to whatever that huge number is but you kind of can't take make a really huge tuple that goes all the way to this number so tuples have an explicit representation like all these values are sitting around in memory somewhere whereas this is a implicit representation of a range of numbers which may be very long but you really just have to remember the beginning and the end in order to talk about the whole thing so in that sense ranges and tuples are different now they have similar characteristics which is that they're both immutable sequences so like uh tuple could have anything in it it could have lists it could have strings a range can only have numbers in it but it's true of both of them that you can't do slice assignments you can't extend or append or anything like that 