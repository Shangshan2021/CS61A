let's talk about the details of non-local assignment a non-local statement has the following effect future assignments to the name change its pre-existing binding in the first non-local frame of the current environment in which that name is bound and the Python Docs this first non-local frame is called an enclosing scope it is possible to have multiple names separated by commas in a non-local statement and there are restrictions on exactly what names you can put there these are directly from the Python 3 language reference names listed in a non-local statement must refer to pre-existing bindings in an enclosing scope so these names have to have already been used and the names listed in a non-local statement must not collide mean be the same as pre-existing bindings in the local scope or the current frame as we call it in this course so you can't declare something non-local if it's in the current frame already but it must be in a parent frame or the parent of the parent somewhere between the global and the local frame in the chain of frames that makes up the current environment if you want to read more yourself you can find all the Python docs online so you see x equals 2 somewhere in a program based on the context of that program it actually might do different things so here are the many meanings of an assignment statement if there's no non-local statement and X is not bound locally already then this creates a new binding from X to 2 in the first frame of the current environment the current frame if there's no non-local statement and X is already bound then it reminds X the previous binding is lost this all happens in the first frame of the current environment and these two conditions are old but what if there is a non-local ex statement four x equals two then it also must be the case that X is bound in a non-local frame the effect is to rebind X to 2 in the first non-local frame of the current environment in which it is found the old binding is lost if non-local ex is declared but X is not bound in a none local frame then you get a syntax error and the error message will say no binding for non-local ex found if non-local ex statement occurs X is bound in a non-local frame but it's also bound locally which is not allowed then you get a different syntax error that says the name X is a parameter and non-local the exact text of these errors will change over time with different implementations of Python but they correspond to the two conditions that we saw on the last slide X must already be bound but it cannot be bound in the current frame now these are general rules for binding non locally and they occur in many languages there's one feature that arises it's particular to Python that you just have to be aware of Python actually tries to pre-compute which frame contains each name before executing the body of a function within the body of a function all instances of a name must refer to the same frame which means you're not allowed to have the same name in the same function body actually refer to two different frames that just doesn't work so let's say I tried to write the following program which is the same as we saw before but deleting the non-local statement the error would arise here if amount is greater than balance what would happen is by inspecting the body of withdraw Python would have concluded that balance is a local name because it has local assignment statement right here remember we deleted the non-local statement so believing that balance is a local it will only look in the frame for withdraw for that name balance and we'll never find the one in the enclosing scope and so you'll get an unbound local error local variable balance referenced before assignment so everything worked before but now we're going to remove the non-local statement I'll just comment it out so you know where it was but it's not gonna do anything anymore because now it's just a comment I can still call make withdraw because that just creates the function but as soon as I call the function I get this unbound local error and it says it's on line four which is here now this is just such a weird thing because we've always been able to refer to balance even if it's an enclosing scope before and that ability hasn't changed except for that local assignment to balance and non-local lookup of balance cannot appear in the same function because balance has to refer to one particular frame and in this case it's trying to refers to now if we got rid of this line we'd be back in a situation where we could call this function it just wouldn't do anything anymore but it wouldn't cause an unbounded local error so this is a quirk of the Python language that just as part of how it's implemented and something you need to be aware of as you start using non-local statements now using non-local statements is not the only way to create a mutable function instead I could use an existing mutable value so here's an alternate implementation of make withdraw it takes in a balance puts balance in a list with only one element remember that lists can be changed and so what def withdraw ammount can do is check and see if the amount is greater than the balance that's stored within the list B if it is then we return insufficient funds otherwise we've reassigned the element at index zero to whatever was before - amount and return that value here we see the name be is bound outside of the definition of the withdraw function which means that all calls to withdraw can refer to that same B and that B can change because it's a list and we can change it using element assignment which changes a list so the environment diagram for this version of make withdraw looks a little bit different let's take a close look we create the make withdraw function now called make withdraw list we call it in this line with an initial balance of 100 but instead of referring to that balance we're gonna make reference instead to a list called B which contains the balance originally with a hundred in it each call to withdraw in this case one with 25 as the amount will update this mutable value of this list to contain a new number used to be a hundred now at 75 now we don't have any non-local statements because we're never changing what B is bound to or what balance is bound to or what withdraw is bound to from within the body of withdraw so we don't need to make any non-local assignment instead all we're doing is we're changing mutable values so these are two different ways of having persistent local state inside of a 