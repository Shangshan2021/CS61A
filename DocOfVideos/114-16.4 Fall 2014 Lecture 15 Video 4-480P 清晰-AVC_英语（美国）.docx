we really understand why local state is called local state when we look at what happens when there are multiple mutable functions in the same program so here's my implementation let's first say that John has a bank account represented by a withdraw function where John has $100 and it's friend Stephan also has a bank account with $100,000 so John can drown as a function Stephan is a different function and they're not the same and they're not equal and why is that well they're representing different bank accounts with different amounts in them so if John withdraws 10 and then draws another 10 Stephan has an entirely separate account with a hundred thousand in it and he pulls out maybe a thousand at a time but notice by doing that he's not affecting John's total so if John takes out another 10 it's just marching down the balance that John has within its function Stephan has this separate balance with a thousand in it and so it can take out another thousand whenever he wants but if John ever tries to take out a thousand well that's not gonna work out because there's so little funds in there and it's more reasonable to take out just one at a time or if a really important purchase comes up then of course John could take out a whole sixty Stephan on the other hand gonna be pulling out 10,000 at a time no problem or another 80,000 or another 7950 now we've reached a point where both Stephan and John have the same but there's still not equal because they're different accounts they're still not the same the only sense in which there is some equality relationship there is that if they both withdraw the same amount at this point then their balances will be equal so just for this brief amount of time John has a balance of 50 and Stephen has a balance of 50 but John just withdrew a dollar and so now they no longer have an equal balance so we've reached a point in our writing of programs where we've lost something called a referential transparency perhaps this was something you didn't even know you had let me tell you what it is expressions are referentially transparent if substituting an expression with its value does not change the meaning of the program so let's say I have just multiplication in addition to call expressions that are used in order to make some computation this was from long ago in the course in a referentially transparent program if I replace mole for 6 by its value 24 I have a program with the same meaning so it's an expression that still evaluates to the same value if I again replace add 2 and 24 with its value 26 I still have the same program it looks different of course but it has the same meaning everything evaluates to the same thing now this is only true when we have referential transparency mutation operations undermine that because they do more than just return a value they change the environment so this expression would be different from this expression if adding somehow changed the environment in addition to adding together its arguments now adding doesn't these are referentially transparent expressions but when we have mutation which is the enemy of referential transparency then you run into trouble so let's take a look at an example where referential transparency is lost this example is also just a good practice for understanding non-local assignment so I would suggest you try to work through it to yourself before you watch me okay here's what's gonna happen well define an F and then we'll call it on the argument 1 so X is bound to one in a frame F 1 immediately we rebind X 2 4 and then we define another function called G which gets returned let G function is returned and bound to a in this assignment statement and that we call a on to so what's a well a is this function G and G of Y gets bound where Y is equal to 2 introducing a new frame the G frame with Y bound the 2 which defines another function H and returns it and that return function H will be bound to be according to this assignment statement so now we have a and B bound to G and H respectively and what we're gonna do is call B twice in the first call to B I'll pass in the argument 3 for its formal parameter Z ok so we've made a call where Z is bound to 3 and X is declared non-local and then X is rebound to whatever X is currently plus 1 we have to look through the current environment which starts with F 3 and then goes to F 2 and then its parent is F 1 and its parent is the global frame and find the first occurrence in this chain where X is bound which is here in the F 1 frame so any change to the value of x will be a rebinding in this frame in this case we change it from four to five and we return x y&z well there's the it's three there's why it's - there's exits five and the total is 10 so let's remember this for a long time this thing evaluated to ten we have to remember it because we still have to evaluate this thing so the total will be ten plus something else okay what's this something else well it's what you get when you call the H function on for which rebind X - X plus one HX well let's look we're first looking at for there's no X then we look at F - there's no X then we look at its parent F 1 there's the X that's the one we're gonna rebind now it's 6 instead of 5 and we return 4 plus 2 plus 6 is 12 10 and 12 together gives us a total of 22 so there's an interesting example of how non-local works but what about referential transparency well this used to equal 20 2 and B 3 evaluated at 10 but what if instead I replaced this function call by its value and then I visualized the execution the difference now is that the effect of calling B would never have happened because I used it value instead and so the total is 21 there was never a second call to the H function because I just used the value 10 instead of calling beyond 3 and therefore X only got incremented once instead of being incremented twice from 4 to 5 to 6 so this program has a different meaning from the one where I wrote B 3 and the reason they're different is that now I have functions that cause mutations referential 