61a lecture 16 q a well while we're waiting for a question let me ask you john what do you do you ever use the non-local construct um it's pretty unusual to use it is that mutable values and non-local assignment are quite interchangeable yeah and python was originally designed without it which is kind of interesting yeah and then um there was kind of a push from the community that gives feedback to python that they should support this because it is a kind of natural thing to do in specific circumstances where um you're trying for example not to use mutable values but you still want to have like certain functions have access to some value that's in a in a parent frame so um it also kind of comes up in the context of this course as we talk about higher order functions enough people wonder how come i can't kind of change things in the enclosing environment that i can read from well it turns out you can yeah but the consequence is very similar to the consequence that you get with mutable values which is that uh now functions might change how they behave and this is kind of the simplest possible way to do it but you know you could also do it with a list or something like that yeah yeah i i'm not crazy about the construct it's it's it does it's there's something about it makes me uncomfortable anyway um i i didn't realize that it wasn't part of the original python but it does fee it does have that feeling of something that was added in later yeah the um the the particular way in which python allows for non-local assignment which is that you have this non-local statement is weird and that is clearly a symptom of them adding it late it was it was it was an afterthought you can see the construct okay okay so the question was about uh when a list refers to itself like what's going on there and um there was a particular example from lecture last time that i think it looked something like this that looks right something like that well let's talk about this example so a very curious thing happens here where when you try to display this you get something that's not just full of one twos and threes and lists but also this elided portion uh this is an ellipsis basically to say this is just the whole thing all over again so if you look at what's actually in here the len of t is 2 t 0 is 1 and t 1 is just t again and um there's lots of ways to get a list to contain itself but they all do involve some kind of mutation like assignment or sorry like a slice assignment which we have here or using append or extend or something like that um and uh what we've done here in particular is we've said replace elements from one to three so that would be element one and element two with the contents of this list and the contents of this list is actually just one element that element happens to be t and so uh you get this structure and this i i find not the most easy thing to read so i prefer looking at this as an environment diagram so you can kind of see what's going on and if we do the same thing there we'll see that one of the elements of t is in fact t so while john's doing this notice there's there's two things going on there there's how the list is being stored and then how it's represented when you try to print it and those are distinct things that's right so this is the storage is this t is a name for a list with two elements whose elemented index one is that same list and then how on earth would you print this out well um python does it this way yeah so the the the representation of the list is finite but the printing of it is infinite because you have to keep referring to yourself you keep chasing your tail essentially a follow-up question was could you refer to the zeroth element of the first element of t good let's try that you could so once you got t1 that's just another name for t and so its element at index zero is just the number one and in fact its element that index one is just t again and that's t and that's t and that's t and that's the one at the beginning of t so i could have an arbitrarily long referring expression but really all we're doing is just deciding how many times we want to re-refer to the same thing the question is about how you compare different node labels in a tree that don't have kind of a direct relationship like comparing the parent to a child pretty straightforward because whenever you have a tree you can refer to the parent label as just label and the child label as the label of a branch but what happens when you want to compare things that are kind of farther apart and that does involve recursion usually and some mechanism for getting the information in one part of the tree available as you're processing another part of a tree so um i guess uh there's two kinds of questions there's questions that involve just like some fact about all the labels like what's the second largest label in the whole tree and in those you kind of want to process the whole tree but as you go you need to keep track of what's going on so i think you'd have to keep track of both the biggest and the second biggest thing you've seen so far and whenever you see something that's bigger than one of those then you need to kind of update that so that's one kind of problem and another kind of problem might be for two nodes at the same depth but not necessarily direct siblings um which one's the biggest or something like that like yeah what's the largest difference between two nodes that are at the same depth and this um it similarly involves just processing the whole tree but at the same time keeping track of an additional piece of information which is what depth you're at but let me offer another thought here is processing data in a tree is just a slightly more complicated than processing data in a list so in a list you have neighboring elements right there are indexes different by one in a tree you have the parent-child relationship but if i want to know for example that john was just saying you know what's the smallest element in the list i've got to traverse the whole list if i want to know what the smallest element in the tree is i have to traverse the whole tree and there's a couple different ways of doing that you can go all the way down and then start making your way back and then the only other example i could think of too was that same notion of maybe you want to come because there's there's another sort of dimension if you will to a tree it's just not the ordering there's sort of the depth ordering that's that's the only other thing i can think about in which case as you're traversing a tree you have to keep track of that information and then sort of analyze things at the back end okay let's take a look so the question was about this um quiz four from the exam prep section question one a quant firm has enlisted your help in maximizing their trade profits you know ahead of time how much profit you will make by executing each trade these values are stored in a tree however if you decide to trade a stock represented by some node s you are not allowed to execute trades that have an edge directly connected to s for example if you choose the parent you can't choose the child i think that's what's going on um return the maximum profit you can make based on these constraints and then there's a skeleton which involves saying oh the profit of the tree involves calling a helper on a tree and something that we're going to track that something might be whether we are allowed to do anything on this level or not or it might be something else i guess we'll see so i guess unfortunately it appears that this question is using a representation of trees that we have not taught you yeah and that we do not plan to teach you in this semester so i would say that the template here is problematic and we should ignore it instead try to solve the problem using the tree representation that you do know because we don't have any like none trees and we don't have any lefts and rights and things like that uh but we could still solve this problem with the tree representation that you do have and uh how would we do that so profit of a tree let's get ourselves an example um return the max profit and uh here's an example tree oh it's big one isn't it two at the top we've got a three my goodness it's going to take a while isn't it maybe it was a mistake to do an example maybe we'll do a small example and uh then we can make it larger if we really feel like it okay so in this particular tree if i took the two then i wouldn't be allowed to take the three and the four uh but if i take the three and the four that's allowed because they're not directly connected i guess we need to make it just slightly more interesting and we'll put a 5 down here so if we take the 4 we can't take the 5 but we could take the 3 and the 5 or the 2 and the 5 or the 3 and the 4 and the best would be to take the 3 and the 5 which would give us 8.
how might we do this well i agree we need to kind of keep track of some information as we go basically to decide am i allowed to use the values in this part of the tree or not and there's a constraint which i think says uh once you've used a label you can't use any of the labels of its children so um if i were to come up with a helper uh i think it would take entry and say whether or not we had used the parent and at the beginning there kind of is no parent so we don't need to do that um uh used parent okay so if we use the parent then we're not really allowed to use any of the current labels the best we could do is return the sum of the results of using the branches okay john in the chat steve is saying that you can't use his children or parent well that's right um i i think that if you impose a constraint that like if i don't use the parent i'm allowed to use the children and i do that everywhere yeah then i've kind of covered the constraint in all ways like basically uh as long as i make sure that whenever i use a parent i don't use a children a child then i've also made sure that like whenever i use a child i don't use the parent because it's kind of symmetrical that way um well i got long didn't it um but if i don't use the parent then i kind of have to decide like am i gonna use this current label or not so i think i have uh i could use it which would mean that uh i have the label for t as part of my result um so i've used the current label uh all right let's do this way we'll add to the total or everything that we find in the branches or i could start with a total of zero meaning i don't use the current label but that means i'm allowed to use the children then i think what i want to do is well maybe the total is the wrong word well okay total plus equals the sum of everything i use below where i'm deciding whether i use the label or not this time something like that the hardest part of programming during these things is that zoom has put like all kinds of stuff on the screen that i'm trying to avoid clearly this did not work making up a problem and trying to solve it together seems to have caused an issue um i think what the chat may be somebody in the chat said you have to compare the two totals and i think that's right yeah okay so this is what i was supposed to do um there's kind of a version where we okay so this is like a total one and there's a total zero there's a terrible way to write it but we'll do it this way anyway then we'll clean it up later do you need two different used labels now uh oh no you don't oh okay so i think you should okay so that works okay so let's write it this like a normal person would write it which is basically like uh keep making it longer so this is the use label total and then the skip label total which involves i'll write this out explicitly not using the current label but in this case you don't get to use the children and in this case you do sorry john what's label zero yeah we're getting close um now you have to fix your max max now yeah we're getting there okay so passes for our one example and i guess you have to trust us that it passes for the rest of them um this expression here and this expression are the same so there is another way you could write this which is to kind of assign this to a name and use it twice and that would probably be a reasonable thing to do but in both cases i guess we are illustrating exactly the general principle we were talking about before which is that sometimes as you traverse a tree you have to keep track of information about the rest of the tree that you can't see right now so at the very beginning you can see the whole tree but later on as you're making recursive calls you can only see the current node and what's below it if you need information about what's above it like whether you included the parent and the total then you need to keep track of that information by passing it as an argument and this recursive call is telling the function that's going to process this branch some information about what's going on above that branch that's a good comment uh the chat says we always see people who know the solution solve the problem seeing the way someone approaches a problem for the first time is really helpful i think that's true by the way it's always easy to solve the problem when you know the answer um it's good to see this sort of iterative approach and the mistakes that we make okay well let's see uh yeah great question so why is it the case that when you're performing local assignment and also trying to read a non-local variable you get the error in the wrong place so uh let's illustrate this with an example and see why it seems like it's the wrong place you get an error here where everything we know about python so far says that there should be no error here you want to print x plus one so you figure out what print is it's in the global frame no problem you figure out what x is you you don't find it here so you look here and you find an x and so this should print four um all programming languages have some quirks uh this is a particularly nasty one that exists in python it exists i think because um you know the there are two central concerns in programming language well there's many concerns in programming languages but two of them are it should be easy for the user to express the program that they want and uh that program should run reasonably fast there's this particular optimization i think python does which is that it has a constraint that says all the names within a function that are the same so like all the x's within this body of g have to refer to the same frame that's just like a restriction that exists in the language that means you can't have two x's in the same body where one refers to the global frame and one refers to the local frame or something like that and they do this so that like basically when you're figuring out what your program means and you're going to execute it it's easy to figure out like where in memory something lives i think i think it's sort of an optimization but why isn't important i think as a programmer you just need to know that this is a constraint so there's no way to write a program that kind of accesses this x and then changes an x in here and this line would in fact change an x in here as opposed to anywhere else this is local assignment so why is it that you get the error here instead of here well in some sense you could say like python's broken and that's a perfectly reasonable reaction um there is an error so whether it shows up here or here i don't know if it's that big of a deal like there's a problem with this code and python is telling you there's a problem with this code and so you got to go fix it i would have if i were designing the language i would prefer for the error to like come up somewhere else or to say something other than this because this is particularly misleading the error really is that you're trying to use an x from the f1 frame and then assign to an x in an f2 frame and that isn't allowed x needs to refer to one particular variable in a particular frame whenever it's uh used multiple times in the definition of the same function so one way to think about it is um the problem is not so much line four it's really the combination of line three and four it's that you're using the variable in different ways so if i had taken out line three line four would have been fine so that's a one way to convince yourself that you know it's the combination of the two lines so you may as well do it in the first one but it also means that python knows what's happening downstream right it's not it's not blind to the code it is about to evaluate yeah yeah this is the particularly spooky part i think for students who see this is like well you mean python knows the future of what the rest of the code looks like and in fact it does so there's multiple stages to interpreting a program and one of them is just to read the code and make sure that all the parentheses line up and all the brackets line up and actually that happens for your entire python file before anything gets executed is that it kind of does a syntax check now that syntax check in python tends to be a little bit more involved because it's trying to set up the program to run quickly so it doesn't just make sure the parentheses are matched it also figures out that for every name which frame is it going to refer to and so it has kind of looked ahead at your code to figure out is this a local x or is this a non-local x like where in the environment is this x going to be and it saw this line and determined it was going to be local and then when it tried to execute this it didn't find that x defined yet and so that's why you got this particular error but that's just like a detail of how the interpreter works not so much about the language but like about how the language mechanics actually run which i guess now you know but uh the mistake of having x try to refer to two places at once is something that like everyone should know because that's a constraint about the language and by the way i agree that the error message here is awful right they should be able to give us a better error message than that yeah the next question was about summer 2020 midterm two question seven all right i guess i'll have to read the question here we go the village operation takes a function apple that maps an integer to a tree where every label is an integer a tree t whose labels are all integers and applies apple to every label in t to recombine this tree of trees into a single tree simply copy all of its branches to each of the leaves of the new tree well i definitely need an example for that oh i don't know about these exams i didn't write okay so uh if you have a tree uh if you have a function that builds a tree of x x plus one and x plus two and a tree that looks like that oh i see so i think what's happening is i see all these branches showed up here and they showed up here okay that sounds reasonable fascinating so take a look understanding this write down that it creates two trees one with the result of x plus one to every label and one to the result of x plus two at every label and then creates a parent no it uh finds the root label 10 yeah passes it into this function to create 10 11 12.
yeah and then for every branch of the old tree ah does the same thing except it does it multiple times it does it here and i guess i can't highlight this i see right so over here and it doesn't there gotcha okay okay so we get a helper function called graft which says graph the given branches onto each leaf of the given tree and then we're going to call graft on some tree and some branches and your question was how come these aren't part of graft or how come they're indented the way that they are this structure says define a new function called graft which in principle has access to the apple function and the t which we might need um and then after you're done defining this function build some new things a tree and some branches and then call graft on those two things let me just start with one obvious thing because i didn't notice this until you scrolled up john is that that that graph function is embedded in a larger function so the three lines that you're seeing there base tbs in return are the body of the parent function it's just that the comments are so long you can't see the header all right let's see if we can make some progress because why not uh so we need to build we need to call apple on the label of the tree we need to [Music] um kind of recursively do this i think uh we either do it now or we do it later it's not clear to me how this is set up uh john can you make that a little bit bigger oh sure thanks no better so i guess we need to know what we're going to graft on and that will be the result of calling village a branch of tree using apple apple's the first argument for every b in branches of t okay now we do the grafting and what does that grafting look like well if t is a leaf then to graft these things on what a strange structure we have here so are we making a tree do you have to return a tree with t in the node and bs as the children is that right i guess what we could do is we could uh graft these branches on all to onto all the branches of the tree i was thinking that was going to be our base case i wasn't expecting a recursive call there yeah i'm just trying to fit the template yeah okay so now we've got a leaf uh oh i see so they're trying to set us up to do this here i think yeah that makes more sense seems like this template has multiple possible solutions but we'll uh do it this way okay so to if we reach a leaf then we create a tree with a bunch of branches otherwise we do this recursively and create a tree with these new branches it looks better that works at least for their one example let me describe how we got here and then you know they only gave us one example so it might be wrong but it seemed like it basically worked it felt like in order to build this monstrosity from this original part we needed to go through and call this apple function on 10 and 20 and 30 and anything else that was in the original t so you get this like typical pattern for that like how do you call a function on every label within a tree you call it on the current label and you call it on everything in each of the branches and fortunately we have a function that does that that like recursively calls apple on everything in each branch so this structure gives us a sense that we're going to be calling the apple function on every uh label in the original t and what's unusual about this function is how you put together the results because instead of like just getting a number back you get a whole tree back there's no like good way to place all these trees so whoever invented this question decided that we were going to duplicate parts of it all over the place and then graft them in and that's how we came up with this okay so so this basically says go until you hated leaf and then put all the branches on that leaf and otherwise uh go search the tree until you find leaves so this is a fine way to do it yeah good question so the question is um how do you like since we the output tree is a different structure than the input tree how is it that we have kept track of the original tree well enough to build the output tree without kind of getting the two confused with each other and without changing the original tree so one thing about changing is that we are just building new stuff all the time we're not editing the contents of the original tree we know that because we don't see any append extend element assignment slice assignment anything like that all we're doing is going through the original tree and building new trees along the way um now how is it that we're building these new trees and still kind of keeping track of where we were in the original tree and that's a great question we're kind of relying on recursion to do that for us so when we make a recursive call to village we're making it on branches of the original tree so all those calls to village that will happen along the way because of the recursion are going to be processing parts of the original tree and there's no risk that they will instead be processing something else because we only call village on parts of the original tree which then calls village on parts of that original branch etc and the building of the new tree with the new structure only really happens in the return value to village which does have this like unusual structure with a lot of repetition in it but but but that all gets constructed after you've kind of gone through and made sure you call village on each note okay so great question the question is what's the difference between adding two lists using plus versus using append when you use plus you create a new list so if i have a and i have b and i write a plus b a hasn't changed and b hasn't changed and in fact i could write something like c equals a plus b and now c a is that b is that and c is that so we have three different lists whereas originally we had two and to be clear if we change a now c doesn't change right it is really a new list oh that is right if i yeah get rid of the contents of a now a is empty but b is still there and c is still there okay so that's how plus works is it always just creates a new list uh what about append if i have two names for the same list and i append to a a has changed we see that change reflected in b because a is b these are just two different names for the same list so append changes this list but the other query thing about append is that it doesn't return anything so if i said something like c equals eight out of pen for what's a it's now got one two three four in it b does two and what's c well c is actually no the return value of a call to append is not why does that make sense well append does something to a but it doesn't really create anything new which is why it doesn't have a return value or the return value is none so instead of adding where we made a new list we're just changing an old list i guess the last thing i'll say on this issue is that if we wanted to put these things together you might imagine something like uh a and b and c where a is c or if i said something like a equals a plus b now i'm making a new list and assigning it to a so a is one two three four and b is three four and c is still a name for that original list one two which used to be called a but now a has been used for something else okay i'm gonna go for another one minute and say my least favorite thing about pipeline and that's a lot because there's a lot of problems with python but one of them is that it has a plus equals operator that kind of does not what i'd expect so watch this if i set a to 1 2 and b equal to 3 4 and c equal to a everything's the same because i haven't done anything different if i replace this line with a plus equals b instead of a equals b now a is one two three four b is three four and c is different meaning this doesn't actually mean the same thing as this i made some effort to get these to line up nicely but somehow i failed maybe the font size is different or something but you should just be aware that if you have a list on the left side of a plus equals then something weird happens that's a lot like extend and so i almost never use this construction because i don't trust it i feel like it should do the same thing as that but it doesn't so now that you've learned about this has been like a theme of this uh quest q a session is that python has all these weird quirks and you know that's true other languages also have weird quirks you may not have learned about all of them so you might think things are rosier on the other side usually they're not there is a notable exception a language that basically has very few quirks and that is called lisp and we will learn about that later in this semester and it is quite internally 