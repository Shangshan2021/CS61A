Sequential data can be represented  implicitly using an iterator.  Iterators are common interface in many programming  languages and they're used in Python as a way   to access the elements of lots of different  containers. A container can provide an iterator,   which in turn provides access to its elements  in some order. The built-in functions iter and   next create an advance iterators respectively.
So iter takes anything iterable, which could   be a container or something you create  yourself. And it returns an iterator over   the elements of an iterable value.
Next is a built-in function that   returns the next element in an iterator.
Let's say I have a container, a list containing 3,   4 and 5. If I call iter on that list s, I get an  iterator t. That iterator knows the contents of   the list and it also has a marker for what's next.
So you can think of an iterator as a position in   some sequence. It gives you access to the element  of that position, and everything after it.  If I call next on t, I'd get the number 3.
As a consequence of calling next, the marker here   is going to advance, which means the next time  I call next, I'll get 4 instead of 3. And since   I've called next twice, I've advanced twice, and  now the marker is set to 5. If I create a second   iterator for the same container, that means I  have a second marker into the same list. So u   is an iterator that hasn't been advanced at all.
If I call next on u, I'll get the number 3. Now   t doesn't forget where it was just because  I created u. So if I asked what's next in t,   I'll get the number 5. And the iterator will  advance past the last element saying that   it's at the end of this list. It's still the  case that I can ask for elements in u. So if   I ask what's the next thing in u, it'll say 4.
So t and u are iterating over the same values,   but they're otherwise independent in the  position that they're going to give you next.
Okay. Let's build ourselves a list that's  slightly more complicated than the one   you saw before. This one's a nested list.  If I asked for the next value in a list,   I get an error. That's not what next does. Next  first expects you to have created an iterator   over the contents of some container, at which  point, then I can ask for the next value of t,   which will give me the sub-list 1, 2.
So all it does is give me the element at   index zero of the list that I'm iterating over.  And if I asked for the next t again, I'll get a   different value. If you ever want all the values  in an iterator, you can just list them out.  Now, here, you see that we only get the values  that are left. We already used up the list 1,   2, and the number 3. So when I build a list  of the remaining contents and an iterator,   I just get the numbers 4 and 5.
Now if I asked for the next element in   t at this point, I get an error, a special  kind of error called StopIteration. And   that's how you tell you're at the end is that  Python will raise a stop iteration exception.
