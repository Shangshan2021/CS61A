A great deal of processing of sequences  and other iterable values uses built-in   functions that take in one iterable  value and give you back an iterator.  So many built-in Python sequence operations  return iterators that compute results lazily.   What lazy computation means is that a result  is only computed when it has been requested.  So the interpreter gets ready to compute  whatever is desired but doesn't actually   compute it unless that value is going to be used.
Let me show you some examples.
There's a function called map that takes in   another function and an iterable. And it applies  that function to each element in the iterable.  But instead of applying it immediately, it returns  an iterator. An iterator that iterates over the   values func(x) for every x in the iterable.  There's another built-in function filter,   which takes a predicate function and an iterable.  And it iterates over x in iterable if the case   that func(x) returns a true value.
Zip takes two iterables.  It iterates over co-indexed x, y pairs.
Reversed iterates over x in a sequence   in reverse order.
All of these return   iterators. And those iterators produce these  values each time you call next on them.  If you ever want to view the contents  of an iterator and its entirety,   you can place the resulting elements into a new  container by calling list, or tuple, or sorted.  Sorted creates a sorted list containing  all of the elements in the iterable.  Let's do some demos.
So if I create a list b, c, d,  I could uppercase all of those elements  by invoking the upper method for x in bcd.  I could get a similar effect by calling a  map on a lambda function that computes the   uppercase version of every element in bcd.
But what I get is not the list, capital B,   capital C, capital D, but instead  a map object, which is an iterator.  So if I give it the name m, then I can ask  for the next uppercase letter, which is B,   and then C, and then D, and then we're done.
Now how those results are computed   is quite interesting.
Let's define a function double, which takes   an x and prints out exactly when x got doubled.
x is doubled into 2 times x right now, 2 times x.  If I map a double over the list 3, 5, 7, I get a map object and you notice,   nothing was printed.
So I'll give this thing the name m.  And then I'll ask for the next element in  m. And at that very moment, it doubles 3   to get the number 6. Not until I asked for the  next element for a double 5 to get the number   10. And then finally, if I ask for the next  element, after that, it computes the number 14.
So the point here is that double  is not applied to 3 and then 5, and   then 7 immediately, but instead applied lazily.
Only when we ask for the next element is the  function applied and the results computed.
The map object that's returned when I call map,  can be passed into another  sequence processing function.
So for instance, let's say I  take the range from 3 to 7.  I map double over that range. And I call  that m. Then I create a filter function   that takes in a value y, and returns true  as long as y is greater than or equal to 10.  I could filter using f the map object and  build a new iterator from the result. Notice,   I still haven't doubled anything at all. If I  asked for what's the next doubled element in   the range from 3 to 7, that's at least 10, then  it will double 3 to find that the result is 6,   which is false according to our filter  function. So it doubles 4 to get 8,   which is also false. Then it doubles 5 to get  10, and 10 is greater than or equal to 10,   so that gets returned. So you can see that  it did exactly as much work as it needed to   do in order to return the next element of the  sequence of doubled values that are greater   than or equal to 10. But it didn't do any more  work than that. If I ask for the next element,   then it will just double one of them, find out if  it is greater than or equal to 10 and return it.  And if I list the contents of t, well  it finds that there's nothing left   because this range only goes 3, 4, 5, 6, 6 doubled is 12, and then we're done.  So starting from scratch, if I want to filter all of the elements  of the result of mapping  double over the range 3 to 7,  I'll get an iterator over the values 10 and 12, which I could place in a list.  And placing them in a list means that it's going to run this process to exhaustion  until I reach an empty iterator at the end.
And that returns the values 10 and 12.  And I had to do all of the  work in order to get there.  Had to double every number 3 4 5, and 6.
So it's possible to use these iterators to   compute the exhaustive answer. But if  you don't ask for the list of values,   and you only ask for elements one at a time, then  they will be computed lazily. Lazy computation is   mostly convenient because it allows you to specify  how to compute lots of values. But if you don't   actually need all those values, then you don't  bother computing them. However, there are some   things to be careful of. For example, if I create  a list that's the same, forward or backward, and   I asked what's the reversed version of that list?  What I get is a mystery reverse iterator object.   So just saying is the reverse of t equal to t will  give me the result false. Now if I list out all of   the contents of the reverse iterator that's equal  to t, what you want to avoid applying equality   to a list and an iterator because you'll get  false. You'd have to compare a list and a list.  Here's one last demo.
If I have a dictionary,   the elements come in any order, but when I iterate  over them, I get a consistent order each time. One   way to iterate over the items is to get an  iterator over d.items. And then I'd get b, 2   followed by a, 1. But another way to get the same  result is to zip together the keys and the values.  Zip returns an iterator that gives you each  of the items in the same order as before.
