A generator is a special kind of iterator. Just  like a map object is a special kind of iterator.   The thing that's special about a generator is  that it's returned from a generator function. A   generator function looks like a regular function.  Here's an example. The difference is that it   uses the yield keyword instead of return in  order to return values. So I know this is a   generator function because it has the yields in it  somewhere. When I call plus_minus on the value 3,   I get back a generator t. This generator is an  iterator, meaning I can iterate through the values   yielded by plus_minus. So if I call next on t, I  get 3. But I can call next t again to get -3. So   you can see that both of these yield statements  are being executed. t itself is a generator   object, and its job is to help iterate through  all of the yielded values of the function that   was called. So a generator function is a function  that yields values instead of returning them. A   normal function returns just once, but a generator  function can yield multiple times. A generator is   an iterator created automatically whenever you  call a generator function. So here's the call   expression where we called plus_minus and got back  a generator. When a generator function is called,   it returns a generator, and that generator  iterates over the yields of the function.   Here's another example. Let's say I want to return  iterators that go over even numbers only. I give   integer start and end points. But I want to make  sure that I actually start at the even number   that's greater than or equal to start. So the next  even number is start plus either 0 or 1 depending   on whether start is even or odd. While it's the  case that this even number is less than end,   I'm going to yield it. And then I'll increase even  by 2 to get the next even number. So when I call   evens, and I go from 2 up to 10, I get a generator  object, that's going to give me 2, and then 4, and   then 6, and then 8, and then stop iteration,  meaning we're done. And if I list all the evens   between 1 and 10, it still starts at 2, goes up  through but not including 10. So what's actually   happening here? When I create a generator by  calling a generator function, I haven't even   begun executing the body of this function yet.  It's not until next is called that the body begins   to be executed. And it keeps executing until  a yield statement is reached. At which point,   that number is yielded as the next element in this  iterator t. And in that case, execution pauses at   that yield but remembers all of the environment of  the function execution, so that the next time next   is called, it can continue where it left off.  So the next thing I would do is add 2 to even,   continue your backup into the while statement. See  that even is less than end and yield the next even   number. And what's powerful about generators is  that you can set up any computation you want. And   that computation will be executed lazily. So  when somebody asks for the next element, then   you continue until you reach the next yield. But  if nobody asks for all of the elements, then you   