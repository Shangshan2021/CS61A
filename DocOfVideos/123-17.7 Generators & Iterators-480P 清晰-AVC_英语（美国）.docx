Generator functions return generators. But they  often process iterators in the course of their   execution. And this happens so often that in  Python 3.3, released back in 2012, they added   a new statement, yield from, that just has a  generator yield all the elements in some other   iterator. So a yield from statement yields all  values from an iterator or iterable. For instance,   let's say I want to define a then b, which  is a function that takes in two iterables,   or iterators, and returns all the elements  in the first, followed by all the elements   in the second. One way I could write this is to  say, for x in a: yield x, and then for x in b:   yield x. But there's a simpler way. I could just  write, yield from a, then yield from b. These   are completely equivalent. So you can think  of yield from as just shorthand for writing   down a for statement where you go through all the  elements in a and yield them. But it does allow   you to avoid giving a name to each item in the  sequence, which just cleans up your code. Here's   another example. Let's say we want to define a  generator function that counts down from 5. Well,   one way I could do it is recursively. If k is  greater than 0, then I yield k. Then I yield   all of the values and countdown(k-1) by calling  yield from countdown(k -1). So I'm counting down   from k. If k is greater than 0, I definitely want  to yield k first. If I wrote this wrong, and just   wrote yield countdown(k - 1), the second element  in the iterator that I got back would actually   just be another iterator. So counting down from 3  would start out well, but the next thing I'd get   back is a generator object, which is not what I  expected. I expected the number 2. So to get the   numbers 2 in 1, I'd have to write a for statement  and yield each element in the for statement. Then   if I count down, I get 3, and then 2, and then  1. And the shorthand way to do that is instead   of writing a for statement, I just write, yield  from, everything in countdown. And I got 3, 2, 1,   blast off. Wouldn't it be cool if it say blast off  at the end? Well, we could change that. We could   just say else: yield 'Blast off'. Okay, so now  we can go for every k in countdown(3), print(k).   And it gives me the whole countdown sequence and  something exciting at the end. Let's finish with   a slightly more involved example. I can yield all  the prefixes of s. Well, I'm going to assume s is   a string, but it really could be any iterable. If  it's non empty, then I'm going to yield from the   prefixes of all of s up into, but not including  the last element. And then I'll yield s itself.   So the prefixes of both is a generator object.  If I list them out, and I get b, bo, bot, and   both. And I get them in this order because I yield  from prefixes before I yield s itself. Once I can   generate prefixes, I can also generate substrings.  If s is not empty, then some of the substrings are   just the prefixes. So I'll yield all of those.  And then I'll yield from the substrings of the   rest of the string. So substrings of tops, for  instance, is a generator. If I list its contents,   then I see t, to, top, and tops. Those are all the  prefixes of tops, but then I get all the prefixes   of ops. o, p, ops, and then p, ps, and s. And  together, those are all of the substrings of tops.
