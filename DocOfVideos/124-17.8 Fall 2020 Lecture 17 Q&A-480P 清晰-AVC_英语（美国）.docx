61a lecture 17 q a okay so i i think the question is about the the relationship between yield from and how that's essentially unpacking a for loop yeah the yield from is just a convenience there's no real reason why it's in the language but it is um it takes two two lines and turns them into one so uh going back to the example from lecture which was trying to yield all the prefixes of some string s if s meaning f s is not the empty string um it said yield from prefixes of everything in s up to the last letter and then yield s itself because s is a prefix of s depending on how you define prefix but that's a fine way to think about him um and then we need to call this on something like uh i don't know dogs so that should get dog and doo and d notice that this result is not a list if we'd want to do something with it we'd have to pass this in or call next on it or something like that i believe the doc test just called list on it which is basically get all the contents and we got all this stuff yield from can always be replaced with a for statement that says the following for some new variable in the thing that we're yielding from yield x so that's what yield from does is it goes through all the elements of some iterable and yields each of them so it's just a syntactic shortcut that's all it's essentially saying look this is a this is what you will find often not just in python but in a lot of programming languages that things that are routinely coded by hand are eventually incorporated into the language with a little bit of a shortcut it's it's abstracting out some complexity here um yeah exactly once you know what it means it's a little bit easier to read before you know what it means and it's hard to read right and uh there's a question in the chat do we always need a yield statement after a yield from and the answer is no we could have just commented out that yield and it just wouldn't have returned the list as part of the prefix i mean that would have been incorrect in terms of the functionality of prefixes but you can just have i mean essentially a yield from is a whole bunch of yields and so in this example if we had commented out yield s it would have it would have worked fine it was just given the wrong answer yeah good question the question is for the correct implementation here what is prefixes s of all of s without the last letter this is an iterator over all of the prefixes of this so if this were dogs this would be dog and prefixes of dog would be all three d-d-o and d-o-g so um yeah it's not just like the first prefix it's all of them and uh that's why what we're doing is we're yielding the d the d o the dog and finally we're dealing yielding the dogs hey john there's a question in the chat sorry to interrupt and why when you read we get comments dot yield ass and when you ran it it returned an empty list a great question so the question was if we comment this out what's the behavior and we showed you right here it ends up yielding nothing why is that well we've written something that just yields the prefixes for the like smaller version so if this is dogs we're yielding whatever we get by calling prefixes on dog which in turn would yield whatever we get for calling prefixes on do which would return whatever we get for calling prefixes on d which would return nothing we've reached oh sorry which would return the result of calling prefixes on the empty string and that would yield nothing so the base case here is like if there's no letters then there's no yield therefore we're not producing anything and since we don't produce anything in the base case and all this ever says is yield whatever the next recursive call would yield we end up not yielding anything at all so in general if you like ever have a function where your yield from an empty list that's not going to yield anything at all yeah good question so if an iterator is not a list what is it um there are lots of different kinds of uh iterators so you know it more by its behavior than it's like what it's constituted of an iterator is something that you can call next on and get more elements in the case of a list the iterator for a list is more than just a list it's kind of a reference to the list along with a position in that list that tells you where you are so that if you call the next thing the iterator advances meaning that if you called next again you'd get something else than you did the first time so in that sense it's it has different behavior than a list because it's both a list and like a marker for where you are but list iterators are not the only kind of iterators you could have an iterator through the labels in a tree you could have an iterator through the prefixes in a string you could have an iterator kind of through anything and it's just a description of something that lets you go through multiple elements in some order by calling next on the iterator and getting the next value and you can do that over and over again so it's quite an abstract thing as opposed to feeling quite as concrete as for example a list well the question about when should you use the built-in python python functions is an interesting one i imagine if you ask different people you'll get different answers so i'm going to answer and we'll see what uh john has to say so my view is languages are not static and they change and so this functionality comes in and out so for example if i want to write some python code and put it on my website and i happen to be using the latest greatest version of python and i grab some function that just got introduced i don't know if somebody using an earlier version of python will be able to run my code and that's not great i don't i don't like that i like my code to be standalone and not rely on somebody having just upgraded so now you could say look this requires python three point whatever and that's the way it is so i i prefer to write code on my own but there are limits to that i'm not gonna go re-implement some gnarly like if i want to use an iterator i wouldn't implement that myself um but i like to implement my own code in part to make it compatible and also because i just like to know what my code is doing i always get a little worried when we use code that's all canned up and you know we don't really understand it so i i like to do things i i tend to do things more um on my own but if you are doing rapid prototyping and you just want to get something built sure using all the built-in functions is great it saves you from writing a lot of code and doing a lot of debugging yeah i think that's a great answer i think everyone who's building software has come to a point that they've written a ton of code and then realized oh this is just like a special case of some general thing that's built in i've basically just like rewritten all the mechanics of a dictionary or something like that when in fact i could have just like used the one that's built in and it would have been one line and that's okay um happens to all of us and you know is the version that you wrote better or the built-in one better uh it depends it depends on how it's going to be used uh like connie said especially if something's just recently been introduced then it's probably worth avoiding it for a while if you want to be kind of compatible with everybody else but using the built-in functionality means that your program might get better without you having to do anything at all like if you're implementing your own system for time zones this is fine except that like you know what if some island somewhere changes their time zone this happened in the 90s the christmas island decided to change its time zone like you have to go in and update that whereas if you use the like built-in system for handling time zones then it would just get fixed for you in the next version of python so i think there are generally advantages to using the built-in stuff or relying on open source libraries whether it's part of the language or it's like part of some community development rather than just like redoing everything yourself for the long term but like if you're just getting something running like it's totally fine to just rewrite stuff yourself and ignore yield from and nothing bad happens i'm going to go back and quickly answer your other question that i i know you know the answer but just um for posterity's sake the question was what happens if you invert the order of yield s versus yield from s like what's the difference we could just quickly look at that and see that if the yield s comes afterwards that means s which was originally dogs is the last thing in the list if instead we had yielded that first and then yielded all the prefixes then we'd see everything in the opposite order so really you know python is going to go through and do these things in the order that you write them and that will have an impact on exactly what happens one more thing i wanted to say about this example is that what if we didn't know about yield like what if we were just in the business of building lists could we still get this behavior and the answer is yes it would look something like this we start with a list we go through and instead of yielding we would append to that list and then for every x in the list of prefixes i think we would append that x and then when we were all done we would return that result and in fact in the base case we'd want to return an empty list so in either case i think we want to return the result and here we get something that you know kind of does the same thing and if we inverted the order then we'd get it in the other direction going from d to dogs instead of from dogs to d um and uh a lot of code looks like this and kind of avoids this notion of yielding in general and that's fine um there are sometimes efficiency benefits to yielding there are sometimes some like interesting concurrency benefits to yielding so it is something that does get used more and more as people advance in their like sophistication of programming but it's not like you really need it in order to get stuff done in the first place you could just explicitly build the list instead of yielding it piece by piece okay so the question was in the countdown example why is it the case that you have to yield from count down k minus one and this was if k is greater than zero and then we yielded k how come we couldn't just yield countdown k minus one well let's just try both ways to see what we get and then i think we'll understand um if i list out the contents of the iterator that i get from counting down from five i'll get one two three four five oh i think i was supposed to count down okay um if instead i yield this what i'm yielding is an iterator rather than a number so what i'm gonna get in the contents of my list is not a bunch of numbers but instead one number the five that i yielded and this generator object and what's this generator object well you know like if i get this result and i get result one here's this generator object this is something i can get the next thing from and so i can get that four it's like buried in there somewhere it just took an awful lot more work to get it than in the other version where i just ended up with a bunch of numbers so essentially the from is doing the is unpacking that list that is that is now sort of stored up in the generator because what is yield from it's just a for loop that iterates through the result yeah and if you don't iterate through it all you do is you have that sort of core generator but the result as john just said is still there it's just sort of that lazy evaluation that you have to now unpack it yeah good question so the questions about this example and why is it the case that when you get the length of uh the result of listing out the contents of an iterator twice you get a different thing each time first time you got three things next time you got zero things this isn't something having to do with len this is having to do with how list interacts with an iterator when you call list on an iterator you end up building a list of all the contents of that iterator but the iterator is used up as a side effect of calling list on it so if i have an iterator over these values um i can get one thing out of it but then if i get another thing i get a different thing list is kind of like calling next over and over again and putting all the results in a list so as soon as you call list on t you're going to get everything that's left over in the iterator that hasn't been used up or returned already so we've already seen the one we've seen the two therefore calling list on t will just show us the three and now t is used up i can't get the next thing in t because we're already at the end and so if i try to list everything that's left and t i'll get an empty list so your version was start with this get all the contents of that which is a list containing one two and three if i do this i'm changing t this is uh every time you get elements from an iterator you're changing that iterator which means you can't really use it again so if you get the length of this you get three you get the length of this you get zero so think of these iterators as one use disposable operators once you've gone through the list either next next next x next or the list of it is you're essentially enumerating the list it's gone right so by the way you could have implemented this yourself you could have written a function that every time you access an element the next element you delete that element from the list that's essentially what's going on here yeah and so once you it's a funny thing about iterators by the way is that once you look at the list it's it's sort of like uh what is it it's like snapchat right the image comes in you look at it and then it vanishes it's gone that is beautiful yeah god you got to be impressed by somebody my age making a snapchat reference that's that's i think you know you have a little credit for that perfect snapchat analogy great question yes this is a form of mutation so this is why we teach iterators right after we talk about mutable values is that at all iterators are mutable they always change whenever you do anything with them meaning we call next on them so the question is is there like real applications of yield as opposed to just returning uh i see it a lot um it often appears in cases where your program is interacting with something else so there are lots of cases where you want to return a list of things right instead of just returning a single value but sometimes that list of things that you want to do something with isn't all there at the same time so classic examples are you're like reading contents from the web and you want to start doing stuff with each element of the you know like each page in a website you want to be printing out it's like a title or something like that you'd write a function that gets all the pages in a website and uh returns them so that some other function can print out their title well it takes time to get all the elements of all the pages in a website because there's like network traffic and you might have to discover where they are and so that's a classic case where you would be yielding each page as it becomes available and that means that whatever is printing out the title can start printing stuff right away as soon as the page is available instead of having to build a list of all the pages in some website which might be huge before you ever kind of start work on anything else so um yeah there are other cases in which there's this kind of like pipeline of information flow where stuff sort of is becoming available incrementally and you want to yield it as soon as it's available that's where it's used a lot i think that's exactly right i was thinking of the example you can tell the difference in john and my research john does natural language processing so he talks about text i do images in video so my example is we take a video and we have to decompress the video to do an analysis of it decompression of video is very very slow um but i want to start processing as soon as i get the first few frames so as i'm decompressing the video i'm shoving frames out the other end and then i have an algorithm that's doing some analysis and it's shoving it out so when i think it's exactly right is when you have these different pieces in a data flow but the processing is not exactly the same so maybe you have some slow steps some fast apps and i don't want some i don't want to sit here waiting for this really slow process because i can start working as soon as i get the data and so that with return you couldn't do that right return says i'm going to hand you back all this data when i'm done the yield can do it incrementally the next question was is a generator always an iterator but an iterator is not always a generator iterators are not always generators there's lots of different kind of iterators and generator is just a particular type of iterator and what makes it a generator is that it came from a function that yields as opposed to being from a list or something like that so iterators describe anything that you can iterate over whether it's the elements of a list or the yielded values from a generator function or anything else whereas generators are or more specific but the way you use a generator is the same as how you use an iterator it's just talking about where it came from the next question was about the summer 2020 midterm question two uh okay so this says uh schedule takes a galaxy which is a string and then there's some number that you want to sum to and some max digit that you're allowed to use and so a galaxy looks like something that's a bunch of digits maybe with some question marks for example here's some digits and some question marks and then there's a completion of a galaxy which is a string full of just digits where we've replaced each question mark with a digit and uh the total sum of the whole thing is supposed to be this value sum2 so here's a legal way of doing it which is that you could fill in this question mark with 0 well this has to stay at 2.
this question mark was 0. this question mark was 0. this has to say 1. this has to stay a 1 and this could be anything we want but all the digits including the ones that are provided and the ones that we added have to sum up to five so here's all the ways of doing it okay um let's take a look it seems like we'll do some recruiting uh we have a helper which has a galaxy um the fact that there's a galaxy here in a galaxy here means that maybe we'll be changing this along the way like filling in digits for example here we have a sum so far which could tell us whether we've reached the sum that we're trying to eventually achieve and the index i guess means that we're going to walk through here element by element okay so we'll call schedule helper on the original galaxy the sum so far i think is zero we haven't done anything yet and we'll start at the beginning and we'll see what we do if it's the case that we're done then we're going to return a list containing galaxy okay that's good but this means that the galaxy that gets passed in here has to have all the question marks filled in if we're going to be returning it so we know we're going to be kind of filling in things as we go if it's the case that maybe we've reached a sum that's too big then then we have a problem so i think there's probably some base case like some so far is greater than sum two then we have a problem there might be some other base cases that we have to think about as well and i'm not sure what's going on here yet we'll think about that later here's the kind of main recursive loop which is that we build a list we go through every x in something probably the digits from zero to nine or something like that uh and we fill in a question mark that seems like what modified galaxy is going to be all about um so i kind of feel like this is going to be the case where there's no question mark and this is going to be the case where there is a question mark and then you have to like try all the possibilities so it might be something like if galaxy at index does not equal a question mark then i think we have to just use that first value so we'll call schedule helper on exactly the same galaxy we had before the sum is going to change we have the old sum plus uh whatever the first element of galaxy is or the current element of galaxy is and uh what else let's advance the index so we keep moving what if there's a question mark so here this is in fact i'm just going to rewrite it lf galaxy index equals question mark and i think this will do the same thing right uh oh wrong way we're gonna find all the different ways of doing this um go through the digits zero one two three four five six seven eight nine we're gonna build a new string which is galaxy up to but not including the index plus a stringed version of x plus the rest of galaxy after the index that might work so let's just like look at what this does for an example before we go on would be nice to know that it works so if i have something like 2 3 question mark 5 6 and i have an x which equals 4 is it the case that if index equals 2 and galaxy equals this thing that i get what i want when i evaluate this expression it does so we basically just replace the question mark with a 4 there in this long line so what do we do well we have to get some more answers in there uh i'm gonna recursively call schedule helper on this new modified galaxy and a new sum so far because now we've got an x in there and we're moving forward and we do this for all the index like why is it the case that i called schedule helper here this is where i'm going to fill in all the other question marks that are later on and make sure that i got the sum right all right now i think we need to get this base case of when we have found a fully complete galaxy so this would be like if index equals the len of galaxy then we've gotten to the end and if galaxies well okay how do we do this let's make sure we got the right sum sum so far equals sum two that might do the trick then maybe we're done nope uh index out of or index greater than equal to the length of the galaxy so if you kind of like get to the end and you don't have a sum that's big enough then i guess you need to stop what on earth sorry zoom is in the way i can't even see what broke oh i don't think you're supposed to use oh parts of the size max digit yeah you can't always go to 10.
you should probably read the question first okay now it works so what got us here well we kind of kept track of what information we needed to maintain along the way and there were like some pretty good clues in the question of what to do based on the name some two and some so far and it took a minute to kind of think through the base cases and i think we could have figured this out without running the code just by kind of like considering different cases uh reading the question carefully but since we had it all set up we just ran the doc test instead to get a clue about whether we had done it right or not during the q a i said we could do this with yield instead of building a list but we never actually did that so um let's do it we're going to return a list of the results of everything that scheduler helper yields and then we can worry about yielding so here we would yield just galaxy that's equivalent to returning a list of galaxy here we just wouldn't do anything one way to stop a function is to write return but it would also be fine just to kind of do nothing here just don't yield anything and what about here well schedule helper is going to yield a whole bunch of different values so this would have to be replaced with the yield from and here we could get around building up a list and just say that every time we call schedule helper will yield from that so what happens when we run this we get the same result great question so if you have a for statement or for loop is that the same as creating an iterator and then calling next on it repeatedly yes the behavior is identical i think there are cases in which python tries to like find a faster way to do it like if you iterate over a range maybe it's doing something fancy underneath i don't know but from your programmer's perspective the behavior is identical to create an iterator out of this thing that you're running the for loop over and then call next repeatedly binding the name x to the next value each time yeah good question is there any way to reset an iterator once you've gone through the elements or do you just have to make a new one and the answer is you just have to make a new one um there are um the reason for this is that it might be that you're trying to write a program where you're kind of forgetting the past because maybe the stuff that you've iterated over is so big it's like whole video files that you can't store them all in memory at once so this idea of like resetting would require you to remember everything you had seen before and that's exactly what you might be trying to avoid an iterator so it's up to you to write your own program about uh remembering where you were i think there might be some like built-in stuff in the python standard library to to remember an iterator and kind of cycle through it but i don't know exactly what it looks like the next question was is there a relationship between yield from and recursive functions like to yield from always have to be recursive i don't i don't think of it as recursive i think it was iterative because you're just unpacking a for loop john yeah that's right so i don't think yield from has to be recursive or anything like that you know the simplest possible yield from would be like yield from all the elements of this list and there's no recursion there and uh it works just fine so you have to start with a list one two three but then if you call f on that and you get that result this is a generator object where you'll get the one the two and then the three it happens to be that you can uh can mix together recursion and yielding if the goal of your recursion is to build up a sequence of things which is not totally unusual you know our first examples of recursion where like count the number of ways that you could partition up a number using parts up to size m and then we just did a homework problem which was actually list out all the ways and so you know it's the same basic recursive structure in both cases except for counting you just return a number whereas if you're listing out all the possibilities then you have to either return a list or you have to yield yeah good question so can yield be used within a list comprehension or inside of another larger expression the answer is no and this is also true of return and assignment statements and def statements there's a lot of things that can't be embedded inside of a larger expression because they're not expressions themselves they're statements and so they have to kind of just like show up on their own line so you never have like return x for x in some list because return x is not the kind of thing that you can embed inside of a larger expression and the same is true with yield you can't have that there either yeah good question so is there is there a way to kind of do two things here right in a list comprehension and the answer is you only get space to put one expression but that expression could be a compound expression so um you know one expression is the number two but another expression is the list one two um because this whole thing the list one two is actually just one expression that's got parts within it you could try to get each part to do something it is legal in python to say first i want to get the result of printing one and then i want to get the result of printing two and use that to fill in this blank and now i've kind of like done two different things but i've done it by calling a function which is something you're allowed to embed inside a larger expression as opposed to writing down a statement like print or yield or sorry like a return or yield or def where you're not allowed to embed that inside something larger yeah okay so the question is how would it be that like new stuff appears in an iterator as you're reading from it um this was an example from earlier in the q a and what might it look like if you have something that's like read pages from a website well every website has like a root page so maybe we should call this root it would be something like i don't know google.com or how about the new york times uh you would have to have some function that reads that right and so you'd like call that on the root and get this page and you'd want to yield this page but and that means that like whoever called read pages can immediately start acting on this right after this is done but then i think you'd want to go through for get all the links in this page and you'd want to yield from the result of reading all the pages from that other page that you got so how is it that we're like getting new stuff along the way well you're kind of not in some sense all of the data that you will ever process is known is defined when you call read pages the first time it's whatever's at www.newyorktimes.com and everything that it links to but actually writing out that list of everything linked to from the new york times will take a really long time and so um there's a lot of this result that we haven't discovered we immediately kind of yield the front page and that means that something could print the title right away as soon as this line is executed but um we haven't really found all the other pages yet so they're there but our program doesn't know about them okay that makes sense cool all right thanks folks it's been a pleasure talk to you soon 