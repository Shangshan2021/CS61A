Today we begin learning about object-oriented  programming. So we already know that all values   are objects in Python. But we're going to start to  understand what that really means. Object-Oriented   Programming is a method for organizing modular  programs, meaning that you define each piece   without worrying about the other pieces. And then  they all work together. So that means we're going   to worry about abstraction barriers, and bundling  together information and its related behavior.   Object-oriented programming is also a metaphor  for computation using distributed state. What   do I mean by distributed state? Well, we'll have a  bunch of different objects, and each of those will   have its own local state. So when we want to know  what's going on in the program, we have to inspect   each object in order to figure that out. Each  object will also know how to manage its own local   state, based on method calls. So you call a method  on an object, and that might change its state,   the object knows how to update state correctly.  And those method calls are best thought of as   messages being passed between objects. So that's  the metaphor. We have a bunch of different things,   objects pass messages amongst each other and each  one is responsible for taking care of its own   internal state, so what's going on with itself.  Several objects may be instances of a common type.   And different types may relate to each other. So  we're gonna see examples of all this stuff. But   that's the basic idea that you want to understand  when you think about object-oriented programming.   And to support this metaphor, we're gonna have  specialized syntax and vocabulary in order to make   this all make sense. So we saw in the last lecture  that we might have different objects. Back then,   they were functions. Now there'll be objects  that are John's account and Stephens account.   And let's say we have another object, John. I made  it tall, because, you know. And so what happens in   this metaphor is that if John wants to withdraw  money from his account to give it to Stephen,   then there will be a message passed from John  to the account. The account's business is to   make sure that it knows how to withdraw money,  and update its balance correctly. So as John's   done that, that it might send another  message to Stephen's account, saying, hey,   deposit $10. And then Stevens accounts balance  will be updated. The balance for each account   is stored within the object. And John can ask for  it using a message as necessary. And the idea is   that all these different objects might have other  messages coming in. And they might send messages   to other objects as well. So John's account might  occasionally say, after many withdrawals, John,   it's probably time to apply for a loan. So  that's the idea that we want to create when   we write code in an object-oriented programming  language, like Python. Fundamentally, objects   are organized according to classes. A class serves  as a template for all of its instances. And each   object is an instance of some class. So we have  built-in classes that we've seen along the way,   but now we're going to start defining our own  classes. So the idea is that all bank accounts   will have a balance and an account holder. That's  what makes a bank account a bank account. So the   account class should make sure that every  one of its instances has those attributes,   what's its current balance, and who's the  account holder. That'll happen when we create   a new instance. And here's what the code is going  to look like. Let's say I'm creating an account,   I'll pass in the account holder gym, and I'll bind  the resulting object, which is an instance of the   account class to the name a. Then if I ask, who  is the holder of a? The account holder is Jim.   I set that when I called the account class to  create the object. And now I can access it later   as an attribute of that account. And what's the  balance? Well, Jim, so far doesn't have anything.  So how's Jim gonna have some money in his account?  Well, we want all bank accounts to have withdraw   and deposit behaviors. And all bank accounts  should work the same way, which is why they're   all instances of the same class. So if I deposit  $15 into this bank account, which we've named,   a, as Jim's account, now we'll get the balance  back of 15. And if we withdraw $10, then the   balance goes down to 5. What's the balance now?  It's 5. So notice that some of these look like   call expressions and some just access and value  that's part of the object. If I withdraw $10,   again, I will have insufficient funds. So  there's two different ways we could realize   this. We could put deposit and withdraw methods  as part of every single account, but that's not   what we're gonna do. Instead, we'll make sure that  all accounts share the same withdraw and deposit   methods, and that way we can guarantee that they  all behave in the same way, which is what we want.
