The last piece we need in order to finish  implementing a class is to add additional   methods. Methods are what represent the messages  that an object will accept. And they're just   functions that are defined within the class  statement. So let's take a look. Methods are   defined in the suite of the class statement. So we  write class account. And then we define the init   method. And then we can define other methods. So  here's a deposit method. It takes in an object of   the instance of the class account. And it takes  some amount of deposit. And what it does is it   changes the balance to be whatever the balance  was, plus the amount that was passed in. Now,   it's important to pay careful attention to what's  going on here. Self is a name that's going to   refer to an instance of the account class that's  being deposited into when we change an attribute   using this assignment statement, what we're doing  is we're changing the balance of that particular   account, particular instance, to whatever its  balance was plus the amount that's being deposit.   So amount doesn't need any self in front of it,  because it's passed in as an argument to this   deposit method. Then we're going to return the  balance of the account that was passed in which   we call self. And that's what depositing is.  What about withdrawing? Well, that's slightly   more complicated, but the same idea. We'll pass  in an instance of the account class called self,   and then the amount that we want to withdraw.  We'll check and see if that amount is too large.   If so, then we'll return insufficient funds.  Otherwise, we'll set the balance to be whatever   the balance was, minus the amount, and then we'll  return the balance. And then we're done. So now   we've implemented the account class in such a way  that it starts out with a balance and an account   holder. Well, that's set up with the constructor.  And then we can deposit amounts into it, and we   can withdraw amounts. So these def statements  create function objects as always. There's no   new rule for executing a def statement. But their  names aren't bound in a particular frame. Instead,   they're bound as attributes of a class. So the  account class now has three attributes init,   deposit, and withdraw. Okay, so now that we've  defined our methods, what can we do with them?   Well, we can invoke them. So all invoked methods  have access to the object. It's the methods being   invoked on via this self parameter. So self is a  name we gave to the object that we can manipulate,   look up its balance, whatever. And so all these  different methods have access and can manipulate   the object state. So there's only one balance for  every account, but we can deposit and withdraw   from it with two different methods. Okay. So  here's our account class. I've abbreviated some   of it because it's not important for this example.  What is important is that we define the posit with   two arguments, self, and then the amount that we  want to pass it. And then we use dot notation,   in order to invoke this method. And dot notation  is special because it automatically supplies   the first argument to the method. What's it  supplying? It's supplying the object instance   that we're invoking the method on. Okay, so let's  look at this. After we've defined the account,   we can create an account by calling account,  passing in the holder. Now, tom_account has   that balance of 0, and the holder's name Tom.  And I'm going to deposit $100 into tom_account.   Notice that I've defined deposit with two formal  parameters, but I call it with only one argument.   So where's the second argument? Well, it's  actually that the first argument is Tom's account.   And the second argument is 100. So when we call  this function, we're calling it on tom_account,   which we call self, and 100, which we call  him out. And then we just execute the body   of the function as if it were any other function.
Okay, so let's look a little bit deeper into these   dot expressions. Objects received their messages  in this metaphor of object-oriented programming   using dot notation. So dot notation accesses  attributes of the instance or attributes of its   class. So balance is an instance attribute. Every  instance has a different balance. Withdraw the   method is a class attribute. All instances share  the same withdraw method. Okay. A dot notation   looks like this. You give it any expression you  want on the left, but you just have to give it a   simple name on the right separated with a dot. The  expression can be any valid Python expression. It   evaluates to some object. And then we look up the  named attributes. So it has to be a simple name.   So what happens with this dot expression? Well,  it evaluates to the value of the attribute looked   up by name in the object. That's the value of the  expression. What's looked up by name mean? Well,   we're going to have to go through all the  details, and we'll do most of them next   lecture. But the basic story is, you look in  the instance and see, is this name bound there?   If not, then you're looking at class. Okay.
So let's think about tom_account.deposit(10).   Here's an expression we've seen before. What's  really going on is that this is a call expression   with a compound operator. The compound operator  is a dot expression. And what it does is it goes   and finds the deposit method of tom_account,  which is actually part of the account class   that tom_account is an instance up. Okay. So  this dot expression evaluates to a function,   and then we call that function on 10. And that's  how we deposit $10 in the tom_account. So let's   look at the demo real quick. So over here, on  the right, we'll see the account class that   we've been talking about. It's exactly the same  as the examples, but I've added a little bit of   documentation. So when you define a class, usually  give it a doc string. An account has a balance and   a holder. And then you can give it some doc  tests that show you how to use this account.   So we created an account, my account. We deposit  100, we withdraw 90, we have 10 left. Withdrawing   90 again gives us insufficient funds because  we have a balance of only 10. And we create all   this behavior by having a constructor, a deposit  method, and a withdraw method. And this really   does work. If I load this file, that account is  the class. And john will bind to an account for   me. So what is john? john is an account object. So  here's the class. If I ask for the type of john,   it will tell me the class account, which I have  defined here. And john has a balance, not very   much there. And john has a holder which is me. And  when I deposit 10 into john and I do it again and   again and again, then John's balance goes up.
And then I can withdraw all of that out again.   Okay. So it behaves like an account should. You  can deposit or withdraw from it. It knows what   to do when you over withdraw. So we can  think of it as an abstraction for a bank   account. And we defined its behavior  with the following class statement.
