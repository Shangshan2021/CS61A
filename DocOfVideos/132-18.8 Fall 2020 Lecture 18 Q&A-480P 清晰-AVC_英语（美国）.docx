lecture 18 q a so the question was if you have an account class like this is deposit a class attribute and technically it is but that's because it's a very special kind of class attribute it is what's called a method so um it would be rare for someone to call this a class attribute even though that is technically true what it really is is a method which means that uh the only way that it usually gets used is by having an instance of an account and then depositing into that some particular amount at which point itself gets filled in automatically and the other part of the question was what are the instance attributes in this example there are two they are holder and balance you know something's an instance attribute if it's assigned to an instance and self always refers to an instance of count in uh inside of the body of a class that's about an account sure so the question is what's a bound method and how is it used well if i have an account it's mine uh normally i would deposit into it like this this expression here actually build something we could give it a name if we want this thing is called a bound method and what's a method about it well it's a function defined within a class and what's bound about it is that the self arguments already filled in so this is not just depositing in general f is depositing into a that john's account which is called a in this example is already bound to self meaning what we're left with in this bound method is a function that only takes one argument so that's what a bound method is it's a method a method is some function that's defined within a class that has already had itself filled it right so the saunders question the chat um they are different um it's just as john was just saying in the bound method you've already filled in one of the parameters what is the object you're sending in it's still doing the same thing of course it just sort of you've delayed the evaluation a little bit right you've taken like one step in the evaluation by finding yourself yeah and i guess a follow-up question might be what's a method that's not bound you can actually access that it's a little more rare but there are reasons why you might want to do it if we access the deposit method directly from the account class notice the difference we had an instance here here we don't have any particular account that we're talking about we're just talking about accounts in general what does it mean to deposit well this is a method that takes self and amount so if i wanted to call this thing i would need to pass in both the account that i want to deposit into and the amount and then the depositing would happen i find that really offensive john i don't like this is something i don't like about python by the way is that you know the syntax it lets you do the same thing many many different ways and i find that a little confusing yeah it is confusing i mean i think that functions are very fundamental in python and classes yes they are but it's if you look under the hood like it's actually just built out of things that we already know so this thing that's like a method is actually really just a function except for uh if you have an account instance then something special happens with that function meaning self gets filled in so uh things are unfamiliar in that kind of everything's new with object oriented programming and yet it is built on the stuff that we've already yeah the question is like what can self ever refer to and self by itself sorry self itself is always a name for an object which is an instance of this account class so what that means is that every time you use self within one of these methods you're referring to a particular account which one well you don't know that's going to come later is that somebody's going to build an account and going to start depositing into it and self will be the name that you use to refer to whatever that thing is that somebody built later so it's a placeholder just like you'd always have within parentheses of a function like stuff that hasn't been determined yet but this one is special because it's going to be an account an object which is an instance of the account class because you know that's true you know certain things about it like it was passed as the argument to init therefore it has a holder and a balance the next question was can self only be used to refer to particular attributes or could it be used to refer to methods as well sure so if we start writing more methods function i can within the class call one of my own method functions yeah so at the other side within the class so we certainly know outside you can call a method function of a class once you have an object self is just the object it's just a special name for an object so within the class sure i can call member functions all day long using self dot and then whatever the function is and pass some parameters yeah even within it you're kind of free to do whatever you want so this this is like a really nice bank i'm not sure such a bank exists but john is a really nice bank you could deposit into it right away yeah just go ahead and so say when you open your account you want to deposit well john's a little stingy four bucks um all right and that will do it okay so uh yeah go ahead 400 better great question so is every time we're referring to self.something and assigning to it is that a form of mutation yes what we're changing is self is the account object so this account is something that's mutable and instead of like having elements like a list or something like that it has attributes ways that it can change are that it can get brand new attributes that's what happened here we gave it a holder attribute that it didn't have before or you could update attributes that already exist this already had a balance and now the balance is changing but in either case we are mutating which does mean that if we have two names for the same account and i deposit into a i have in fact deposited into b as well because b and a are just names for the same thing and it's the thing that's changing it's not the variables that are changing okay good question i think you're asking about an example where an instance has an attribute with some particular name like interest and the class also has an attribute with that particular name interest and therefore if you have an instance and you try to look up the attribute value for interest you get the instance attribute instead of the class attribute because that's where python looks first so when does this happen there's two ways to set a class attribute i could just write it in here that will be fine or i could add it if i have access to the account class i could give it a class attribute like that and uh both of them do the same thing okay so now that the account class has an interest that means every instance of this class will also have an interest and so if i make one of these it has an interest but this is actually not an instance attribute it's a class attribute there's no real way to tell that based on how we used it here it's just part of python that it looks in the instance attributes first and if it doesn't find interest then it looks in the class and it happens to have found this one in the class but if we gave this thing an interest attribute i might be too high now it has changed but the account's interest rate has not changed because this was instance attribute assignment which changed an instance attribute and we didn't change the account if i made a new account at this point its interest rate would be whatever the classes was because b doesn't have its own instance attribute um and yeah let me pause there and then i'll answer your final question okay i think your final question was is there some way to get a to behave like all the other accounts like right now a has a different interest rate than all the other accounts could we make it go back and like use the class instead of the instance well there's a way to get the values to be the same which would be to write that the instance attribute is the same value as the class attribute then they would look the same for now but if the class changed again for some reason then a would be out of sync oh sorry i typed this wrong oh my gosh now i got to go back to one do it because of that one typo okay so if account's at point three now a is at point three but if we change the account to 0.4 then a's interest is still 0.3 there's still a lot of sync can you somehow say like i i don't want a to have its own special instance level interest rate i want it to just be like all the other accounts there is a way uh i don't typically teach it in this class because it's used so rarely that it's like you could not worry about it but there is a way which is that there is like a special keyword called dell that would get rid of the instance attribute at which point a still has an interest it just happens to be the classes interest so that's kind of the answer to your question but this is not something you need to know because i just have never seen it used in the world and so it's possible but but i don't it's hard for me to imagine a case where you would want it the next question was about the relationship to java which has private and public keywords that don't seem to exist in python is there some equivalent in python okay so let me just interject here for those who haven't not done java michonne obviously knows a little bit of java so a lot of languages have this notion of classes and objects c plus plus c sharp java et cetera not all languages do by the way uh and within java for example there is a notion of a public method and a private method a public method can be called by anybody and the private methods can only be called from member functions within the class um i john i actually haven't i don't know if this is changing python 3. is there a notion of public and private in classes in python 3 um it is there is but it's much lighter weight so in a language like java it's really like strictly enforced in python instead there's a naming convention it's a weird one we don't really talk about it in this course but you'll see it in like industrial code which is that if you want a method that you don't want anyone else to call but it just like is there to help like uh check that balance is not negative or something like that uh assert that self.balance is greater than equal to zero you might want this somewhere but you don't want other people to call it the convention is to put one underscore in front of it and that basically says like oh this could change people shouldn't rely on this um but it's possible to call it anyway it's just like uh try not to use it right but it's not enforced right john i could still call that function that's a you can still call that function it like it doesn't show up when you generate the docs and stuff like that so there is like a little bit of uh soft enforcement there is a stronger enforcement which is that if you put two underscores then this is genuinely hard to call because uh some crazy thing happens with naming that i won't describe but um that is a feature that i think is quite rarely used because it's like hard to understand so the convention is basically like if there's stuff that you that is just like for internal implementation reasons then you put a little underscore there and that lets everybody know this is not something that's part of the class it's just part of the implementation that is the very definition of a hack it is definitely a hacker now you might wonder like is python deeply broken well this idea of private and public came from a time when you wanted to write code that's kind of protected from other bad programmers and um there are settings in which this is a good idea like if you're building a library that thousands of people might use and they might you know use it wrong and if using it wrong like delete somebody's bank account then it really is important to make sure that it's impossible for them to do it wrong and uh this protection system that exists in java is for that kind of industrial setting most of the cases where python is used um it's more collaborative rather than defensive like you know you write your class and you tell people how they use it but they can hack on it and mess around with it if they want to and as long as all the programmers are friends and they're willing to understand how it works like that can can be perfectly productive too so it's a different approach to building libraries and building code that interacts with other people's question so is there some way to make a user-defined class immutable um there this is basically not part of python as far as i know there might be some way but i don't really know what it is and it doesn't really happen what does happen sometimes and we'll learn about this in the next lecture is that you can specialize some kind of immutable class that already exists so you can make like a special kind of tuple that behaves slightly differently than a regular tuple but fundamentally since tuples are immutable then this specialization would be too but other than that i think the answer is no um that's that was that i'm not positive but i don't know of a way of doing it and by the way it's that's not a bad feature you could certainly imagine wanting to create that type of protection i just i just don't know or don't think it exists and there are i would say there's certainly lots of um open source projects where classes are defined that are meant to be used immutably meaning like the design of this thing is that you create it and you don't change it it's just that the python language doesn't force you not to change it so it's really kind of up to you as the user to read the docs and say oh this says and we're not supposed to change it and then it will work correctly so let's not change it so raymond is asking a question about what we call selector functions and i think we've actually talked about this in the class and so you you saw that john in the in the python window was directly accessing the balance uh variable which you're allowed to do um i think john can disagree with me if he wants to that's considered bad form um that really you should use functions to access and set the data fields and not access to them directly so it's really all about the abstraction what's nice about having a function that says give me the balances i don't need to know the the variable name and if i change something in the underlying data implementation which you've heard us talk about before all the functions are going to do what the functions do and i don't have to change my code so i like when i build classes to have what i call selector functions which return to balance return the name and i like to have functions that set them and that's the only way i access the data now python doesn't force that you can you can do whatever you want but i think that's i like that as sort of a clean implementation so that if i then go back up and change the underlying data representation i've only got to change a couple of functions and john's writing them exactly here these selector and uh functions yeah so i mean there's trade-offs and everything so uh a getter and setter or a selector and i'm not quite sure what how they call it i don't know what the other one is but often they're called functions um might look like this and you know something you might typically see in a python program is that this will indicate that it's not supposed to be accessed directly with like an underscore or something like that um and the nice thing about this level of indirection is that yeah if instead of having a balance you decide one day you really want like uh to represent this as something else you can do that and the interface that people access this with hasn't changed which is nice um so i but you've added you know a little bit of code and you still have the case that like uh this part can't be changed or everyone has to change their code and so um you've pushed it upstream a little bit yeah i think you just gotta think i don't think there's like a perfect general rule sometimes this kind of indirection is quite helpful because you're not sure about what your final attributes are going to be sometimes it's just kind of extra work because you're pretty sure you're going to have a balance forever and you want people to be able to mess with it and so like why have them mess with it with these functions instead of just using it directly it's just a trade-off right you know how much do you want to future proof your code to make sure you can change it later this is one technique to do it and in some settings it's a good idea i think that there was like a big push in the education community to tell everybody to do this everywhere all the time because of this disposition i described earlier that you need to be very defensive of the users of your programming language or users of your library later on you want to like make sure that they don't use it in the wrong way and so you want to kind of protect your data and make sure that it's impossible for them to change it and that disposition is effective in certain like industrial settings and in other ones it's not like if you have a more collaborative group of people all working together then it can be really nice to be able to kind of dip in below the abstraction and mess with something because the original programmer didn't anticipate exactly how you want to use it and you want to do some feature that manipulates the balance in a way that they didn't think about and so you you want that like access to stuff that they didn't really think that you were going to access directly it just depends so um so this is a pattern that we don't like obsess over in this course because i think that it's fine to think about object-oriented programming as a way of compartmentalizing changing state so like have the mutation happen on particular objects as opposed to globally and um have objects interact with each other by kind of calling methods on each other like that's really the important part and the protecting against other users i think is something you could learn about in another course or we could talk about it now um it's a fine thing but i don't think it's the most essential part of object-oriented programming um and uh if you do this kind of all the time with every single attribute that you include then you can just like generate a lot of code and it's hard to see kind of what's the meat of this uh class because you've got a bunch of other stuff that doesn't really do anything um okay that's nice of you so josh has a question can you please explain the difference between remove and dell methods i don't let you know the difference yeah i can so there's a remove method on certain objects but not many so for example a list a is a list an instance of the list class and there's a remove method on there which does a particular thing that's list specific it goes to the list and it removes the first element that's equal to whatever you pass it del is something that's really general it applies to any object and what it does is it tries to remove an attribute from that object it actually i think doesn't work on a lot of built-in stuff we'll find out in a second what's on list site it works on i think you can say dell a sub zero oh that's true so if i try to get rid of the remove functionality it will say oh no right yeah it's like built in elements if i try to okay so what is a now if i del a zero then that will get rid of the one so that's kind of like remove except for we've picked an index as opposed to a value to remove um but del is actually pretty general so as you can see it's not a method it's not using dot notation but instead it's its own kind of statement and you can delve from all kinds of stuff but i basically never use it because i think it's almost always better to just use the methods that are built into the class so it does exist maybe you want it sometimes and maybe you could never use it and do everything that you want to do the next question was about explaining parts 10 and 12 of homework 3 all right homework 3 was already due and there were some extra questions that you didn't have to do but i think are interesting and they were about data abstraction where um we had an abstraction about an interval and that interval basically described there's some number but we don't know what it is so instead we're saying like oh it's between three and seven and that means we know it's in there we just don't actually know whether it's four or five or six that was the idea behind this question so we haven't done it yet the first part was to build an interval abstraction because we could probably just do that if you want the lower bound then you return the intervals at index 0 if you want the upper bound then you could return the element at index 1 and that's because we constructed it in this particular way there was some notion of multiplying i wonder if we need that for question 10 probably yeah let's let's add this notion of multiplying oh it's given to us excellent all we have to do is fix the data abstraction violations which i think would be that you get the lower bound of x times the lower bound oh it's going to take a while to type sorry we could have the lower bound of x times the upper bound of y we could have okay so let's talk about what's going on here because it's actually really important um when you multiply two numbers together there's only one answer but when you multiply two intervals together basically what you're saying is i'm multiplying some number and i don't know what it is but it's in this range with some other number and i don't know what it is but it's in this other range okay we got rid of the abstraction barrier violations what would it mean to have an interval from [Music] negative 1 to 1 and another interval from negative 2 to 2 and multiply them together it tells me negative 2 to 2. why is that well we don't know what the number for a really is it could be negative 1 and b could be negative 2 at which point if i multiply those two numbers together i get 2.
well this was kind of a lousy example let's have this go from negative two to zero okay see what happens when you multiply okay so even though uh like it's not obvious how you get to the number two well the way you get to number two is a is negative one and b is negative 2 and so you've multiplied two negative two numbers together and you can get a positive number how you get to negative two i guess is maybe a is actually one you don't know it's like somewhere in that interval and you could multiply that by negative two and you would get negative two it's also possible to get like anything in between you could get a half because uh this is one oh sorry this is a negative one and this is uh a half i do that right no if a were negative one and b were negative a half then you'd get a half that's like in that interval somewhere okay finally i got it right here's something weird what happens if you multiply a by a it says you could get anything from negative one to one but i argue this is wrong because if you take some number and you multiply it by itself you never get a negative number right anything squared is greater than or greater than or equal to zero that's just like a fact yet somehow we have code that says if i multiply a by a i could get anything from negative one to one so something has gone wrong and that was what this like uh question was about so let's read the question and uh then try to understand what's going on so sometimes when intervals are computed by different but algebraically equivalent expressions you get different results and the problem is multiple references to the same interval the multiple reference problem is a formula to compute intervals using this system the system that has things like mole interval will produce tighter error bounds if it can be written in such a form that no variable that represents an uncertain number is repeated why is it that multiplying a times a according to the system that we've built gives you the wrong number what would the right number be well i think the right number would be if you take some number between negative one and one and you multiply it by itself you can get anything from zero to one but you can't get anything negative and the reason this gets it wrong is that this code assumes that x and y could be different numbers but in fact if these are the same interval they're really referring to the same number you don't happen to know what it is but it can't be different for the x and the y it couldn't be that some number which is between negative one and one is both negative one and one at the same time that's not what intervals are intervals are about one number and we don't know what it is so for that reason when you write all this code and you think it's going to work it actually doesn't work correctly because you have an implicit assumption that x and y are different intervals but in fact if you pass the same one in then then you're kind of using intervals wrong that's the story of question 10 multiple reference problem yeah i haven't seen question 12 which i think was also part of tan's original question after considerable work eliza p hacker delivers her finished system several years later after she's forgotten all about it she has a frenzied call it seems that lem has noticed that the formula for parallel resistors can be written in two algebraically equivalent ways okay i'm pretty sure this was supposed to come before question 10. but here's two different ways of writing down what should be the same equation right because if you write r1 times r2 divided by r1 plus r2 that's the same thing as writing 1 over 1 over r1 plus 1 over r2 except that this refers to r1 twice and this only refers to r1 once so if you use the system that we've built combining with multiplication and division r1 and r2 but you've got r1 in there twice according to the way this multiplication function that we wrote works you're going to have like a different value for r1 somewhere in that range in one part of the equation than you do in another part of the equation and that is broken so i think that the point of this example was that it only works like this interval computation system that you've built only works if each interval only shows up once if it ever shows up twice then you get the wrong answer yeah i think that's the nugget of it it's not how i would have interpreted it by the way but i think the nugget is that when you have the same interval you are assuming that you're choosing the same value from that interval and then the rules change yeah and so you'd have to write a new system a follow-up question was whether this has to do with programming or python or it's just about this particular interval example yes this has nothing to do with programming except for you do need to think about what you're representing in the world when you write your program and here's an example of that it's like if you just like assume everything's fine um but you forgot that the interval you're representing only can be one number at once then you might run into trouble okay what's a static method and when would you use it a static method is just a function and you would write it like any other function like if i want to be able to square a number i would write that what if this function was really kind of associated with a class in some way and so i wanted the way that people access it to not be what am i doing to write square 12 i really wanted them to write like a math dot square 12. and why would i want it this way well it's basically just a way of saying like i want to group a bunch of functions together and i want to use a class to do it and have attribute notation kind of take care of that for me well if i make a math class and i put square in there something's gone wrong because normally methods start with self but there's like no self there's not a math out there this is really just like a different way of using classes to just group stuff together and if i want square to be a regular function but happen to exist inside of a class then there's a decorator to do that i think it looks like that and what's the story here well now i can square stuff uh if for some reason i made a math i could square stuff with that math and it wouldn't try to like fill in a self for me so all this does is get rid of any kind of interesting self behavior and you leave out self entirely which means that this is reduced to just being a regular function and so if you didn't want to like have fun regular functions live inside classes you wouldn't need this at all but sometimes organizationally you want that because you want people to refer to it in a particular way at which point you might use a static method the last question was is there anything you don't like about python's object system good question uh sorry i just sent you the question i have one minute yes the answer is yes i don't like how um undisciplined it is um i there are things i like which is unlike java you can actually write code without classes and that's nice it's nice you just getting your hands dirty i don't like sort of the the sloppiness of it that you can you can it's not quite as precise as i would like um like for example michonne asked about the public private i actually think that's john's right we're not adversarial but i i i tend to think that that kind of functionality is nice but so but there's other things i really like about it yeah it's really minimal and that's not ideal in a lot of settings especially when you're trying to collaborate on like really large programs across many people i think the minimalist flavor of python's object system kind of limits the ability to scale this to really large programs now people done it anyway but they've often done it by building a lot of extra a lot of extra infrastructure on top of the language like you come up with some system for defining who is allowed to call what that isn't built into the language and that's just a shame right it's better to have it kind of built in but it's a reasonable decision it's just a compromise like having something that's simple can be good because then people can learn it faster and uh when you read somebody else's code you're not faced with a bunch of like tricky stuff that you've never heard of at the same time it's uh it can be a barrier to like really using the language for something extremely ambitious so like i was at google for a while and there was a lot of python code but there were rules about how you were allowed to write your python code and like extra comments that you had to put everywhere that were pretty elaborate in order to basically force some kind of additional structure into the language that wasn't there and that you know that seems like uh indication that the language was not a good fit for 