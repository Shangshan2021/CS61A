Onto a new topic, Inheritance. This is a new  feature of the Python object system. And it's a   feature that exists in almost every object system  in every programming language. So inheritance is a   method for relating multiple classes together.  Because not every class exists in isolation,   sometimes one is just similar to another one. And  we want to express that relationship. So the most   common use case you should think about when using  inheritance is when you have two similar classes   that differ in their degree of specialization.  So the specialized class might have all the same   attributes as the general class, along with some  special case behavior. The way you express this   syntactically in Python is that in addition to  having a class statement with a name and a suite,   you can also put in parenthesis, a base class,  and the base class is what this class inherits   from. So conceptually, what happens is that the  subclass, the one that we create, when this class   statement shares all the attributes, with its  base class up here. The subclass might override   certain inherited attributes in order to change  its behavior slightly. But anything that's not   changed stays the same. So using inheritance, when  we write down a subclass of an existing class,   all we do is we specify what's different about  this subclass from the base class. Everything else   stays the same. Let's do an example. So let's say  we have a CheckingAccount. It's like an account,   but special in the following way. When you create  a CheckingAccount, you still give it a holder. But   its interest rate is lower than the interest  rate that you would get on a normal account.   So you get less money every month. When you  deposit, it's the same thing as before. You   add money to your checking account. When you  withdraw money from your checking account,   you incur a withdrawal fee. I mean, the  bank has to make some money somehow,   right? So when you withdraw $5 from your bank  account, and there's 20 in there, what's really   left over is a balance of 14. Okay, so most  of this behavior is shared with the base class   account. So all that's different is that we have  a lower interest rate. And when we withdraw money,   we have to pay an extra dollar. Okay, here's how  we write the code for this checking account. We   say there's a class called CheckingAccount. Its  base class is Account. Another way of saying   the same thing. We'll create a class called  CheckingAccount that inherits from Account.   So this is a bank account that charges for  withdrawals. We set that withdrawal fee to   be $1. We set the interest rate to be 0.01 instead  of the usual 0.02. And then we also have to change   the withdrawal method. Because writing down  withdrawal fee might seem like it's helping   us get in the right direction. And it is. But we  haven't ever said how to use the withdrawal fee.   So we have to write down a method that does that.  And we'll write down the withdrawal method. So   the withdrawal method takes some amount. And what  it does is it withdraws from the current account,   the amount that was specified, plus whatever the  withdrawal fee is for this current account. Now,   why do I keep saying current account, when it  says self right there? Well, remember that self   is the name we use to refer to the object on which  this method gets invoked. So when we actually call   withdraw right here, self will be bound to this  checking account, which is currently called ch,   and was originally created when this call to  CheckingAccount. Okay, so we'll withdraw $5,   amount will be 5, we'll add in the withdrawal fee  of 1, which is shared among all checking accounts   because this is a class attribute. And then how  do we actually do the withdrawing? Well, that's   the interesting part. We refer to the method  on the base class called account.withdraw. Now,   since we're looking this up on a class as opposed  to on an instance, we're not going to get a bound   method back. We have to supply the self ourselves.  Okay, since we put Account here as the base class,   we don't need to say anything about  depositing that just stays the same   as it was before. We don't need to say anything  about init. That just stays the same as it was   before. So checking account start out with $0.
Okay, so let's talk about looking up attribute   names on classes. The base class attributes  aren't copied into the subclass. Instead,   it's part of the process of looking up an  attribute by name that gives you the behavior   and an attribute of a subclass that isn't changed.  It's just the same as whatever the base class was.   So to look up a name in a class, here's what you  do. If it names an attribute is in that class,   then return the attribute value. Remember,  attributes are name value pairs. If not, look at   that name in the base class, if there is one. Now,  the base class is just a class. So we recursively   are doing the same thing. We'll look there. See  if that attribute is in the class. If so, we'll   return its attribute value. Otherwise, we'll look  it up in the base class of the base class. Okay,   so let's talk about exactly what's happening. When  I create a CheckingAccount, I pass in Tom as the   holder. Since the Checking Account class we just  defined doesn't have an init method of its own,   we look up the name init. We don't find it in  CheckingAccount, but we do find it in Account.   And so that's the one that gets called. And that  sets the balance to 0 and the holder to Tom. When   we look up the interest rate, well, there is a  special interest rate for the CheckingAccount.   So that's where we find it and is 0.01. When  we deposit, all that depositing happens from   the accounts method. So here's what we do. We try  to evaluate this operator expression, which is a   dot expression, which means we look up deposit on  this CheckingAccount. We check in the instance, no   deposit attribute there. We check in the checking  account class, no attribute deposit there. So   then we check in the account class, and it has a  method called deposit. We get back a bound method   here. And we call it on 20, depositing $20 in the  account. And finally, when we withdraw, we'll find   that in the CheckingAccount, and that gives us 14.
Okay, let's just write the whole thing down so   that we understand what's going on. So on the  right, you see the account class from last time.   So in addition to the class that we have, we're  going to create a CheckingAccount which inherits   from Account and has a different interest rate,  and has a fee associated with all withdrawals   of $1. And the way that fee gets used is that  we write or withdraw method that withdraws not   just the amount, but $1 extra. Okay, now, it's  reasonable that we could just copy this over   right? Say, the first thing we're going to do is  we'll add 1 to amount. And then we'll go through,   and we'll check and see if the amount is too  big. If it isn't, we'll say insufficient funds.   If we're okay, that will change the balance.  And we'll return that balance. This will be   correct for a while. But the problem is, if  we made changes up here, they wouldn't be   reflected down here. So that's why instead in the  example that I showed you, I said, let's actually   just use the implementation, we have already,  account.withdraw. That's this function right   here. And what does account.withdraw take?  Well, it takes self and account object as a   first parameter. And the second parameter is the  amount that we want to withdraw, which is whatever   amount was passed in here, plus the withdrawal  fee. Let's quickly verify that this works. So   if I have one account, that's an old kind of  account for John. And then another account,   which is a CheckingAccount for my good friend  Jack. So a is an account, b is a CheckingAccount.  They both have a balance of 0. Let's add a  balance to each by depositing into 100 in   a and depositing 100 in b. Now, both of those  did the same thing, because they're both using   the same deposit function over here. But if I  withdraw $10 from a, I have 90 left. Or if I   withdraw 10 from b, then I have only 89  left, because I use this withdraw fee.
