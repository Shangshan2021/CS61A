Next, we'll talk about designing object-oriented  programs. Some of the choices you'll encounter,   and some guidance for how to come to a useful  solution. Okay, here's the checking account   class that we just defined. Now, let me  just reiterate why we did certain things   that we did. So first of all, it's important to  continue following the guidelines that you saw   earlier in the course. Don't repeat yourself,  use existing implementations whenever you can,   and try to avoid copying and pasting code. Second,  attributes that have been overridden should still   be accessible via class objects. What am I talking  about? Well, to override an attribute means that   in the subclass, you're giving an attribute the  same name, as exists in the base class. So here,   we see the CheckingAccount class has withdraw,  which also exists in the Account class. But even   though we've overridden that name, meaning the  CheckingAccounts we'll call this withdraw instead   of the original withdraw, we can still access  them and use them using the class object. So   here's the account class, and account.withdraw  will give us the original withdrawal method,   as opposed to this new one for CheckingAccounts.  So we can still defer to the old logic. And we   just make this small change of using a withdraw  fee. You can also look up attributes on instances   whenever possible. And this is a good idea.  So what am I talking about there? Well,   when we compute the total amount that we're  going to withdraw, amount + self.withdrawal_fee,   we had several options here. We could just write  amount + 1, hard coding with the withdrawal fee,   but then we could never change it. We could also  write amount + checking account.withdrawal_fee,   which would get this one, this attribute here,  but it wouldn't allow for the fact that some   CheckingAccounts might have a special withdrawal  fee. So the best way to do this is to look up   withdrawal_fee on the instance itself, which means  that if that instance has a particular withdrawal   fee, we'll use it. If not, we'll use the one from  the account. Okay, so here we have an attribute   look-up on a base class. And here, we have looking  up an instance attribute. And that's preferred   to looking up CheckingAccount.withdraw_fee,  because it allows for specialized accounts,   either through further sub-classes, or by giving  instance attributes to particular accounts. The   other thing you need to think about when  designing an object-oriented programming   is when to use inheritance, versus when to use  composition. What's composition? Well, that's when   one object has another object as an attribute.  And that's a very common pattern as well. So   object-oriented programming shines when we follow  the metaphor, that is we treat objects like real   things in the world, this helps us think about  them clearly. So inheritance is best to represent   is-a relationships. Meaning a CheckingAccount is a  type of account. So CheckingAccount is a specific   type of Account. So CheckingAccount naturally  inherits from Account and thereby has all of   the attributes of that account. Composition,  when one object has another one as an attribute,   is best for representing has-a relationships.  So for example, a bank has a collection of bank   accounts that it manages. So in that case, a bank  has a list of accounts as an attribute. But a bank   won't inherit from account. And an account won't  inherit from a bank. They're related, and then   one has the other as an attribute, but they're  not related according to inheritance. So let's   design a bank real quick. A bank won't inherit  from account because the bank has accounts. And   what will it look like to use a bank? I'll create  a bank, so that we have a new bank. And bank is   going to do things like create accounts for us.  So if I go to the bank, and I might open account,   give them my personal identifying information.  I'm John. Here's $10. Please open an account for   me. And the bank will remember that it's open that  account and it will return it. My good friend Jack   might go to the bank and open an account as well.
And Jack only has $5 with him. And the bank   manager says, oh, that's fine. But you're going to  have to open a CheckingAccount. So John has just   a normal account, which means John's interest  rate is should be 0.02. Whereas Jack's interest   rate with his CheckingAccount will be 0.01. Okay,  so what will banks do? All banks pay interest on   the money that you keep with them. So let's say  we just paid that interest. And now we can check   and see what John's balance is. And balance has  the $10 that he had before, and an extra 20 cents   because he had 2% interest on his $10. Okay, so  now we have an interesting problem on our hands.   How do we implement the bank? Well, let's look  for some clues about how to implement the bank,   by this example, that we've drawn so far,  and we'll write the implementation. So bank   is constructed with no arguments. What's gonna  happen when we open a bank? We're gonna have to   remember what accounts are held by that bank.  When I go to a bank, and I open an account,   that's a method where self is bound to the bank.  And then we also see that we have a holder,   an amount, and some kind of account that we  open, which is optional. Let's say by default,   we open a regular account. What happens when we  open an account? Well, we have to create that   account. How do we do that? Well, we'll call kind,  which another account of CheckingAccount. Pass in   the holder, because that's how bank accounts  work. Will deposit into that new account,   the amount that was given to us. Next, we have  to remember that this is one of our accounts,   as opposed to an account in another bank. So  we're going to add this account to our list of   accounts. And then we can return. Okay, what's  the last piece of the implementation? We have to   be able to pay interest. Paying interest takes  no arguments beyond the bank itself. So how do   we pay interest? Well, we have to go through every  account that we have. So we'll call it a. And how   do I get all of the accounts that I have? Well,  that's called self.accounts. And for each one,   I'll deposit some extra money in it, which depends  on its current balance and the interest rate for   that account. Let's see if all of our tests  pass. And they do. So we've implemented the   bank not using inheritance. So are we finished?  Well, not quite yet. We need to provide some   protection for our bank. Because we don't want our  bank to get into trouble if it ends up paying out   too much interest. So we should probably write  a function about whether it's too big to fail.   And when would that be true? Well, probably  whenever we have at least two accounts. So is   this bank too big to fail? Certainly is. I mean,  it holds both John and Jack's money. Test passed.
