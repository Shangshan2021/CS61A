Let's stress test our understanding of attribute  lookup and inheritance by working through a   slightly more complex example. Here it is. I  suggest that you pause the video and try to   figure out what happens after you run all this  code on the left, and then evaluate these three   expressions on the right. What are their values?  If you finish that, try to answer the question   of which evaluates to an integer, b.z, b.z.z,  b.z.z.z, b.z.z.z.z, or none of those? So like   I said, please pause and work on it on your own.  We're going to go through the solution in 3, 2, 1.  In order to solve a problem like this, you need  to figure out what happens when you execute these   three class statements. And then these three  assignment statements. Let's take a look. When   you execute class A, you create a new class. A  class is like any other value in the sense that   it can be assigned a name. And the name that it  gets assigned in the global frame is capital A,   because that's the name that we gave it. Now  the class itself has two class attributes,   z is -1 due to this assignment statement. And f is  the function that returns B(X-1). This function,   like any other function, does have a parent frame.  All of the functions in this example have parent   frame global, so I'm not going to write them in.  So this structure was created by executing the   first class statement. The second class statement  creates a class B that inherits from A. And   forever, this class will know that it inherited  from A or that A is the base class. It also has   some attributes due to the body of this class  statement. So n is bound to 4 and init is bound   to a function that initializes self. In the global  frame, this class is given the name capital B.   Finally, the third class statement creates a class  C which inherits from B. Since B inherits from A,   any instance of C will have access to the contents  of A, except for when it's the case that some name   is repeated. So the class C or an instance of the  class C will have an f that's different than A   is because f is overridden. There's another  definition of f, which in this case is the   function that just returns x. This whole class  is given the name C capitalized in the global   frame. And then we execute these three assignment  statements. Calling A introduces a new instance   of A and we'll call it a. Since there is no init  method within the class definition A, there are no   instance attributes that are set. This A instance  is just a blank slate. Now we create B of one,   calling B introduces a new B instance. And the  init method for B is called automatically with   self bound to the instance and y bound to 1.  And then we have some expression about self.z,   which depends on y. So since y is a true value,  we're going to call self.f on y. Which f does it   call? Well, B doesn't have any f. So then it looks  in the base class and calls this f which creates   another B. Oh my goodness, that's complicated.  Let's not worry about it just for the moment.   And instead, focus on the fact that z is sent.  self.z equal to something. And it's whatever   is the return value of this call to f. Whatever  the attribute contents of this B instance may be,   that instance itself is assigned to the name B  in the global frame. And now, we have attribute   assignment to an attribute of a lowercase b.  So I look up b in the current environment,   it's this instance. Setting n equal to five means  that I add an attribute here. This has no effect   on B's class or its base class. Instead, it's just  a change to this particular instance. Now I think   we're in a good position to review some of these.  Eventually, we're going to have to fill in what   z was. But let's solve the first two here before  we do that. So C(2).n. Here's an expression that   has to evaluate to some object. In this case,  it evaluates to an instance of the C class.  Here's the C class. So we build a new instance.  And what happens when you build an instance So   the C class is that you automatically call the  init method for the C class. Since C has no init,   we look at its base class. Here's the init, which  is this function here. So we're calling this with   y bound to 2. If y, which is 2, is a true value,  then we'll set self.z to be self.f(y). Now what is   self in this case? Self is the C instance that we  just created. So we're going to add a z attribute.   You can see here in my slide that it's going to be  2. Why is it two? Well, we look up self.f. What's   the f function for the C instance? There's no f  attribute here. So we look in the class, there's   the f attribute. It's the identity function. So we  call the identity function on 2. We get back 2 and   that gets bound to self.c. So c is 2 here. But the  interesting thing is that C(2) having been created   is only used to look up the attribute n. So when  we look up the attribute n on this C instance,   since n is not an attribute, we look in the class.  n is not an attribute here. So we look at its base   class, n is here, so the value of C(2).n is 4.  If we had instead asked what C(2).z, we would   have gotten 2. Alright, is it the case that a.z  is equal to C.z? Let's figure out what a.z is. A   is this instance. It does not have a z attribute.  So we look in the class. There is the z attribute,   it's -1. So the left-hand side of this equality is  -1. C refers to the C class. C.z is an attribute   which does not appear here. So we look in the base  class, no z here. So we look in the base class and   we see z is -1. So these are equal because, in  fact, we're referring to the same attribute in   two very different ways. Okay, a.z, we already  figured out, is -1. And what's b.z? Well, b is   this B instance, and it has an instance attribute  called z. We never really wrote down what it is,   but I'm pretty sure it's not going to come  out -1. I think it's time that we figured out   what it does equal. So when this instance was  created, we passed in 1. As the value for y,   self is bound to the instance itself. We checked  that y was true. And so we called self.f on y.   Since b is an instance of the B class, f refers  to this. Because we look here, there's no f. So we   look at its class, there's no f. And so we look  in the base class, and there's f, which is the   function that returns B(x-1). B(x-1) creates a new  instance of the B class. But this time, we call   the constructor on whatever x was. That's 1 minus  1 is zero. So now we're calling this on 0 for the   second instance of B. Since 0 is not a true value,  we set self.z equal to a C instance, where we pass   in 0 plus 1 is one as the argument. So we're about  to construct a C instance where we've passed in   1 as the argument of the constructor. C has no  constructor, so we look in the base class and we   find this constructor. y is bound to 1 and 1 is a  true value. So we set self.z for this C instance,   to be self.f. Now since self is bound to the C  instance, self.f is looked up here, and then in   the class for C. And there is an f there that just  returns whatever was passed in, which in this case   is y equals 1. Tada! Okay, so it's quite clear  that this is -1, and this is some B instance,   and those can't be equal. And now we can move  on to which of these expressions evaluates to   an integer. b.z is a B instance. b.z.z is a C  instance. b.z.z.z is 1. And 1.z is nothing at all.   That would be an error. So only this expression  evaluates to an integer, and that integer is 1.
