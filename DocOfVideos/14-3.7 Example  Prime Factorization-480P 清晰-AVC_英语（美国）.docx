let's work on a slightly more complicated example where we'll use a while statement to do something more interesting find the prime factorization of any positive integer what is the prime factorization anyway well each positive integer n has a set of prime factors which are primes whose product is n and it turns out there's just one unique way of writing each integer of writing a positive integer as a product of prime numbers as long as you order them from least to greatest one is kind of a funny case and that it technically doesn't have any prime factors at all but let's not worry about that so much and focus on numbers bigger than one like 8 or 9 or 10 or 11 or 12 so here are their prime factorizations how would you find the set of prime numbers that you multiply together to get some n for any n well here's one approach it's the one that i learned when i was a kid take n find the smallest prime factor of n divide by it and do that again for the number that results by dividing n by this prime factor so here's some number let's say we want to find the prime factorization for it well we just start looking for primes that divide into it evenly it's an even number so 2 divides into it leaving us with 429 left what are the prime factors for this well 2 doesn't divide evenly into this because it's not a number but 3 does so 858 is 2 times 3 we found 2 first then we found 3 and now we have to try to find a prime number that divides evenly into this 2 doesn't work 3 doesn't work 5 doesn't work 7 doesn't work but 11 does if you divide 143 by 11 you get 13. so first we found 2 then we found 3 then we found 11 and we'd have to find what prime number divides evenly into 13.
well it turns out 13 is prime so this approach of finding the smallest prime factor that divides into whatever we're working with to get some new number that we then find the prime factorization of is what's called an algorithm it's a computational process i could describe it in english or i could describe it in code so now that we have an approach we can try to write the code that does this and let's write it as a function of n so let's describe what this does let's just print them out print the prime factors of it and then start writing some examples so the prime factors of eight we're supposed to win two and two and two the prime factors of nine are three and three the prime factors of ten well now we have to pick the order so how will we do two and five we might as well specify this in increasing order would be one way to write it but these aren't actually increasing they're the same so the point is that it never goes down sometimes it goes up sometimes it stays the same that's called non-decreasing order okay if there's only one we're supposed to print it out the next interesting one was 12 which is 2 times 2 times 3 and then we did this tricky one 858 which was 2 times 3 times 11 times 13.
so now we have a bunch of examples we can test our work but how do we actually solve this problem well we write down code that corresponds to the process that we came up with in the first place as long as n is not 1 that means there's a prime factor for it while n is greater than 1 i have to find the smallest prime number that divides evenly into n how do i do that well who knows but let's not worry about how to do that let's just write down the fact that we have to and we'll call the result k pretty soon i'm going to have to implement smallest prime factor but for now let's just assume that we could do it if we could do it then we would divide by it i can use floor division because i know k evenly divides in that's part of its definition i also need to print k out and i think that's all there is to it to printing the prime factors of n is to find the smallest prime factor of whatever number i'm dealing with so if this is 858 i'll find the smallest prime factor is two then i'll divide by that to get 429 i'll print out the two and then i go back and do it again find the smallest prime factor of 429 is three divide by that is 143.
print out the three and do it again but i can't run this code until i define smallest prime factor well the smallest prime factor it turns out is the same thing as the smallest factor greater than one so i could just try dividing in by different values k starting with two working my way up until i find one that works turn the smallest k greater than one that evenly divides in so we'll start with 2. if it's the case that dividing n by k does not give me zero that means k does not evenly divide n then i need a different k and if i want to find the smallest one well i could start at two and then just work my way up so this says try dividing by two if it doesn't work out then add one to k so then try dividing by three if that works out then we return k i don't return k in here because i only want to return after i've gone through this while statement long enough to find a k that evenly divides n so it is important how you indent the return statement here indenting it at the same level as while means after while has repeated as many times as it's going to repeat then return k whereas writing it here would say the first time through it's time to return that's not when we want to return k okay let's play around what are the prime factors of eight two two and two what about eight hundred and fifty-eight two three and eleven and thirteen so it does what it's supposed to do in fact we could run all the dock tests that we've written down so far and make sure that they all pass so we've solved this problem but we're not going to stop discussing it two things i want to point out is that if you want to see how this is working drawing an environment diagram is a good choice so for example i could copy my code paste it in here compute the prime factors of 12 and see what happens there's 35 steps that's not an overwhelming amount the first two steps are just to define the functions then we call prime factors on 12 which immediately calls smallest prime factor so it needs to find something that divides into 12. 2 does and so it returns 2 so k is the smallest prime factor of 12 and then we change 12 to 6 by dividing by 2 and we print out the number 2. now we go through this while statement again finding the smallest prime factor for 6 that introduces another frame where n is 6 and the return value again is two so another two gets printed out and now we're going to try to find the smallest prime factor of three so we call smallest prime factor on three that's another call the smallest prime factor this time with n equals three here we can see this loop do some work k starts out at 2 but since 2 doesn't evenly divide 3 it changes k to 3 3 does evenly divide 3 so we return 3 and watch what happens here n is set to 1. because we divided three by three we're still not done even though we've met the wow condition because we finished the body of the while statement printing out three then check the while condition one more time n is now one and so we're done prime factors returns none but it's already done all the work it needs to do printing out two two and three so if you want to see what's going on inside a program that you're writing python tutor can be a good way to do it but i'm still not done talking about this problem i introduced this second function remember when i said i was writing this program i didn't even know how to do this yet well i did but i was pretending i did i just gave it a name and didn't worry about how to do it that's a form of abstraction that's functional abstraction now that we know how to do it we could think about whether we needed another function at all could i have just kind of pasted this in here instead get the indentation right and then i don't have to have two functions anymore well it turns out this doesn't work because return here was about returning back to the middle of the while statement in prime factors when we wrote it in the first place whereas now if i call prime factors on 12 it tells me just the two this return statement isn't returning from this little block it's returning from all of prime factors meaning that we can't keep printing out the rest of the prime factors now there is a way to get this to work which is to get rid of this return and now when we get the prime factors of 12 it behaves correctly and i would say you know this is not bad this is a reasonable way of solving it but there's enough going on here that i would think we'd need to rename k to the smallest prime or something like that because it's pretty hard to just glance at the code and see what k is doing here so now things have gotten a little bit more complicated because i had to change this name code still works but now it's still kind of hard to read smallest prime is two it's not two it's eventually going to be that this name is bound to the smallest prime but it's not at the beginning which makes this program just a little bit harder to read than it would have been when we broke it up into two functions one of which had the job of printing and executing that algorithm that we described at a high level earlier find the smallest prime and print it out and the other one had the job of finding that smallest prime so even with this name change which helped a little bit i still think this is a worse program than the one where we had two but it is interesting program because it has a while statement within a while statement and that is allowed in python as far as the interpreters concerned this program's just as good so the moral of the story is there's more than one way to solve a problem but often using functions and their names makes everything clearer than trying to fit everything into one long body of a program by nesting a while statement inside of 