61a lecture 19 q a hey john let me ask a question while we wait for somebody to chime in when object oriented first started this notion of inheriting classes was very popular and i think sort of was a big motivating factor and you had this nice lecture at the end where you you talked about how complicated it gets like what's the what's the thinking these days with object oriented i've always found that once you get beyond one or two classes of inheritance it just becomes unruly like where are things these days uh good question i think that um there are definitely people who think that inheritance should be completely avoided yeah um a more but that's sort of an extremist view i would say a more common belief is that inheriting methods is fine it's inheriting attributes that's complicated because um yeah if you don't know where the attribute was originally declared then it's hard to kind of keep track of what's going on so i i see programs where yeah like functionality defined by a bunch of methods is inherited sometimes even multiple inheritance inheritances allowed there but you just want to be careful about like having attributes defined in one place and then having a subclass that like tries to ignore some of those attributes because it's different enough that you don't want them all that gets messy pretty fast and it's usually better to just use composition instead yeah that sounds about right i have to say i think i'm much more likely to use composition than inheritance that's really common sure so the question is about this complicated example and what's going on um and in particular there was an example at the end about b dot z dot z dot z and why is that right but four z's is wrong and two z's is wrong and one 1z is wrong once you have the right picture then solving these problems is not so bad so let's say that we had already gone through the work to draw a picture like this about what's going on then let's talk about how dot expressions are evaluated this dot expression b.z.z.z is taking the dot z of something but you don't know what it is until you compute it and to compute it you have to evaluate b dot z dot z but you can't do that until you know what b dot z is you can't do that so you know what b is b is just a name so that's something we've been able to handle since the first week of class we look in the global frame we see that b is this thing this object is a sketch of what it would look like to have an instance with a particular class so this has the b class and a bunch of instance attributes in this case there's one called z and one called n we're gonna access the one called z which brings us to this object happens to be another b instance so this thing one way to refer to it is b z how did i get there i went to b and then i went to it's z and i got to this object now it also happens to have a z attribute it's not like this is related to this one in any way they just happen to have the same name okay so when you look at what's bs.z.z we have to follow this and figure out what we get and then we get this object so is the answer b.z.z an integer no b z dot z is an instance of the c class so it's some object that's not an integer but it happens to have an attribute whose name is z and its value is one so if you evaluate b's z [Music] z z you get a number a number one so that's why which of these evaluates to an integer happens to be b z zero z as opposed to one of these other ones if you were to take that integer and look for its dot z you would get an error integers don't have z attributes and if you were to do either of these other ones what you'd get back is one of these objects along the way so b is an object b dot z is an object b dot z z is an object it's only b does easy z that gives you a number okay so sometimes there are these long chains and uh we're just following them basically looking at this from left to right what's really going on is that we're figuring out what object to finally get the dot z of but to do that we have to figure out what object would to get this dot z of what object to get this dot z of and so you end up working from left to right in order to find the answer by the way don't ever write code that looks like this ever this is a good pedagogical example but this is not what your code should look like that is that is certainly true okay so now let's back up a little bit and figure out how we got here in the first place we started with this long example and maybe we'll work our way up to a z equals b dot z by saying there's a class a there's a class b there's a class c there's an instance of a there's an instance of b and then this doesn't create a new instance at all this just is an attribute assignment so this is changing the b object to have an attribute called n which is value 5.
this expression does create a new object but i'm not sure that's the interesting one so when you execute a class statement you get a new class when you execute this class statement you get a new class when you execute this class statement you get a new class so this has all happened before we actually made an instance of anything when you make an instance that creates some object now we're giving it a name using uh an assignment statement so this is called a and remember that when you create this thing you have to execute its appropriate init method it happens to be that the a class doesn't have an init method so there's kind of nothing nothing special about this object it has no attributes at the moment this one on the other hand when we create b we're um calling the b class oh sorry somebody needs to mute i think hold on i'm gonna start muting people when we call b then um we create an instance of the b class but we do have to um call its init method because it has one and this is what always happens when you create a new object you um start it out as a blank slate and then you start passing it in as well as any arguments to the original constructor so y would be bound to one self would be bound to this b instance and then we check if y is true which it is so we set self.z to something and i put this dot at that because we actually don't really need to figure out what this does um in order to answer the question of whether a dot z equals b z okay so let's see what we can learn about this structure if we look at a and try to find its dot z we first look at its instance attributes it has none so if we're looking for its z we look next in its class it's an instance of the a class so we find that it does have a z the z is the value negative one so that's what a dot z would evaluate to what about b z sorry b is this thing when we look up dot z for the b object we look first at its instance attributes and it has one i didn't bother to figure out what it was yet but i'm pretty sure it's not negative one um so b dot z will give you whatever this object is if we finish the evaluation um we would have to go through and figure out what self.f returns and uh we did that eventually in lecture it returned this other b instance so what this is evaluating is is a dot z which is negative 1 equal to b z which is this b instance and the answer is no like a number is never going to be equal to uh some object yeah so let's sketch this out and then we'll answer your question and the question is about if you're using composition instead of inheritance how do you access the attributes of the elements of something so if you have an account which has a balance and we have a bank which is not a subclass of account it's just its own thing and when we create a bank we'll just have a set of accounts which starts out as empty and then we have like open account this is a little different than what was in the lecture but it's pretty close so um what open account is going to do is it's going to create a new account with whatever name was passed into the bank so the bank gets the name and uses the name to create an account and now uh how do we figure out how much money is in that account this is sort of the minimal example if i have a bank and i open an account for myself i don't have a name for that account i can't access it directly because it's not in the global frame the only thing that's in the global frame is the bank but the bank has a list of accounts and there's now something in that list so if i go into that list of accounts and get the element at index zero whose account is that that's john's account and how much money is in it zero dollars because we haven't deposited anything into it so the answer in general to your question of like when you're using composition how do you access attributes of the parts is often using some like chain of dot expressions where instead of having a name for this account you have an expression that's like some compound expression for this account that goes in and gets part of the goldman the bank finds his list of accounts gets its thing and then gets its balance now we could have had a method that does this instead that would have been fine um but this is kind of the minimal example of how you would access some piece of the composed bank you can think about the account as just being as john just said one level removed from you instead of having a global variable that where you created the account it's now stored in a list inside of another object so now look at the command object goldman list accounts get the element sub zero what is that that's now an object of type account and now you can do whatever you want with it you can you can access the member function you can access the data it's as if you as if we had just written uh john's account equals goldman dot account sub zero that's that object now now it's all the same thing yeah so just levels of interruption you have to follow yeah good question so the question is can you use a syntax to refer to a method that just states which class contains that method then the method name and then call it where you explicitly pass in the object that you want to call it on and the answer is yes so um if you have an account there's really the normal way of depositing into it which is that you would refer to the method by using a dot expression with the object that you're interested in and you could think of this as shorthand for find the class of a and deposit into that using a as the account itself and 12 dollars as the amount in fact uh you could write this out if you really wanted to get the type a is a an account and deposit into that 12 now you wouldn't write this because it's just like a more complicated version of this it's allowed because this happens to be just a function this function you've defined here and so you can call it as a function but there isn't really a good reason to do it uh there happens to be when you're using inheritance occasionally a reason to reference things that you've overridden and this is one way to do it and so there's like an occasion where you would actually do this kind of thing but it is allowed otherwise it's just not something that i think is is normally done yeah i think it would be considered poor form if you wrote that it's i think you should avoid that because it's just it's not something that most programmers would would would sort of do and you know i mean even though things are allowed doesn't mean you shouldn't necessarily do them but it does illustrate you know what is this doing it's basically doing that it's getting some function and filling in a yeah good question so what is super which is some built-in function that really is quite magical in my opinion um in terms of what it does so it's better to describe what it does instead of how it does it but what it does is it says when you look up this method for uh this is kind of related to self let's say self is a checking account when you look up its withdraw method skip the one that's in the checking account class and go find the one in the account class instead we could have said this explicitly we could have said go find the one in the account class if we kind of knew where to look this is asking python to find it for you saying you know python you know about you know what the parent the super class of or base class of checking account is so why don't you go find that version of withdraw that's what this says and um this actually wasn't always the syntax in python there was like a different version of this in python 2 i think it works fine people do use it and it's a very subtle thing it's basically saying i want something that's just like self except for it ignores the withdrawal within the checking account and all goes and finds the one that was there before checking account was ever defined which um you know you could say that explicitly go find the accounts withdraw or you could have python look it up for you is it weird john that you don't have to pass self when you use the supernotation yeah so that's an interesting thing is that super isn't referring to the account class it's like referring to a version of self as if account where it's class instead of checking account where it's class so it's doing two things at once it's going and finding the account class and it's also filling in self for the withdraw method so that you don't have to pass it in explicitly it is a lot to just like have a built-in function call with no arguments and somehow it does all that magic that is what it is so you know you don't have to memorize this we don't test you on it or anything like that this one is a little bit more explicit but it does mean that you have to be redundant you have to say like oh the account is this base class and that's the thing that i want to get the withdrawal function from yeah great question and that's exactly right so if there weren't a duplication or an overriding of withdrawal where it existed in both checking account and the base class account then you wouldn't need super this is strictly a thing for when you have inheritance and you're using the same method name in both the subclass and the base class although i would argue you probably should still do it as sort of a built-in documentation so that the user doesn't have to like you know scroll through your class to figure out which one it's sort of nice the thing i like about the making the explicit is you're telling somebody which one is it going to as opposed to relying on some default and then what if somebody actually comes in and puts up a draw function later on i mean do you so sometimes it's good to make things explicit even if there's a default um response you know yeah but one thing i would say is like if you have a deposit twice which is like totally new which is fine your your subclass can have totally new stuff in it um and what you want to do is deposit this amount twice you can just write self.deposit that amount and then do it again you don't really need to use any supers here or anything like that and you can trust that python will look it up for you correctly yeah good question so the question was in this example if we made an a but we passed in some argument when trying to construct an a would you get an error and the answer is yes since there's no in it um it's not expecting any arguments so um by the way i've always thought this was weird that python let you build a class without a constructor it is kind of a funny thing but if we have no constructor if it's just like no constructor here yeah strangely enough if you had an account that you've managed to create correct successfully while it doesn't have a balance you could give it one later so while this is possible it's rarely terribly useful the next question was do you have to call init init with the underscores or could you call it something else you have to use the inet it's not a convention because when you call the constructor it has to know which function to call and that's a special name and it always has to be underscore underscore net underscore underscore the next question was whether you're supposed to know all of the special method names in python like underscore underscore init underscore underscore and some other ones that we haven't covered yet like underscore underscore stir underscore underscore and the general answer is that we will cover this on wednesday tell you what you need to know and what you don't know but here's our answer well you have to know the constructors because you can't really build a class without you can't build an object without them and the str function is just what happens when you call print on an object that's not fundamentally defined and so you should know how those functions work and and then but there's no so yes you absolutely should know how the the constructor and the print functions work or the str and the init functions yeah so we'll go over the stir and wrapper functions in wednesday's lecture along with a couple of others you don't have to know all of the special method names there's like a long list of stuff that's built into python and uh we'll give you a kind of overview of what they all are in wednesday's lecture but you're not expected to memorize them all but the ones that create string representations are particularly important and as well as in it okay so um the question was why does this multiple inheritance version of an account give you only 19 when you deposit 20 well in fact you've paid a two dollar fee somewhere because there was one dollar in there already so depositing 20 should get you to 21.
but instead it got you to 19 somehow why is that well let's look back at the code we came up with a savings account which has a deposit fee of two dollars and what happens when you deposit into your savings account is that you actually deposit the twenty dollars minus two so we deposited eighteen dollars we had one that's how we got to nineteen why is it that this deposit got called instead of accounts deposit well um when you're finding which method to call you look in the class first of the thing that you're depositing into and if you don't find it there then you look into its base classes and then only after you've looked into its base classes do you look in the base class of the base class which would find you the accounts deposit method which doesn't do this nasty thing of taking out a deposit fee so um yeah so basically you're finding methods here well there kind of aren't any except for the init then here then here and then the account class and why the account class even though it's not listed here well that's because it's the base class of these that's right in general and multiple inheritance you'd look in both of these before you ever looked in the base class of one of these so think of it like a tree there's the account class at the root it has two subclasses checking and savings and then you have a subclass you're just going to work your way back up the tree and if you're wondering whether it ever gets messy to figure out which thing happens first the answer is definitely yes in fact like python's now on its third version of how to resolve this question and because there were bugs in the first two so uh don't worry about it this is beyond the scope of the course but multiple inheritance does leave lots of uh computer scientists scratching their heads about what's exactly going to happen which is why in general you should try to avoid it yeah i agree i think one level of inheritance is is more than i even care for but i don't think you should be very careful when you go beyond that yeah so the question is is this slide have anything to do with midterms this did come from a past midterm um so the we won't ask this kind of question because um you know you could just run it and see what happens um i think this semester we're just going to focus more on getting things done rather than knowing exactly the mechanics but exactly the mechanics of how the object system works as we've described it is part of the course so you should know it um but i would guess there's more of a focus this semester on like you know building things implementing things rather than tracing through a complicated example because of the online format and and that's fine for life as well because you know getting things done is is more important than understanding my very convoluted code uh but you know there will be cases in which you find some complicated things out there in the world and you have to trace through them so that is a useful skill to develop yeah good question so how do you keep track of what's an instance attribute and what's a class attribute and which one's which i think instance attributes are just generally more common because usually when you're creating objects you really want to focus on what's true about this particular object and you just store that state as instance attributes but it's not like class attributes don't show up once in a while so you certainly have to know about them uh this particular case where an instance attribute and a class attribute share a name does show up in practice usually when you're trying to get something to do a different behavior than was originally intended so you want to like change the way this particular instance works so that it behaves differently than whoever wrote the class and that you know that is to be avoided when possible but sometimes when you're building off of other people's code and you can't get them to change it then you have to change it yourself by adding an instance attribute that's got the same name as their class attribute so it's not like this never happens uh in practice but it's the rarest of the three cases so most common everything's an instance attribute second most common yeah there's class attributes out there but they have different names than the instance attributes and then the third case is it is possible that you have a name collision and you should know what happens yeah so the question is about this maximum subsequence question from lab four question five uh if you try to trace it you get quite confused because there's just like a lot of calls going on and how does it all fit together so how else might you understand the implementation well i'd say at the outset that it's often the case that tracing through uh tree recursion is not something that humans can tolerate like it's it's just really messy sometimes um so the right answer is to shift the way in which you approach understanding uh implementation to get away from tracing and instead just treat the recursive calls as abstractions they do the thing that they're supposed to do but how they do them is not your problem and then like you can put it together but this is not not like obvious or easy so um so maybe we can talk about that with a particular example so maybe while i read this maybe hani can uh say whether that makes sense to him i i'll add one more thing to it so john's absolutely right that tracing tree recursion is very hard you have to hold a lot in your memory um so one one way to fix it is as he just said is to just think differently about it it's not about tracing it's about thinking about the fundamental nature of um the the functions and they just do what you want them to do and the other is to just use toy examples so if you have really small inputs you can sometimes hold on to the recursion a little bit easier as opposed to something like this that has you know a ridiculous number of steps so um i do think that it does require a slightly different way of thinking as opposed to just drawing the environment map and mapping everything out line by line yeah that is actually great advice is like you know think about maybe a two or three digit example if you want to trace it don't trace a five digit example for something that's going to do something with every digit it's just going to get too messy so how would this go return the maximum sub queen sequence of a length at most t that can be found in the given number n [Music] well if t is zero then i think we only have one choice which is to not take any of the digits of n at all but then we have to decide like are we keeping the first digit of n or i guess the last edge of n is the easiest thing to access because we can access it like that are we keeping the last digit of n or not so um i think it's helpful to pick a value for n so let's say n is one two three and t is two something like that what would n percent ten give you just mark it up like this will give you three that part i think is worth tracing and the rest if we divide by 10 gives you 12. i think you know those pieces you should trace explicitly now what do you do well you're either going to take two digits from 12 or you're going to take one digit from 12 and the 3 at the end so that would be like keep the 3 but then you'd have one less digit for the rest of it or you'd forget the three and you keep both the last digits now you know you can think ahead you can say okay what i should do is is keep the three because it's big but python doesn't know that yet so avoid the instinct of solving the problem for python and instead just like let the computer work through the details itself so you have the components now it's your job to say well i have two options option one let's say like keep last digit is option one which would mean that three is the last digit of this new number how do you get it in there you add it but then this expression here needs to be all the other digits and so it's got to have a 0 in its one's place that's where that times 10 came from and how do you get the rest of the digits well that's where you make your recursive call get your maximum subsequence of the rest using t minus one because you already used up a digit the last digit and you don't need these parentheses i was just trying to kind of guide things as we go um this i think you could trace in the following way instead of looking at the body of max subsequence you should ask yourself if i pass in 12 and 1 into here what am i going to get and you know the behavior of this thing you know you're going to get 2 so 2 times 10 plus 3 is going to give you 23.
that's the degree to which it makes sense to trace is to pretend that this is some black box that does its thing but you don't know how it does it but you do know what its result is which is like what's the biggest digit in 12 well it's two and then the other option is would be leave the how about drop last digit which means you're not going to use last you're just going to use everything in rest but you get to use t digits and if you wanted to return the biggest one then you just take the max of these two when you're tracing through this you want to say like oh what's this going to return well this is 12 and this is 2 so this is going to return 12.
and so uh what's this going to return well the max of 12 and 23 is 23. so at least in this example it seems like it's going to do the right thing that's the kind of tracing that i would do in a tree recursive problem and we realized that we never went back through the body of max subsequence again instead we just asked ourselves what is this going to return and stop there so there's that big leap of faith right where you have to just trust that what you're doing is doing the right thing and by the way if you're wrong well then the code won't work and so it like that uh hold on oh i think there's another one yeah oh how about that there we go sorry a good chapter yeah so anyway that's uh that's kind of the story is don't don't try to trace through the next call because you're just going to get confused if you want to let python draw the environment diagram for you so you can watch it happen that would be fine but doing it by hand is really really 