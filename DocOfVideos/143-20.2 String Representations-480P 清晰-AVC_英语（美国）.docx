String representations. In the object-oriented  programming metaphor, we say that an object   should behave like the kind of data it is  meant to represent. And one aspect of that   is that an object should know how to present  itself to the world as a string or to produce   a string representation of itself. And strings  are important. They are descriptions not only   in natural languages that the humans use  to communicate with each other but also in   programming languages, you can put an expression  in a string. So in Python, this distinction is   built right into the language. All objects produce  two string representations. One is called the str   string. And it's designed to be legible to humans.  The repr string, by contrast, is designed to be   legible to the Python interpreter. That is, it's  supposed to be an expression, an expression in   the Python language. Now, a lot of times the str  and repr string are the same. Because Python was   designed to be a language that people could read,  and so a lot of the expressions have exactly the   same form, as a person might write down when they  try to communicate the same idea. You write the   number 1 in either case. But sometimes these  differ. Let's look at an example. First, we'll   consider the repr string for an object. There's  a built-in function called repr. It returns a   Python expression as a string that evaluates  to an equal object. If I call help on repr,   this is what I see, built into the language. repr  can be called on any object who produces a string,   and it's supposed to return the canonical string  representation of the object. For most object   types, the documentation says calling eval on  the repr of the object gives you some object   that is equivalent to the original. The result  of calling repr on a value is exactly what   you see in an interactive session. It's what  Python prints out right below the expression   you evaluate. So if I evaluate this expression,  which represents 12 times 10, to the 12th power,   the canonical string representation is 1 and then  2, and then twelve 0s and then a decimal point,   and then a 0. And that's what gets displayed.  Exactly the same thing gets displayed if you call   print on the result of calling repr on 12 times  10 to the 12th. Now, some objects do not have a   simple Python readable string. There's no way to  write down an expression that very easily captures   everything at some object is or an expression  for how to create something that's equal to   the original object. And this is typically true of  compound things. So just functions or classes. The   min function that's built-in just can't be written  in a single expression. So instead, what you see   when you call repr on min, is this proxy, which  uses angle brackets to indicate that this is not,   in fact, a Python expression at all. It's just  some standard, a human-readable description   because generating a Python expression just didn't  work out. The str string of an object can be   different. Human interpretable strings are useful  as well. And so we'd like to have our programs be   able to generate them. Because oftentimes,  the program wants to communicate something   with a user. So here's an example. There's a  fractions module, part of the standard library,   and it has a fraction class. A fraction is built  from a numerator and a denominator. The repr of a   fraction is just a call to the class itself,  exactly how you'd construct the fraction in   the first place. That's not how humans write  fractions. Humans write fractions like that.   So str is a built-in function that takes any  object, gives you back a string where the string   is some human interpretable representation of the  original object. The result of calling str on the   value of an expression is what Python prints  out when you actually call the print function.  So if I print half, I'll see 1 divided by 2. Now  notice this has quotes around it because this is   a string. Whereas this is just what happens when  you print the string, the contents of the string.   Alright, let's try it out. From a fractions  import fraction gives me access to this class,   which I can bind an instance of to the name half.  Now half is a fraction. The repr string of half   is just that. If I print(half), I see 1 divided by  2. The str string of half is 1 divided by 2. Now,   if I evaluate the repr string of half,  I get the fraction. It's a different   object. But it's equivalent, right? If I evaluate  to the str string of half, in this case, it turns   out that is a valid Python expression. But that's  just kind of coincidence. What you get back is   not a fraction, it's a float. 1 divided by 2 is  really just there to be interpretable by humans.   We can learn a little bit more about the repr and  str functions just by trying them out on strings.   So here's the string, "Hello, World". What happens  when I evaluate s? I see that string. That's what   happens when I print out the repr of s. Same  thing. Now, what happens if I print out s? The   quotes go away, which is exactly what I see when I  get the str of s, because the str of s is just s.   Now, what happens if I just call repr of s? I see  quotes within quotes. What's going on there? Well,   what repr is giving me is a string, where if I  evaluated it, I'd get back the original string.   And what if I called the repr of the repr of the  repr of s? I'd get a mess. What's going on there?   Well, this is not just quotes within quotes, but  quotes within quotes within quotes within quotes.   And Python has to use backslashes in order to  indicate what quotes really end a string and   what don't. The details of that are not important.  What is important is that if I evaluate the result   of evaluating a result of evaluating the repr  of the repr of the repr of s, I get back s. Now,   what if I had just evaluated s in the first  place? I'd get an error. Hello, World is not a   valid Python expression. When I have quotes around  it, so if I evaluate the repr of s, everything's   fine. But I can't evaluate s or the str of s  because what I have here is not valid Python.
