Polymorphic Functions. A polymorphic function is  a function that applies to many different types of   data. And str and repr are great examples because  you can really pass any kind of object you want to   this built-in str and repr functions and they're  always supposed to do the right thing. How's that   possible? Well, the fundamental idea is that repr  just asks its argument to display itself. And in   Python, this is done using a special method name.  Now, it's a special name because it corresponds   to a built-in function. But this general idea  that you can have a function that just asks the   argument what to do certainly applies beyond the  Python language. Okay. So repr, in particular,   just invokes a zero-argument method called  __repr__ on its argument in order to get the   repr string that it returns. So I can call repr on  half, which was the fraction 1, 2, or I can invoke   its method. Invoking the method gets looked  up in the class. So it's really the fraction   class that knows how to generate the repr string  for a fraction. It's not the repr function. And   likewise, str invokes a zero-argument method that  is correspondingly called __str__, another special   method name. And so I could invoke this method  directly if I wanted. And that would generate   a str string for a fraction. So there's a really  important idea here. You can write a function like   str or repr that actually doesn't have much logic  at all. And just the first of the argument that   comes in to decide what to do by invoking  a method on it with a particular name. So   let's talk about how repr and str are actually  implemented. It turns out that it's slightly   more complicated than what I described. Instead  of just invoking the repr method on its argument,   an instance attribute called __repr__ is ignored.  Only a class attribute called repr is invoked by   the repr function that's built-in. How would I  implement that? So which of the following function   definitions corresponds to a function repr,  that takes in some argument, looks up the class   attribute called __repr__, and invokes it? Here  are five options. Only one does what I described.  Think about it for a minute, I'll  tell you the answer in 3, 2, 1.  This one manages to skip instance attributes or  ignore them by looking up the type of the argument   that gets you the class. And therefore, asking  for the repr attribute of the class is guaranteed   to give you a class attribute. Now it's a class  attribute that's a function. And that function   is not a bound method, because it's looked up on  the class. So you have to explicitly pass in x   in order to have this class attribute invoked on  the particular argument x that we're interested   in. We'll look at an example in a moment. Str is  also complicated. Even more complicated than repr.   An instance attribute called __str__ is ignored.  If there's no str attribute at all on the class,   then calling str just returns whatever repr  returns. So by default, they're the same. It's   only if you explicitly make them different that  they differ. How would we implement that? Well,   let's try. By the way, str is a class on  a function. So when you're calling str,   you're really calling the constructor for the  built-in string type called str. So to explore   all these different nuances of string generation,  let's create a class called Bear. This is a bear   and it's going to have a repr method, which just  returns the string Bear. I'm going to try to   invoke this in various different ways.
I'm going to create a bear called   oski. I'm going to print oski. I'm going to print  the str string for oski. I'm going to print the   repr string for oski. I'm going to print what I  get when I invoke on oski, the str method, and I'm   going to print invoking the repr method on oski.
So, at the moment, all of them print out bear.   There are five different print statements here,  they're all the same. What happens if I define a   str method as well? Well, since there is a str  now, it will be called whenever we use the str   string, which is here, here, and here. So in this  case, we're going to return 'a bear'. And we can   observe the different behavior than what we had  before. Printing oski gives me the str string,   as well as explicitly asking for str using the  str built-in function, or looking up __str__,   this special method name. Now in order to get  even more variety, we need to introduce an init.   Which will set instance attributes. Let's have  an instance attribute called repr, which is a   function that takes no arguments, because here  we see we call it with no arguments. And it's   gonna return 'oski'. And self.__str__ will return  'this bear'. Executing my five print statements,   we see that printing oski and printing the str  string for oski are always the same. There's no   real way to make them different. The repr  string ignores this instance attribute,   just uses the method, which is a class  attribute, that's also a function,   and so we see bear is returned. Likewise, the  str string skips the instance attribute and goes   straight to the class. However, attribute look up  in the conventional way, gives us these functions,   which when we call them, return 'oski' and 'this  bear'. So we see there are four different things   that we can get based on how we print. As a final  step to prove our understanding, let's see if we   can write a repr function ourselves. So this is  going to replace the built-in repr function. And   what we'll do here is just return a type of x,  invoke the repr method on that and pass in x,   like I said before. And what about str(x)?  We certainly need to get the type of x,   because we're going to ignore instance attributes.  If it's the case that this type has an attribute   called str with underscores around it, then we  will use that t.__str__ and pass in the original   instance as its argument. Otherwise, we can just  return the result of calling repr on x. Here,   we'll run the same program. And it should behave  the same way if we've successfully implemented   repr and stir just as they behave in the built-in  methods. And here we see exactly the same output   because we've implemented the same logic that  repr and str apply. So now you know what they do.
We're using an important idea here. It's called an  interface. So when I talked about object-oriented   programming in the first place, I said that the  central to this metaphor was that objects would   pass messages to each other. And that's how they  would interact. Now the mechanics in the language   is that they just look up attributes or methods.  And that's how they communicate. So that's the   idea of passing messages. Passing messages is  the metaphor. Looking up attributes is what we   actually do, in order to pass messages around.  Now, the attribute look-up rules are designed in   a special way. They allow different data types  to respond to the same message just by having   the same attribute name. And a shared message,  an attribute name that exists on many different   classes and elicits the same behavior from  those different classes, is a powerful method of   abstraction. That's what we'll call an interface.  An interface is a set of shared messages and   some specification that tells you what they're  supposed to do, what they mean. So as an example,   classes that implement repr and str methods and  have those methods return Python interpretable   and human-readable strings respectively.  Interfaces don't have to be built into the   language although this one is. If you ever just  define that they are a bunch of classes that   all have the same method and all those methods do  similar things, then you've created an interface.  So let's see if we can build a  class that exhibits this interface.
We already saw that there was a  built-in fraction class. Let's build  something similar. I'll call it a  ratio so we can tell them apart.  The way you create a ratio is just to pass  in a numerator and a denominator. If we want   instances of the ratio class to be able to display  themselves, we need to define a repr method. It   will return a string. The string ratio followed  by parentheses. Here, we have two different gaps   within our string that we fill in using the format  method on strings, self.numer fills into the first   or zero index gap and self.denom on the second.  Now, if we want a human-readable string as well,   following the example of fraction, we just write  0 divided by 1 where again, 0 is the numerator   and one is the denominator. Now we can create  a ratio, half. Print out half and we'll get   the human-readable version. Just display half  directly and we'll get the Python expression.
