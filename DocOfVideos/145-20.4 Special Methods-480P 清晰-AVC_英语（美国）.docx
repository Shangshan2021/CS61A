Special method names are a topic particular to  the Python language. Certain names in Python are   special because they have built-in behavior of  some sort. And they always look the same, they   always start and end with two underscores. So when  you see a name with two underscores around it,   that's just an indication that it has some  particular behavior. It interacts with the   built-in object system in some way. For instance,  the first one we saw was __init__. This method   is special because it's invoked automatically  whenever an object is constructed. Other than   that, it's just a regular method. __repr__  was discussed in the previous videos. It's   the method that gets invoked in order to produce  a string that represents an object. And it's the   one that's used in an interactive Python session  to display the value. What about __add__? Well,   that's a new one. This is a two-argument method  that's invoked to add one object to another.   There's one argument method called __bool__, and  another called __float__. This one is invoked to   convert an object to true or false, telling you  its boolean value. And float tries to convert an   object to a real number. So for example, if  I set zero, one and two to 0, 1, 2 and then   I add one and two, I'll get 3. If I call bool,  which is a built-in function on zero, I'll get   false. And on one, I'll get true. And this bool  function gives you exactly the behavior that   you'll get if you place these objects in a boolean  context, such as a conditional statement. Now,   it's possible to rewrite this entire sequence of  statements. I could say zero, one and two, or 0,   1, and 2. And then add one and two together  using the special method name, or convert   zero and one to boolean values, using that special  method name. So there's a correspondence between   built-in pieces of syntax and built-in functions,  and the special method names that actually do the   work. It's another example of using an interface  in order to allow user-defined objects to interact   with the built-in systems within Python. So Python  is very extensible, you can create a new class and   be able to add instances of that class together  using the plus sign just by overriding the special   method name add. So what happens when you have  two instances of user-defined classes added   together? Well, what happens is that you invoke  either __add__, or there's another method called   __radd__, I'll tell you about that in a moment.  And that actually performs the addition. Again,   we're just asking the objects, how do you add  yourselves together? So if we want to extend   our ratio class so that we can add ratios, this  is certainly possible. I could add a third and a   sixth to get a half, either using the plus sign  or by using the method that actually performs   the addition. Both of these expressions are  equivalent in Python. People almost always   use this one because it's much easier to read.  The purpose of this is just to allow ourselves,   use the method definition syntax in order to  override what happens when you use a plus sign   between two objects. You can also use __radd__.  The difference between __radd__ and __add__ is   that this here is the argument on the right side  of the plus side. And this is the argument on   the left. For numbers, addition is commutative. So  it's irrelevant what order they come in. These two   functions are equivalent. But you could imagine  some cases in which you'd like to invent addition,   that's not commutative. And so it is possible  using __radd__. I'm not going to go through   every special name, and how it corresponds to  some built-in feature of Python, but that has   been done before you both in the Python docs and  in this online textbook called Dive into Python 3.  But let's see if we can add addition to our ratio  class. We define an __add__ method that takes   self and other. And what it does is just compute  the numerator and denominator of the result.  The numerator of two added ratios is the numerator  of the first times the denominator of the second   plus the denominator of the first times the  numerator of the second. The denominator   is the product of the denominators. If we  want to reduce this ratio to two relatively   prime integers, then we have to compute  the greatest common divisor of n and d.  Then we can return the ratio of n  divided by g, and d divided by g.  And what's the greatest common divisor? We did  talk about this earlier in the course. One way   to compute it is to say, well n does not equal d.  We rebind n and d to be in no particular order,   the min of an n and d, and the absolute value of  n minus d. Now we can take the gcd of 12 and 8,   and get 4. We can also add together the  ratios one-third and one-sixth. Now,   maybe we're not done. What happens if I add  together the ratio of one-third and 1? I   should get four-thirds. But I'm assuming that  the thing that I'm adding this to is, in fact,   another ratio, as opposed to an integer. One  thing I could do is inspect the type of other   in order to figure out what action to take. So  I could say, if it's the case that other is an   instance of the int class, then instead, I have  a numerator, that's the self.numerator times,   well the other denominator is just one, and then  I add in self.denom times the other, which is the   numerator of the other. Here, I'm just treating  other as a numerator of other and the denominator.  d is the denominator of self. Otherwise, if it's  the case that other is an instance of the ratio   class, then I use the formula that I had before.  I can still take the gcd. And I think I'm back   in business. I can add the ratios together, or I  can add one to the ratio. Now, can I add a ratio   third to one in this order? Not yet, because  I don't have right-side addition defined. But   I can just say that right-side addition is the  same as addition for this class. At which point,   I can add ratios, I can add integers to ratios in  either direction. And I fulfilled the interface   for adding addition to a user-defined class in  the Python language. Now what happens if we add a   floating point value 0.345? Well, then this result  will not be an integer. So it doesn't seem like we   should be building a ratio at all at that point.  There's another option. Instead, we can convert   our existing ratio into a floating point value as  well. By that, I mean, I just detect, if other is   an instance of float. And if so, I return not  a ratio at all, but instead, what I get when I   convert itself into a float and add it to other.  And what does it mean to convert itself into a   float? Well, I have to define that. I define that  using this special method name. Or in this case,   I'll just return what you get when you divide the  numerator by the denominator. So I've extended my   system yet further, or now I can add 0.2 to the  ratio one-third, I'll get some reasonable result.   I've actually used two important ideas here and  one example. This is called type dispatching,   where you inspect the type of an argument  to decide what to do. And here, this is   called type coercion, which is when you take an  object of one type convert it into another type,   in order to be able to combine it with some  other value. These are two strategies that   people use in order to have different classes  interact. You know __add__ is a two-argument   method. And now we have a version of __add__  that operates on two values of different types.
