61a lecture 20 q a all right let me ask john a question while we're waiting for everybody uh to chime in i've been coding for a lot of years john and i have to say except for like commercial things i don't think i've ever done object oriented like when i just code internally even when we build big things is that some a crappy programmer or is that is there some obstacle uh still like i never build a lot of classes and do all the things that i teach what's wrong well um object-oriented programming shines in this particular scenario when a bunch of stuff is changing yeah and a lot of code that gets written these days especially data processing code doesn't really have like mutation going on it doesn't have changing state over time or you're like tracking a lot of stuff this happens more often in like software that's got a user interaction cycle or something like that so yeah if you're doing much data processing workflows then it just doesn't show up as much yeah that's a good point that's that's an interesting way i hadn't thought about it that way but i like that oh in lecture i said stir is not a function but instead is a class so if we look at what stir is it says it's a class classes and functions are extremely similar in the sense that the way you do something with them is you call them and so when you call some function like abs it could really do anything when you call a class it's always going to create a new instance of that class so the stir though it looks like a function it's really a class and what you're doing here is you're calling the stir classes constructor in order to make a new stream and you can call this on pretty much anything and it will always make you a string so in that sense stir is a class it's probably a distinction that doesn't really matter that much um honestly yeah it doesn't matter at all but it's interesting to see that yeah our teams and classes are so similar i mean right there it's just classes or functions that always create a particular instance of this class the next question was about a mistake in the polymorphic functions video from today's lecture where i redefined stir and wrapper below the places where i was calling them and so those definitions had no effect yeah good question if you print first and then you redefine stir and wrapper then the print won't know about the read definition which i think is just a mistake in the video but uh i checked it and if you rearrange the code it still does the same thing so uh it's it's uh the code wasn't doing quite what i said but it would have done what i said had i written it right does that make any sense so uh yeah so anyway you're right that if you print before you make changes then those changes obviously won't be reflected okay so this question is about how addition works when there's an instance of a user-defined class involved and the answer is it's kind of complicated so when python sees x plus y it uh checks to see if x is a user defined has a user defined class and if so if it has an add method if that's not true then it checks y and sees where whether y is a user defined class that has an r add method what's our ad well this is the method that gets called when an instance of this class is on the right of the plus and if neither are those are true then it tries to use the built-in edition that it has which basically only works for the built-in classes like ant and float and stir and um you know if that doesn't apply then you'll see an error which says i don't know how to add an int and a widget or whatever uh you have there so this multi-step process is not terribly important except for um it indicates just how complicated it is to to set up a language so that you can arbitrarily extend what plus does and it's complicated because there's these two different arguments to the addition and um you know you might want to be the case that your user-defined thing shows up on either side but then sometimes the order matters it's not always the case that every addition operation is commutative like for strings a plus b is different oh come on a plus b is different than b plus a and you might want that kind of behavior in your own version but then you need to know whether the object you created is on the left or the right of plus the next question was for the kangaroo class is it okay to use in to check the contents of the pouch instead of using a for statement um no i think using the in is fine um i the reason i use the for loop in the while loop is i like to exercise that for students to make sure that they understand it but the in operator is a perfectly fine thing it's essentially um this is one of those cases where python has given you a construct that does something that you could have done manually but you could have absolutely used the end and done it in one line instead of two or three lines yeah great question so the question is is instance the same as just finding the type of something and figuring out whether that's equal to a class and they're oh so close but because of inheritance they are actually different so let me show you an example if you have a class a um that is the base and you have a class b which inherits from a and is the subclass if i build a b and ask is this an instance of the b class well the answer is yes but it's also an instance of the a class whereas the type of b is the b class but it's not the a class so what is instance does is ask is b an instance of this class or any of its subclasses that's a tricky little thing isn't it yeah but it can be useful because basically you're you're future proofing your code by saying is it an instance of a kangaroo if somebody comes up with this special subclass of like a short kangaroo your code's still going to run correctly yeah good question so what's the difference between this built-in wrapper function and this thing well um you'll see them in different places so wrapper can show up anywhere it's a built-in function that's in the global frame you can call it on anything and what it will do is really really simple it will ask its argument what is your wrapper method and we'll just call that so i can get a wrapper of you know basically any kind of object i create but when is happening there is that there isn't a whole bunch of code within repper that says here's all the different kinds of objects in the world and here's what they do instead all rapper does is take its argument and invoke the method that means this can be defined in the class of whatever this thing is this happens to be a list and uh it has a wrapper method built into it you can ignore what a slot wrapper is that's kind of some random detail of python that we don't care about but this is just like some function that uh that knows how to turn lists into strings and you know what does it do it adds square brackets and commas and spaces in the right place and stuff like that so the difference is that these are built to be related to each other these appear in class definitions so you will have often a wrapper method which takes in the object that you're trying to make a string of and returns a string something like that and this is a function that's built in that always knows when it gets an object and it doesn't know how to print it out it just invokes this wrapper method this underscore underscore wrapper method in order to do the work but if you had called this something else it wouldn't work so the relationship is between the repper without underscores being a built-in function and the wrapper which is a special method name with the underscores that does the work so uh if we make an a now it will look like a instead of some kind of like funky thing with angled brackets the next question was whether every class defines ripper yeah great question so the underscore underscore wrapper method is something that the user has to define in each class if it's not defined there's some default behavior and you've seen it many times it's this uh thing where uh it shows you some angled brackets and it tells you what the class is and it says the word object so like this is built in but it's not very useful it's just like a placeholder and so it's almost always the case that when you create a class you want to add a rapper method that shows uh more interesting information about a yeah good question so how would you take a tree and print all the paths um so let's say we want to print a first we have to decide what a path looks like so a typical thing would be it's the list of labels along a path a path is really like a list of nodes each one is a tree but um you know the interesting part of a path is that it's got a bunch of labels in it that are numbers or whatever yeah so if we take in a tea tree and we want to print all the paths from the root to a leaf some zoom display stuff i don't know how to do this yet but i know it's going to be recursive steve you know the most straightforward way to do this is in two steps you get all the paths and then you print each one out so let's try it that way what would this actually look like if you had a tree uh what have i done made a mess is what i've done i hate this notation john okay i shouldn't get that off my chest that's all [Laughter] okay so we get one two three and we get one four let's see um that seems like a good way to go no what is all paths a path comes by finding a path from uh the root of a branch all the way to a leaf and then putting the current label at the front that's like a recursive way to think about a path is that a path has the first thing and then it's got the rest of the elements in the path and the rest of the elements in the path are a path in a smaller tree a tree that starts at a branch so one way to do this is to say that for every branch you want to get all the paths in that branch like here's a branch and a path through that branch would be 2 3 but we want 1 2 3.
so if we go through all the paths in the paths in the branch then what we want to return here is not just 2 3 like path path might be 2 3 we want to return 1 to 3 but there might be multiple of them so i'm going to write it as a generator function we can change it later if you want but what we uh yield here is one two three which would have to have the label of t first and then uh the rest so this is yielding one two three which is what we want i don't know if you heard that but john had this beautiful recursive definition in there he said what is a path it's one if we start at the tree that he's just described up top with the path of everything below everything right so there it is i mean that that one statement is what what wrote your function for you so now we have to think about what happens when you hit a leaf here there are no branches in a leaf so this would do nothing but that's not quite right when you get to a leaf there is a path which is just a one length path so if uh t is a leaf then i think we want to yield a list of length one okay and now that some uh gardeners have showed up it's gonna be very hard for me to talk but i'll try anyway okay so that seems to pass the test i think that's a good way to print all the paths and actually this is exactly the same structure that we had in a question that we had to skip at the end of the last time why is there sometimes two for loops the reason there's two for loops is that in each particular branch there could be multiple paths so let's like extend this example just a little bit now what should happen is that we should get one two three one two five and one four um when we pass in t is one two three and we go to the first branch which is this guy this actually has two paths through it two three or two five 5. for the branch which looks like this there isn't just one path through that branch there's two and that's why we have a second nested iteration it's that for each individual branch there might be two different paths and for each one of those we want to yield a new path so this is a question about fall 2015 midterm two question three a and just understanding the question it is a good idea to read what's there but then take a look at the examples the doc tests to make sure that you've really understood what it does and if like it's doing something that you don't expect well then um then you gotta address the wording of the question try to figure out what's going on and uh you know in an exam if you really can't understand what a question means um then you know feel free to ask a question because there's no point in working to solve a problem if you can't figure out what it's asking okay so implement complete which takes a tree instance t i'll tell you in advance that on friday we'll talk about tree with a capital t which is that we'll build a tree class which is just like the tree data abstraction except it's a class um so you might see some notation in here that's a little bit different i think all that's really different is that you write t dot branches instead of branches of t um and same with the label so maybe we could just ignore that for a little while but i just wanted to let people know that this is something we will cover but haven't covered yet okay so which takes a tree instance t and two positive integers d and k and returns whether t is dk complete which is some term that's made up for this question a tree is dk complete if every node at a depth less than d has exactly k branches and every node at depth d is a leaf the depth of a node is the number of steps from the root the root node has depth zero built in all function blah blah it's not really relevant the the thing to think about with this is like what what the heck does this say and um looking at examples and thinking about examples is really important to figuring out what this means so let's see what the example says so a tree that has a node at depth 0 but no other nodes is apparently d k complete for d equal to zero because the depth is zero and k equal to five and it seems like this five is just kind of irrelevant what's going on here is that every node at depth less than d has exactly five branches but there are no nodes less than zero depth zero is the smallest depth so all that matters here is is it the case that every node at depth d which is zero is a leaf and that is true so this has only one node its depth is zero and it is a leaf and therefore this happens to meet the definition kind of by accident it doesn't have any nodes at less than zero so this five becomes irrelevant but that's why this came out as true okay um let's look at a more interesting tree so here's a tree that's got three branches and each one is a leaf is it the case that this tree is one three complete yes because for all the nodes at depth less than 1 which is just 0 it has 3 branches and u itself the root is the only node that has depth zero and it does in fact have three branches and then all the nodes at depth one are leaves and that is true tree tree tree um is it the case that this is depth one two complete no because the root has three branches not two is it depth two three complete no because the nodes at depth one which is less than two like this one don't have three branches it's just leaf it doesn't have three branches it has zero branches so that's why this is false and this is false and what about this tree well this is a funny tree this is a tree where one is at the root and then it has three branches which each look like you so if we were to write this out it would be pretty long to write out it would be a tree with one at the top and then one in the middle three times and then each one of these middle nodes would have three leaves under it that are all ones so there would be nine different leaves and that is a two three complete tree which means that all the leaves are at depth two and everything in between has three branches how might you approach this kind of problem the um the base case here is that you've hit a leaf whether a leaf is dk complete really depends on what d is so leaves are okay if d is zero we saw that in this first example but they're not okay otherwise we saw that in this example if there's a leaf at depth one and this is supposed to be depth two has all the leaves then you've run into a problem so you can't just return true here you have to return whether uh t is equal to zero that's that means it's okay to have leaps and this is actually like a poorly thing because it says two positive integers d and k but here we see a non-positive d so uh i think whoever wrote this wrote it wrong maybe it was me this is a non-negative d and positive k yeah i think that the instructions are are not quite right we're rewriting the problem as we go some of them feel free to do this on the exam just rewrite the problems if you don't like them i'm kidding don't do that sorry about that john okay i think that's a better description of the problem because obviously d appears to be something that isn't necessarily positive um so this is saying if it's the case that we've reached the depth where leaves are allowed and we hit a leaf then we should return true otherwise we should return false um there's a clue here about what to do with this line b's which is that the result says all b's and all is a built-in function that only returns true if all the elements of b's are true so this needs to be a list of trues and falses right and what gives you trues and falses is recursive calls to complete so we need to be calling complete on something and um as for as usual i think it's natural to do this for every b in t dot branches t dot branches is just the object-oriented way of saying branches t and what recursive call will we make well for this to be dk complete it has to be that for all the branches they are d minus 1 k complete um so now we get a list of true and false values where they all need to be true in order to get a true result but something else needs to be true in order to get a true result which is that it has to be the case that the number of branches of at t is equal to this number k which is the branching factor that's supposed to happen so this is like a very strict structural description of what a tree looks like is that it's got like the same number of branches until you hit the leaves and all the leaves are at the same depth and here's how you would check for it so the question is why is it the case that you can have a different behavior typing oski wrapper than you can calling rapper on oski and in general this is like not important but i figured if i'm explaining something in python i might as well explain it correctly and there's this weird case in which this can be true but only if you use the object system in a way that is not really designed which is that you put a function as an instance attribute then these can be different so if you have a class bear that has nothing in it and you make yourself a bear and then what you do is you build a function that does something like return go bears and you set that as an instance attribute of the ascii instance not part of the class but just part of oski himself then you'll get this weird behavior uh where they printed this but you would never do this it's just like you know it's some weird esoteric fact about python that you know it's fine if you uh would never use this but it does show the behavior which is that what repper does is it looks in the class it doesn't look an instance which is like very strange almost everything else in python would first look in the instance and then the class but this one doesn't otherwise one thing python could have done to avoid this weirdness it says you can't define functions with double underscores before and after the name right that's what's basically happening here you're making something look like it's a member function using that default nomenclature but there's no protection of that so sometimes when you make something as flexible as python then uh then instructors find weird ways to abuse it and that's i guess what i've done here but uh yeah so so anyway what you're supposed to learn is how wrapper methods like how you define wrapper methods within a class uh it happens to be that you can't put them on the instance or they won't work good question so why aren't we seeing uh the stir function instead of the wrapper function um the default stir is to just do whatever repper would do that's just a fact about python is that like if there's no stir method then printing something we'll call the stirrer but the default stir is just to call repper and figure out what that would do and so for classes that don't have a separate stir and wrapper method they do the same thing because stir just does whatever rapper does so if you kind of want to get them both you could define a wrapper method and then you've kind of implicitly defined a stir method because stir just does whatever record does um so for this reason um if you create something that's got no stirs or wrappers anywhere we get rid of all this stuff and we just print the wrapper of oski we're gonna get the same thing as if we print oski which is uh that by default the stir and the wrapper string are the same it's only if you make them different that they would be different uh so the question is about the order of ad and our ads special methods and what they do um it's just like a very particular thing but if you want to build a new kind of number then you have to deal with many cases in particular you have to deal with the case where this new kind of number shows up on the left and where this new kind of number shows up on the right because it might be the case that something different happens in whether it's on the left to the right uh if python hadn't made plus so flexible then maybe the order wouldn't matter at all but it's so flexible can be used with strings it can be used with lists where sometimes order does matter and so for this reason um there's two different special methods one that gets called when x is on the left and a separate one that gets called when x is on the right and they're called add and r add respectively yeah so um well maybe we'll just do an example and and uh that might fix things so let's assume other is an end you know how do you add i think you'd have to return a new rational that's got your old numerator in there plus it's got other times d in there and your old denominator and how would you r add well okay so so this is like the x plus three case where other is 3.
and how would you r add okay so now we have a different case this is the 3 plus x case where other is 3. so what do we return there we return a rational where the numerator is n plus other times d and then the same denominator and then it will work in either case i think in order to see what's going on we at least need a wrapper method which would return uh rational of and and d oh i went off the line it's okay and now if i have my thing x which is like uh one half and i write x plus three i get oh self rookie mistake seriously the number of times i do that john then we get seven halves and if we write three plus x we get seven halves but we wrote the same code here and here so um one option instead of writing this out would be to just write that r add equals add we had already written it why write it again and then we don't need this anymore and we get the same behavior that was what was going on 