Linked lists are a fundamental data structure in  computer science. They appear everywhere. And now   we'll learn how to implement them using Python's  object system. So a linked list is either empty   because it contains nothing, or it has the first  value in some sequence, and then the rest of the   values in the linked list. So here's how we're  going to represent the sequence 3, 4, 5. We'll use   an instance of a class called the link. I haven't  defined that yet, but I will soon. And that has   two attributes. First, which is 3, and rest, which  is some object. Now that object is holding the   rest of the values. And it itself is also a linked  list or a link instance. So every linked list has   a smaller linked list as the rest of the list.  So this link instance has its first value as 4.   And the rest of its list is a link instance,  whose first value is 5. Now we've exhausted   everything we're trying to represent but we still  need some rest attribute. In that case, we use a   special value called Link.empty. Link.empty is the  exception to the rule, I just said that every link   list has a rest of the list. Link.empty doesn't  have any first value or any rest of the list. It   just represents the fact that there's nothing  left. So the right way to think about a linked   list is not this particular class with these  particular attribute names, but as a pair of   values. It's the first element of some sequence,  and then the rest of that sequence. In this case,   we're storing the first, actually the zeroth  element, as an attribute value. I call it the   zeroth element because it will correspond to index  zero, once we come up with a way of indexing into   this list. The rest of the list is itself a linked  list or Link.empty and that's stored as another   attribute. So you can have objects that are values  of attributes. And here, we're using the idea of   composition in order to construct an interesting  structure. So a linked list has a linked list as   its attribute value. Finally, there's some  class attribute that we use for any linked   list that's empty, and we call it Link.empty. Now  the way we construct this is not by writing 3, 4,   5. That would make a tuple. Instead, we have to  write out the constructor, a link with 3, and the   rest of the list is a link with 4. And the rest  of that list is a link starting with 5. And the   rest of that list is Link.empty. So each one of  these calls to link creates a new link instance.   This call creates that instance, which must exist  in order to make this call, which creates the link   list starting with 4 followed by 5. Now here, the  order in which functions are evaluated in Python   is important. In order to evaluate Link 4, Link  5, Link. empty, we have to first evaluate this   operand sub-expression in order to create the link  instance that represents the sequence starting at   5, followed by nothing else. Once that's created,  we can pass it in as an argument to this link,   which starts with 4 and is followed by all this  other stuff. And then finally, we can evaluate the   whole expression and build the whole linked list.  Now, these structures are so common in computer   science, that there are some conventions about  how they get drawn. Typically, you do draw them   as a sequence of pairs with arrows like this.  But instead of drawing an arrow to Link.empty,   it's very common to just put a slash there. This  is not any sort of official notation. But you will   see people do this out there in the world. So I  thought I'd show you now. In our implementation,   we're going to mirror this structure by  making Link.empty the default value for   the rest attribute. And that means you can leave  it out when you want to construct a linked list.   So we want this expression to actually evaluate  to a link instance representing the sequence 3,   4, 5. And for that, we need a class statement. In  the linked list class, we just have an __init__   method, which takes in the first and the rest.  So here's the class. Here's the __init__ method.   As I mentioned before, we're going to have a  default value for the rest, which is Link.empty,   which I haven't yet defined. The first thing  we'll do is make sure that the linked list   we're constructing is well-formed. It follows the  property that I said that the rest of the list   either has to be the empty list, Link.empty. Or  it's an instance of the link class, meaning it's   itself a linked list. So those are the only two  things we're allowed to pass in as the rest of   the list. And then we store the first element. And  the rest of the linked list as attributes of the   instance self. Isinstance is a built-in function  in Python that returns whether rest is a link when   passed to these two arguments. If you ask for the  help from Python on isinstance, it will tell you   that it returns whether an object is an instance  of a class or of a subclass thereof. So it's a   little bit different than just getting the type  of rest and seeing if it's exactly equal to link.   This will also be true if rest is an instance of  a class that inherits from link. And this is a   good idea because now our system is extensible.  If we want to build a special kind of linked   list by inheriting from link, we can still use  this same constructor. And this verification   will still work out as we expect. So what is  Link.empty anyway? Well, here we have a choice   in our implementation. I've chosen to represent it  as the empty tuple. Although I could have invented   a special class just for the empty linked list,  instead, I just picked some zero length sequence,   because that's what it is, it's a zero length  sequence. Okay, let's see how it works. I can   create a linked list with 3 followed by 4,  followed by 5. If I call this s, I can start   inspecting its attributes. s.first is 3, s.rest is  4, 5, which means if I want to get the element 4,   what I need to write is s.rest.first, the first  element of the rest of the list. I can access 5   by saying the rest of the lists, rests of the  lists, first element, that's 5. And finally,   I can ask whether the rest of the rest of the  rest of the list is Link.empty. And it should be,   because there's nothing there. So these are the  ways in which I'll manipulate a linked list. It   is of course possible to change the values within  the list. I could set s. rest.first to 7. Then,   if I look at what s is, I find that it's  3 followed by 7 followed by 5. However,   oftentimes, linked lists are used in situations  where you're not mutating the values, that's   where they're specially designed for. So you can  create a list that's similar to another list just   by adding a different value onto the front. So if  I want to create a linked list that starts with 8,   and then is followed by 7 and 5, I would  do that just by writing Link 8 followed by   the rest of the list. Writing this creates a  new list, but it doesn't change the old one.
