Recursion is very common in linked list  processing. When constructing a new linked list,   or taking an existing linked list and doing  something with it. Let's look at some examples.   Ranges are built-in, the map function is built-in,  and the filter function is built into Python. But   they don't operate on linked lists, because  those are user-defined. So if we want the same   functionality, we'll have to implement our own  notion of range and map and filter. Let's remember   what these things do. If I have two functions,  like square, which takes an x and squares it,   and odd, which takes an x and returns whether  it's an odd number, then I could, for example,   write the following expression, using  the built-in map and filter and range.   Get the numbers 1, 2, 3, 4, and 5. Filter for only  the odd ones. So now I have 1, 3, and 5. And then   map the square function over those. So 1 squared  is 1, 3 squared is 9, and 5 squared is 25.   Those results will place in a list. The same  kind of thing could be done with linked lists   using the class that we just defined. But  the syntax will be slightly different.   We'll have to come up with a map link function,  which we'll implement momentarily, which takes the   square and squares all the elements of the result  of filtering a linked list using the odd function,   where we start with a linked list representing the  range 1, 2, 3, 4, 5. Filter out the 2 and the 4 to   just have 1, 3, and 5, the odd ones. Square all of  those, then you get a linked list of 1, 9, and 25.   So let's go through and implement range_link,  which has a starting integer and an ending   integer and returns a link containing consecutive  integers from start, including the start to end,   not including the end. So the range link from 3  to 6 would be 3, 4, and 5. And we'll also write   map_link, which returns a new linked list that  contains f of x where every x in the original   linked list s. So if we square everything in the  range 3 to 6, then we get 3 squared, 4 squared,   and 5 squared. And we'll also write filter_link,  which returns a linked list that contains only the   elements of Link s, for which f call on that  element returns a true value. So if we filter   for only the odd elements of this range that we  get 3, and 5, leaving out the four. Actually,   all of these are going to be recursive functions.  So here's our link class. Here's square and odd.   And how do we build a range? Well, if it's the  case that start is greater than or equal to end,   then there's nothing in the range. We return  Link.empty to represent an empty linked list.   Otherwise, there's at least one element in  the range, and that is the start element,   followed by some other stuff. Return a link  with start as the first element. And what's   the rest of the range? Well, that is the range  that starts at start + 1 and goes to the end.   How do we take a function and map  it over all the elements in s,   calling f on every single element and building  a linked list of the result? If it's the case   that s is Link.empty, there's really no work  to do. We could return s or return Link.empty,   since those are just two expressions for the same  thing, it doesn't matter which one you write.   Otherwise, you know there's at least one element,  so let's call f on it. And we'll return a new   linked list with its first element being the  result of calling f on the first element of s.   And then we need to call f on the rest of the  elements. We do that with a recursive call to   map link, where we're calling the same function f  on everything in s.rest. And what about filtering?   Well, if s is Link.empty, again, there's  no elements to filter, so we'll return s.   Otherwise, I do think that we need to  filter everything in the rest of s.   So let's get the filtered rest, which is the  result of calling filter link using that same   f on the rest of s. But now we have to make  a decision. Is it the case that s.first is in   the result or not? Well, that depends on  what you get when you call f on s.first.   If that's a true value, then we need s.first to be  in the result. And what's everything else? Well,   that's the result of filtering the rest of the  list. Otherwise, if this is a false value, then   s.first is not supposed to be in the result, so  we can just return the filtered rest. Let's check   to see if our doc tests all work. Oh, they do. So  it should be the case that if I start with a range   from 1 to 6, so that's 1, 2, 3, 4, and 5, I filter  it using odd. I map the square function over the   result, then what I get is 1, 9, 16. And there it  is. So since link lists ever recursive structure,   