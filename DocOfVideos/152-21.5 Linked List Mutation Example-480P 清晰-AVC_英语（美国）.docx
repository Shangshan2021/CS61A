Here's an example of linked list mutation.  Let's say we have an ordered list with no   repeated elements. And we want to maintain the  fact that s is an ordered list with no repeated   elements. But write a function add, that places  elements into the list in the appropriate position   so that everything stays ordered from least to  greatest. So here's the function, add to a list s,   a value v, which modifies s to make sure that  it contains v, and then returns that modified   s. However, if v is already in s, then we don't  modify s so that we don't have repeats in the   list. But we still want to return s from the  add function. Now's a good time to pause the   video and try to write this function. I'm  going to describe how it works in 3, 2, 1.  When you add 0 to s, we'll make sure that 0  is the element at the beginning. And that 1   comes after that. Instead of rewriting all of  the values in the list, we can do this just by   creating a new link instance, whose first element  is 1, changing s so that its first element is 0,   and rerouting so that the rest of s is the  link instance, whose rest is 3, then 5. Now,   we have a linked list representing the sequence  0, 1, 3, 5, instead of just 1, 3, 5. If we add 3,   we should look through s until we find the place  that 3 goes. And since we discover the 3 is   already there, we're not going to modify s at all.  We'll just return it. And what if we add 4? Well,   we look along here until we figure out where  4 would go. Between 3 and 5. So that means   we can change the 5 to a 4, and a new link  instance for the 5. And now we have 0, 1, 3,   4, 5. And what if we add 6? Well, that's actually  a little bit different. We keep looking until we   find that we've reached the end. So instead of  rest being Link.empty, rest needs to buy a new   link instance containing the 6. That's how we  add v into s. Try to implement it. Add v into s,   returning modified s. Don't change s if v is  already there, and make sure that s remains   ordered. We assume that s is ordered at the  beginning and we have to place v into s so that   the order remains from least to greatest. Here  are some examples. If s is 1, 3, 5, and we add 0,   then it's 0, 1, 3, 5. We add 3 and it doesn't  change. We add 4 and the 4 will shows up in   the right place. And we had 6 that ends up at the  end. And let's assume that s is not empty to begin   with. How can we do it? Well, we'll assert s is  not empty. And then if s.first is greater than v,   we mutate s by changing s.first and s.rest.  If s.first is less than v and s.rest is empty,   then we have to place a value at the end. If  s.rest is less than v, we got to do something,   and in the end, we return s. Why  don't you pause and try to fill in   the blanks. And we'll talk about it in 3, 2, 1.
If s.first is greater than v, then we place v   as s.first and change s.rest to contain the old  s.first and the old s.rest. That's building this   link instance, or building this link instance. If  s.first is less than v and the rest is empty, then   we need to build this link instance by setting  s.rest to a link where v is the first element   and the rest is empty, which is the default second  argument for link. Otherwise, we keep looking for   the place where we're going to put v, which is  just a recursive call to add. We don't need to   return because we're going to return down here.  We're always going to return s. The point of   this call is not to compute a value to return, but  instead to perform the addition on the rest of s.
