Another recursive computational data structure  is the tree. And we've already talked about   trees in this class. But they're so important  that we should talk about them again. A tree   is a lot like a linked list. A tree has a root  label and a list of branches that are trees. A   linked list is a first element in the rest of the  list. So the main difference is that a tree has   multiple trees as branches, whereas a linked  list has only one linked list as the rest of   the list. Here's vocabulary that we've talked  about before, but we'll do it again. There are   two ways of describing trees. The recursive  description uses an analogy to wooden trees   growing out of the ground, except for that they  grow down instead of up. A tree has a root label   and a list of branches. Here, the root label  is 3. There's a branch and there's one other   branch. Each branch is a tree. A tree with zero  branches is called a leaf. In this diagram,   there are five leaves. The leaves have labels as  well, they just have no branches. A tree starts   at the root. There's the root of the whole tree.  There's the root of the left branch. There can be   multiple branches, or one or zero. And every  single branch is another tree, meaning every   single branch has another route. Describing all of  the different trees within a tree often involves   the term node. A node is a position or location  within a tree. It's always another tree itself,   but when using the term node, it's not so  interesting to think about the subtrees,   but instead just their relative locations  to other nodes. Each node has a label,   and each node also has a configuration relative  to other nodes. 3 is the parent of 2, 2 is the   child of 3. The top node is the root node. And  like I did just there, people often use labels   to refer to locations. Instead of saying the  node with a label 2 is the child of node with   label 3. It's often the case that people will just  casually say, 2 is the child of 3. But in fact,   it's the nodes that have this family relationship,  and their labels are just numbers. A path is a   sequence of nodes, where each element is either  the parent or the child of the previous node. So   they're connected in the tree diagram. And the  most common paths are paths from the root to a   leaf, but you could have other kinds of paths as  well. We were able to work with trees using data   abstraction. But we can also use Pythons object  system. A Tree has a label and a list of branches;   each branch is also a tree. We can state this  by defining a tree class with a constructor   that takes a label and a list of branches,  which by default is empty. We set the label,   we check that for every branch, the branch is  a Tree. And then we assign self.branches. Here   we make a list of the branches in order to  retain a copy. And also to convert branches   to a list if it was something else. Here was the  definition using data abstraction. Very similar,   but there are some important differences.  Now that we're using the object system,   we define how to build a tree. But we don't have  to explicitly define how to get to the different   attributes out of a constructed tree. In data  abstraction, we wrote down the constructor and the   selectors. Here, we write down the constructor and  the selectors are implicit. self.label will give   the label and .branches will give the branches.  More importantly, when using data abstraction,   we had to invent a way of combining together the  pieces, the label, and the branches. In this case,   we decided to put them all in one long list. But  we could have done something else. Put them in a   pair, put them in a dictionary. Whatever we did,  we had to come up with a method for extracting   those pieces back out using the selector  functions. When we use Python's object system,   we don't have to make any decisions about how the  pieces are combined into a whole, we always choose   the same way. Each part is an attribute and an  object has all of its attributes accessed by their   name. So the definition is a little bit simpler  using the object system. But using tree instances   is just like using the tree data abstraction.  Here's a definition of a function that creates   a Fibonacci tree, and it's the same with slight  differences. When I use the object system,   I capitalize the word Tree, and I access the  label using .notation. Under data abstraction,   I had a function called tree, and I accessed the  label using a selector function, but our code   doesn't change at all. So the coding style used  in object-oriented programming is not terribly   different from the coding style used with data  abstraction. Once I've defined the tree class, I   can go ahead and use it. So a leaf, I can create,  just by calling tree. If I want to add branches   to that tree, I cannot do it just by passing in  label values, I have to pass in a list of trees.   This creates a tree which I'll call t. It's repr  string is an expression that builds an equivalent   tree. Printing it out gives a multi-line output  where the root label comes first and all of the   other labels are indented. It's not a bad idea to  take a look at the code that generates the repr   string and the str string to understand how it  works. And we've added one more method, is_leaf,   which returns whether there are no branches.  And we've also defined the fib_tree function,   just like it was on the slides. fib_tree(4) is  a fairly large tree. fib_tree(5) has Fibonacci   number 5 at the root. And fib_tree(6) is looking  quite large indeed. Look at all those parentheses   and square brackets. But if I print this out, then  it's easier to see the structure. 8 at the root,   two different branches, one has the root label 3,  the other has the root label 5, and 3 plus 5 is 8.   So what are the leaves of this tree? We have 0, 1,  1, 0, 1, 1, 0, 1, etc. Let's write down a function   that computes the leaves of a tree as a list.  If t is a leaf, that will return a list with one   element, the label of the tree. Otherwise, we need  to build up a list of all the leaves. Let's start   with an empty list. And for every b in t.branches,  we'll make a recursive call to leaves on b. And   what do we do with that? Well, we're going to add  all of its elements to all_leaves, which is one of   the built-in methods on a list. Which one? Well,  we want to extend the list of all_leaves with the   new list of leaves that we get by recursively  calling leaves on the branch b. Then we can   return all of these leaves. And if we call leaves  on fib_tree(6), we get a list of leaves that sum   to 8, which is Fibonacci number 6. And what's the  height of this tree? Well, the height of a leaf   is zero. And the height of a tree in general  is the number of transitions and its longest   path. We go from here to one transition, two  transitions, three transitions, four transitions,   five, I think the height of fib_tree(6) is  5. How could we compute that? If t is a leaf,   then the height is 0. Otherwise, the height is  one more than the maximum height of any branch.   So let's compute height(b) for b in t.branches  and take the maximum value. There's fib_tree(6),   and what's its height? 5. So everything  we've learned about processing trees is the   same whether I use data abstraction, or I use the  tree class. But we get some nice advantages using   the tree class, like a nice way of displaying  trees using this simple recursive str function.
