Here's a tree processing example where we  actually change the tree instance. Removing   some of the subtrees of a tree is called pruning.  Either you remove some of the branches, or remove   some branches of the branches, etc. When possible,  it makes sense to first prune the branches of the   current tree, then recursively prune whichever  branches are left over. You can prune a branch   before you remove that branch. But since you're  removing the whole branch, why not remove it   first, and only prune what's left. So here's an  example tree. And let's say we want to prune all   of the subtrees whose root label is 1. The 0  goes because it's part of this subtree. Here's   a template. Pause for a moment and try to fill  it in. And I'll go over the solution in 3, 2, 1.  The key here is to modify t.branches by  setting it equal to a new list. We could   also change the old t.branches list, but we  achieve the same effect by building a new   list with a list comprehension. For every branch  in the tree, I'm going to keep it in t.branches,   if it's labeled as something other than n. Now,  t.branches might not have all the old branches in   it, so this says, iterate through the branches  that remain, calling each one b and prune that   branch using n as the label we're looking to  prune. And that's it. We don't need to return   because the purpose of the prune function is  to remove subtrees, not to compute a new value.
