61a lecture number 21 q a hey john while we wait for the first question let me ask you something so i've always taught linked lists i think they're really great um dude in in at google did you see people really using them or was it just you know we just use a list that's sort of easier i think that there are many more applications where you use a list than a linked list yeah yeah that was my sense because it's there's clearly a benefit but it's not clear that it's outweighed by the you know the hassle of having to implement everything yeah and i think um when there's a lot of mutation that's when it can matter because you can kind of stick something in the middle of a linked list yeah um and uh so you know definitely if we didn't have them then like something at google wouldn't work like it's supposed to work you know it's a necessary component but it doesn't show up all that often yeah it doesn't doesn't remind me if i'm wrong python does this cool thing when you allocate memory for a list where it actually gives you more memory than you need so that as you're expanding it it's not having to sort of move things around in memory did i get that right yeah i think that's right they round up to the next power two or something like that right it's always powers so actually it's a little bit better than constantly having to move things around when you're inserting in the list but even when you insert like you don't have to allocate new memory but you do have to copy everything over to make room so still linked lists are kind of nice oh that's yeah that's true by the way back in the day when we programmed in c you had to you had to every time you wanted to create a data structure you had to you had to actually go in and allocate the memory for it and then you allocate the memory for it so that memory management is was brutal yeah that's how i started in my first computer science class and uh also when you did it wrong it didn't really tell you where you were and it was it was deterministic because sometimes you would run in the code would be fine and then sometimes you run the questions i recently had to implement uh an algorithm and speak that it had to run really really fast in those four dimensional matrices and it took me like a week just to get the memory management right just don't write memory management yeah no my initial reaction having to deal with memory management was like why does ever anyone take computer science courses is awful so you know i think learning computer science is still frustrating but in different ways now we sound like old guys but back in my day i had to allocate memory exactly all right guys whenever you're ready sorry by the way did anybody else notice that a list is just a a tree with one branch i suppose we could have just done we could have implemented using trees yeah john you could have made a linked list just a tree where you're only allowed to have one branch yeah okay uh there was a problem on homework four that was yield all the permutations of some list s so for example if you called permutations on uh one two three well then you just get back a generator but if you then listed out all the contents then you'd get one two three and one three two and uh okay so those are the ones that start with one but then there's something to start with two like two one three and let me shuffle around my zoom a little bit uh two three one okay so those are the ones that start with two oh there's actually some that start with three you got three one two and three two one i think that's how i didn't do four elements i know [Laughter] so i know a lot of people did this question already but let's just talk through it really quickly i think um there's uh a couple different ways you can do this and i don't think there's one that's better than the other um but one of them is that you pick which element you want first in your permutation so that you could either have one first or two first three first and then you have the rest of the elements filling out your permutation but you don't know what order they come in they might come in two three or three two well actually that turns out to be the two different permutations of the numbers two three and likewise once you've committed to two being your first number you've got two different options for everything else and these are the two different permutations of one three or if you say threes first then these are the two different permutations of one two so you can see that coming up with all the permutations of one two three involves coming up with the permutations of two three and the permutations of one three and the permutations of one two so there's gonna be a recursive structure here and now that we have like a recursive story then we just put it into code so um if you want all the different permutations then you have to consider all the different elements that you could start with so the starting element let's say is s i now we need the rest of the elements these are all the elements except for the one that we chose so if we chose two we need to get one and three there's a number of ways to do this one way is to say i want sj for every j in here if uh j isn't i that's one way to do it another way to do it with slicing might be i want to go up to i but don't include it and i also want everything after i so i plus 1 on either way would be fine but basically however you do it what rest is going to be is uh if we got 2 here this is going to be the list of 1 3. so everything else that we need to permute and then if we want to generate these two permutations then we have to permute the rest of them so try one three and also try three one so if we get the permutations of the rest of the list now our rest permutation is first gonna be bound to one three and then it will be bound to three one but that's not what we're supposed to yield so if we yielded rest permutation we would be yielding something too short we'd be yielding something like 1 3 or 3 1. but really what we want to yield is 2 1 3 or 2 3 1 so we have to decide how to do that i think the easiest way is to use list addition where you put that to the starting value in at the beginning of the list by the way notice that when the problem statement was defined there was the recursive definition i could hear it right take the one off and then find the other the permutations of the other ones and that's one of the tricks of recursion is as you're thinking about the problem there's always like slight simplification of the problem and also it's in the definition right take one and then add it to all the other permutations of the remaining elements well there it is and then when you do all that work you got to think about a base case so it's a good base case well and you could do it with list length 1 or list length 0. i think list length 0 is probably the most basic of the base cases so if you say if len s equals 0 then what's all the permutations of that oh we're yielding there's really only one permutation of an empty list which is just uh you know the empty list let's see what happens oh seems like it worked any questions about this great question so why is it the case that within this four where we're picking the first element we have another four where we're picking the permutation of the rest of the elements and i think that nested loop is just inherent to this problem so there isn't really a way to get around it i mean you could use a list comprehension instead and try to do this all in one line uh if you really wanted to but it's not like you've gotten rid of the for loop you've just sort of changed its syntax right so uh it's still in there it's just kind of hidden away a little bit yeah and so what are the two loops by the way so there's one loop that we agree we have to peel off the first element in the list and then the second loop has to permute everything that's left so i think john's right that this is inherent in this um problem definition yeah the way we're getting to all six of these is we're looping over groups and then within each group we're looping over the two different permutations in the group yeah so great question is there another way to do this where you have the same elements but you group them in a different way where you're taking the first element and inserting it so the story there is you start with uh a split of the first element and everything else your outer loop is that you permute everything else so it's either going to be 2 3 or 3 2. the inner loop is where do you put the 1 i could put the 1 at the beginning i could put the 1 in the middle i could put the 1 at the end but notice the order of 2 and 3 is the same in all of these cases and then i could consider the other permutation which is that 3 comes before two and i could decide to put one at the beginning or one in the middle or one at the end and this is a perfectly good way of doing this problem as well so if we wanted this kind of answer slightly different order how would we go about it well base case looks fine the way it is but here we're saying the split is the first element and the rest of the elements we're considering rest permutations as the outer loop so rest permutation might be something like 2 3 this might be something like 1 and this is 2 3 just annotating it with examples okay now what do you do is you have to consider all the different places where you could put uh first and so here we have another for i in range len s you could put it in the zeroth position or the first position or the second position so the code hasn't changed very much this i think we've handled already but we have to think about what to yield and one of the questions was if i just insert so if i write for example rest.insert first in position i then something goes wrong so let's talk about how insert works let's say rest is two three and first is one and i is first zero right then if i write rest.insert first r oh what have i done oh i got it in the wrong order i think let's try again rest oh yeah first i equals zero you're supposed to be inserting into a particular position a particular value okay so that's what we want ah sorry this is great this is something we could yield so we yield that and then we change i to one that was what going through the for statement again would do and then what if we evaluated this again trouble we have a problem the problem is that insert is a mutation operation and so the insertions are accumulating in the rest and so it's getting longer and longer this is not what we wanted we wanted 2 1 3 but now we have something else so just writing this isn't going to work you could write result is a new list that has all the elements of rest in it and then you could insert into that result and yield that result and you'd get away from this problem of inserting into the same list twice because you'd be making a new list each time that always kind of started out at 2 3 and then you're inserting into a different place so i suspect that this will work oh apparently not uh did something wrong that much is clear oh sorry this is supposed to be that rest permutation yes yeah okay now it works uh sorry about that yeah so you have to consider all the permutations of rest and insert into all of those and then we have a different grouping we have uh all the places where two comes before three and then all plays where three comes before two so those are the two different rest permutations and then we're considering all the different places of pudding uh first so when you're modifying that list in a recursive call you just be very careful right so the way the reason why this worked is we peeled off and we created a new list and notice also the list operator there uh two lines up from where the cursor is it's not result equals permutation that would have been the same object so we create a new list we mutate it and then when we go back in the lip it literally creates a new distance time yeah yeah and another reasonable way would be to try to avoid mutation operations like insert entirely and here you would yield rest permutation up to position i and then put in first and then get the rest of the rest permutation uh that would probably work too apparently okay uh two quick questions somebody's asking would this work for strings okay um would this work with strings i guess it probably would uh i don't remember if you can call me if we want the permutations of abc we're not going to get strings back right this always yields lists but we will get the list of all lists that are permutations of abc and the reason that this works is that what have we actually done with s well we've checked its length that's something you can do with a string and we've gotten elements of it or slices of it that's something you can do with the string so uh yeah i guess um s could be a string it could be kind of any sequence anything that you could take the length of and get elements of or get slices of wood work here but it won't give you strings back it'll give you back lists but we could have changed this to to yield the empty list and do everything a string concatenation instead of list concatenation that would have worked also oh that's a quick change here and then down below also john uh in first gotta get rid of that yeah now maybe we're in business yeah so i think for the most part things that operate on strings and this work but there's a few operations and i think audrey's confirmed that you can't insert into a string there's a few things the operators don't work you just have to sort of push everything together in a slightly different way yeah that's right strings you can't mutate a string they're immutable objects so you'd have to do it this way so if you have okay so the question is can you create a circular um linked list and if so is that ever a good idea or not um so here's the link from uh lecture and if we create link one link two link three um that's something i can look at i can print that print life is good but if i change it so that s dot rest equals s then s dot rest is just s star first is still something the number one we've lost track of the numbers two and three um because now s dot rest on first is still one and as the rest i rest at first is still one i can't print it why well there was a print method uh that we came up with which was basically like you know uh start with the angle bracket and then get the first thing and then get the rest and keep doing this until you hit a rest that's empty but the rest of this is never empty because it's always just s again so this is running forever we've created an infinitely long linked list there are cases in which you might want exactly that you might want to represent some repeating decimal of like you know what happens when you divide one by seven well actually this should go on forever and we could represent that as a circular linked list and then we could ask you know what's the 50th digit of one divided by seven and we could just call rest fifty times and find it so there are cases in which you might want to do exactly this this is a feature of linked lists that doesn't really exist for lists lists have to have a length but these things don't really have to have a length if you make them cyclical though i would guess like 99 of the time you want them to actually end it's pretty rare that you want something to go on forever so this there's a name for this era to your question too is that these are called circular lists um and one of the benefits is as you're traversing a list you know there's something nice that when you get to the last element you can get back to the first element so this idea that there's no real end to the list but it causes problems but we could have fixed that problem with a different print function we could have had some notion of wrapping around and one way to do that is what's called a sentinel and you put a special node at the front of the list that indicates that it's not a data field it's a sentinel so you put something in the data field that that specifies this is not data it's it's showing you that at the beginning of the list and then when you start going through and you wrap back up to the sentinel you know you've wrapped around so then the print statement could have said okay keep printing until i loop back and then sp have some notation to say this will keep going like dot dot dot yeah so they're not fundamentally bad but you do have to put um precautions in place and circular linked lists are actually a common data type and that's a great point that if we had just a slightly smarter version of stir then we could print this out just fine and just like put a data sure great question so the question is about discussion 5 question number 1.3 which was called square tree when you write an implementation of this then it's unclear how python actually executes that code this was using the tree data abstraction but since in this lecture we talked about the tree class maybe we'll use that one instead and it'll have almost the same code so uh now we have our tree class what would it mean to square a tree well uh i think that you want to square the label of the tree so one way to write that is t dot label squared or t dot labeled items t dot label either way is fine but the goal of square tree is not to return the square of the label is to return a whole tree so we need to return a whole tree where this thing is the label and what are the branches well the branches are the result of calling a square tree on each branch so how did i get that far well i know i want to square all the other labels each label appears as the root of some node within the tree so if i've said square the top of the tree and then i apply that operation everywhere else in the tree then i'm going to end up squaring every label in the tree so i could write squared tree b for b in t dot branches and then if i have a particular tree here's a short one oh i shouldn't use one because you can't tell whether one got squared can you and i square that then i have squared everything i've squared the 4 to get 16 i squared the 2 to get 4 i squared the 3 to get 9.
let's do a medium tree and we'll talk about how it actually gets executed so if we have 4 there three two we have a uh branch of this tree like uh five and then we have a tree three so this is almost the same as the one we had before except for it has one extra little leaf here when we square this tree even the five gets squared the easiest way to think about it is through abstraction and say okay so the result of square tree on this medium tree is that i get a new tree or i've squared the root and i've applied square tree to all the branches so there's what's happened when you square tree this and here's what's happened when you square tree that and you kind of just don't think about the process but it is the case that uh python is going through and traversing the whole tree and squaring things bit by bit so maybe it's worth just printing out what it's doing next as it goes and we can see what happens so here's our medium tree and here's what happens when you square medium tree oh that's not exactly what i wanted let's print the wrapper is that first just trying to square that but we make a recursive call on the first branch which makes a recursive call on the first branch that's that's the call that gets us 325.
and that's the call that gets us three nine and that's the call that gets us three four twenty five but notice that that's just using a piece of what has already been computed and then once you've computed this piece and this piece already then you can build the whole thing the next question was about spring 2019 midterm two question one what would python display all right so items is an empty list n is two um air pods is a clast that's got its own two i think we really do need to annotate a little bit to show what's going on i'm just gonna try drawing freehand and it's probably gonna look terrible but who cares so we got items we got n and we've got the airpods class and the airpods class has cost a okay okay at zero and then it's got um three different methods an f method an init method and a wrapper method and then two airpods is like airpods doesn't have any class attributes and then we've got some functions and um so we can see what happens so let's see what happens if we kind of just trace through this uh two airpods dot cost this is a class we're looking up a class attribute the way you look up a class attribute is that you look in the class it has no class attributes called cost so you look in its base class so this would give you the number 200.
what happens when you create an instance of an airpods well in that case you create a new air pods and you call in it and so we're going to have to do that uh i think it's handy just to like keep track of all the instance attributes in a box so let's say that's our uh lost air pods and let's track what happens so i'm going to interrupt just for a second because raya asked a question in the comments um she's saying i thought it was a hundred because discount was called before uh oh it's true i wasn't paying any attention so i think we lost the discount i kind of skimmed over this part but it actually is important so discount takes whatever class you pass into it and divides its cost by two so then uh i agree with you that this would be 100.
yeah so what happened there is that we changed this cost oh apparently you cannot change things in maybe you can and so this is hundred uh okay and that's all that happened all right so we created an airpods what does airpods do it um changes the class attribute k to increment uh so this is now one it calls some function that's part of the class so that's f on self and what does that do that prints out self so this self that's getting printed out is this new instance of the airpods class when you print something out then it's going to look for the stir method if that doesn't exist it will call the repper method instead so printing this out is going to display whatever this returns so we have to read this this says airpods k is less than 2 which is true and lonely which is a true value because uh you know strings that aren't empty are true so um this is actually going to evaluate to lonely and when you well this is definitely not an exam that i wrote uh and then when you or that with pair then you have to know this rule about what happens when you uh evaluate an or expression which is that the first true value of the true ends up being the value very mean so basically what the way to unpack this is to have it say if error positive.k is less than two return lonely else return pair right what that's doing so um calling this method will give you back the string lonely what printing does is it displays the contents of that string so it doesn't display the quotes then there's one more thing that happens which is that items which happens to be global is extended with a list containing only self what extend does is it takes all the elements of this list and adds it to items there's only one element of this list so now items which we didn't bother to draw but should have if we were trying to actually do this correctly so no i guess we need it uh oh i can draw squares items now has something in it and the thing that it has in it is this beautifully laid out okay uh what happens when you make it two airpods well when you make it two airpods you don't you call the init method for two airpods um so we're gonna create a new uh dang it i wanted a box we're gonna create a new instance this times it's a two airpods instance we're gonna execute all this which says it gets an instance attribute called k and then we call airpods.init on this and we're going to do it twice so the first time we call this we're passing in the two airpods instance as self air pods dot k plus equals one okay so we've changed this again to two um we call this function which just prints it out which calls this wrapper method again k is no longer less than two so uh i think that this is going to display pair this time okay and then we extend um the items list yet again so now there's two elements in the items list but actually we're calling airpods in it twice so we have to play this whole game again uh where we increment airpods.k this is now three if zoom will let me edit it print out pair again and we add this to items so there's where we are okay and these things have names by the way in the global frame there's one called lost uh which is this first one and there's one called man i really made a mess will be lost which is this one and now we're apparently gonna look at what happens with these so stir lost what happens when you call stir on lost well you check for a stir method there isn't one so we'll use the wrapper method instead we have to reevaluate this whole expression now errorpos.k is not less than two so we get the string pair let's see what else we got here item.k for item and items we have three things in items so we're going to end up with a list with three things in it and we have to figure out what dot k is for each of them for this element um it has no instance attribute called k so we look in its class and we find that k is 3.
for this element it does have an instance attribute k so that's 2 and this element is actually the same thing so it has the same k home stretch you lost will be lost which takes in lost and will be lost and uh keeps them in the same order and returns the result of calling print u on each one so we have to print out we've already talked about what happens when you print i believe it displays pair and so that will be the pair that comes from printing the first one that will be the pair that comes from printing the second one but then we have to return the result of whatever print returned and print returned none both times so uh we get a list with none and none in it take the person who wrote this question out back and smack them around a little bit john okay okay so this is spring 2015 midterm two uh question four b takes a string and a dictionary that contains words as values and their secret codes as keys it returns a list of all possible ways in which s can be decoded by splitting it into secret codes and separating the corresponding words by spaces so if you have something like alan turing then there's lots of different ways this could be decoded because alan could be spooky and turing could be ghosts or al could be drink and could be your and ring could be ovaltine so that's how you got these two and apparently there's another one spooky scary skeletons maybe this exam was on halloween okay so um this has a for statement in it and one of the questions was how come what happens if you have a recursive call in the for statement um and you know as long as you treat your recursive call as a functional abstraction then maybe it's just not so bad that it happens to be in a for statement as long as you know like oh i have a way of taking the rest of the string and deco decrypting that um then i guess what we'll do is we'll go through all the prefixes of the string that match something in codes and then we'll have the rest of the string that is after the part that we match so if we match the allen then we have the rest as touring and we're going to have to decrypt that so alan will tell us that there's drink but a recursive call to touring will uh oh sorry ah alan gave us spooky but a recursive call to touring will give us either ghosts or scary skeletons and we'll just have to figure out which it is by letting recursion do the trick okay let's take a look at the code empty string has no way of decrypting it ms is going to be what we eventually return so these are the messages uh if it's the case i think that all of s is in my codes dictionary annotate again if s and d then what should we do we should decrypt it yes okay now we're going to split up s into two parts there's going to be a part where we try to decrypt the beginning and then there's like the rest which we're going to handle with a recursive call and we can see that k is being used as an index into s so we need some way of saying uh 4k in a bunch of numbers i think there has to be at least one letter and i think that there's got to be at least one letter in the first and there's got to be at least one letter in the suffix i'm not sure yet but that's a reasonable hypothesis so we'll check it later so maybe it's something like that so this breaks up the first and the suffix so they have at least one letter each by splitting on k now what do we do if it's the case that the first is actually something that we know how to decrypt if first in d then i think what we want to do is go through and decrypt the rest what's this thing called decrypt i hope i'm not gonna well okay i'm i'm not gonna scroll because then my annotations will move uh so this is going to iterate over a bunch of different options like um scary ghosts or whatever it is and now we're going to build up a full decryption of the whole thing this is not so different from permutations here what we're doing is building a longer list that's got d first in it as well as whatever's in the rest that line i wrote is actually wrong i was supposed to build a string not a list and append that so i shouldn't have put d first in a list instead i should have left it bare and i should have added a space in between d first and the rest so to figure out whether this range is right i guess we'd have to think about particular cases so what happens if uh yeah i think this is right if if we had had empty suffixes and we made a recursive call on an empty suffix then we'd have nothing to iterate over because of the way this is defined so we need to have the suffix contain something and to hit this particular base case this isn't really it's kind of like a base case if it's the case that s is all the way in d then we actually get to see the decryption of that we made it through another question do you have any questions about this question somebody is asking could a problem like this be on the next midterm sure i don't think it'll get any spookier than this but this is the kind of thing we'd like you to be able to do yeah this is a more sane problem i would say somebody's asking what dia first does again this gets the decryption so this goes from alan to spooky or whatever it was so yeah if you notice there are no allens or turings in the results there's only drinks and ovaltines and spookies and ghosts so it has to be that when we build these things they have to be built out of the result of looking up strings in the dictionary as well that's a dictionary look up in case it wasn't clear oh yeah that's the whole thing at the very beginning d is this codes thing that has all the all the decryptions all right oh tan is asking why only to the length of s minus one and the reason is that underneath you have to you have to break the list up into at least two parts first and suffix so if there's not two parts there's nothing to break down and so you don't have to do any more work right so we're trying to make sure 