Let's look at a famous example of iteration. We're  going to study the Fibonacci Sequence. That's   Fibonacci, a mathematician from long ago. And  here is his sequence. It starts with 0 and then   1 and then every element after that is the sum  of the previous two elements. So 0 and 1 make 1,   1 and 1 make 2, 1 and 2 make 3, etc. And you  can see that it starts getting fairly large   before too long. Now, Fibonacci did not invent  this sequence. It was discussed and described   by mathematicians long before him, but he made it  popular in the West. And so we still refer to him   every time we see this sequence of numbers. Every  Fibonacci number is associated with its index,   the position in the Fibonacci sequence. So we  usually call this the 0th Fibonacci number,   the 1st, the 2nd, the 3rd, the 4th, and the 5th,  etc. So the 5th Fibonacci number is 5. Now it   might appear in position 6 in this sequence,  but we call this one the 0th Fibonacci number   since it's 0. That's just a convention. Now, who  cares about the Fibonacci Sequence? Well, that   certainly has interesting properties. You can make  what's called the golden spiral by tiling together   squares whose side lengths are Fibonacci numbers.  So here's a square of side 1, 1, 2, 3, 5, 8, 13,   21, 34, etc. And then if you draw a spiral going  through the intersection points of these squares,   you get an ever-expanding spiral that looks  particularly well balanced to the human eye.   It's also a spiral that people like to look for  in nature. Here is a cabbage where somebody thinks   they've discovered the golden spiral. Okay, enough  about the Fibonacci Sequence. Let's figure out how   to compute it using a while statement. Here's  a function that takes N, the position or index,   in the Fibonacci Sequence where we want that  Fibonacci number, and it computes the nth   Fibonacci number for N greater than or equal  to 1. It does that by keeping track of various   values and then executing a while statement.  So when you're designing an iterative function,   one of the most important things to think about  is what information you need to keep track of in   order to perform the iteration. In this case, in  order to compute that the next Fibonacci number   is the sum of the previous and the current one, we  need to keep track of what those Fibonacci numbers   are. So we start out at the beginning of the  sequence. The 0th and 1st Fibonacci numbers are   0 and 1. And then we also need to keep track of  where we are in the sequence. So that's how we use   k here. K keeps track of the index and throughout  the execution of this while statement. K will be   telling us what Fibonacci number is bound to the  named curr for current. Now, the current Fibonacci   number at the moment is the first one. This one,  0th, 1st. But as we execute this while statement,   k will change and curr will change and k will  tell us which Fibonacci number is curr. Okay,   this says k less than N. We're going to rebind  pred and curr to be the next numbers in the   sequence. So the predecessor is bound to the  current one and a new current value is computed.   And here, we use the definition of the Fibonacci  Sequence. The next Fibonacci number is the sum   of the current one and its predecessor, and we  bind that to be the new current Fibonacci number   which has an index one larger than before.  So that's why we bind k to be k plus 1. Now,   the structure of the while statement allows us to  perform this computation many times until we found   the nth Fibonacci number. So we keep doing it  until k is less than n and that means at the end,   k equals n, because we're just adding 1 to k  each time. So we found the nth Fibonacci number,   we've bound it to curr and we return it. In  the environment diagram, for this example,   we're keeping track of the names pred, curr,  n, and k in a local frame for calling the fib   function and never changes. So if we're trying  to find the 5th Fibonacci number, which is 5,   then n would be 5 at the beginning, pred and cur  would be 0 and 1, and k would be 1. Now we'll   track which values are bound to these names every  time we finish executing k equals k plus 1. So the   first time through, we'll rebind pred and curr to  be the next two numbers in the sequence. And see   now, curr points to the kth Fibonacci number where  that is the 2nd Fibonacci number. There it is. And   then we execute the body of the while statement  again, marching pred and curr up the sequence   and changing k at the same time. We're going to  do that four times. Now k equals n. So it's not   the case that k is less than n. We're finished  executing the while statement and we return curr,   which is the 5th Fibonacci number, 5. Here's a  discussion question. What if in the body of fib,   I had made the following change? I had bound  pred and curr to 1 and 0 and k equals 0. Is   this alternative definition of fib the same or  different from the original one? Pause the video   and think about that for a moment, then we'll  discuss it together. So this is still a correct   implementation of fib. For every n greater than  or equal to 1, just like our old definition. But   it's even better because it can compute the  0th Fibonacci number correctly. So we found   a particular input value where this does a better  job than the old one. So in particular, if n is 0,   then curr is 0, which is the 0th Fibonacci  number. By the time we reach the while statement,   k will be 0 and will be 0, and so the body  will never be executed and will return 0,   which is the 0th Fibonacci number. Excellent. Our  old version didn't do that. But what about with n   equals 5? Well, we start out with curr 0, and  then we're actually going to execute the body   of the while statement five times instead of four  because we started with k equals zero instead of   k equals 1. So curr will be 0 and then 1, 1, 2,  3, 5 will still get the 5th Fibonacci number.
