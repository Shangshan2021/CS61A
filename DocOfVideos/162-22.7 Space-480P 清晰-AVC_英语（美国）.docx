Space or memory is another resource that gets  consumed by programs as they execute. And so   it's something that you need to worry about. Now,  the consumption of space is taken up by values.   So a long list takes up more space than a short  list, but it also gets taken up by frames. So   you need to know how many frames exist because  of different function calls in your program at   the same time. And this will involve some new  concepts. So the new concepts we need to keep   track of are, which environment frames do  we need to keep around during evaluation,   and which ones can we just let go. So here's  the story. At any moment, there's a set of   what are called active environments. And values  and frames in those active environments consume   memory or space. Any memory that is used for other  values and frames, not in an active environment,   can be recycled. And the Python interpreter does  this automatically, by reclaiming the space that   it used before when it knows that that information  is no longer needed. So which are these active   environments? Well, an active environment is  for any function call currently being evaluated,   meaning we called it but it hasn't returned  yet. There's another case, much less common,   which is a parent environment of a function that  exists in an active environment. So this situation   occurs when you've defined a function within  another function. And so its parent frame is   not the global frame, but some other frame. As  long as you need that function, you also need   its parent frame, and all of the other frames  in its parent environment. So, fortunately,   Python tutor can visualize which frames are  active for us. Here's our definition of fib,   which computes Fibonacci number, number 6.  And there's a setting, which I'll show you,   that says don't display exited functions. So in  this way, it will actually delete the frames of   anything that has already returned. So when we  call fib(6), obviously it hasn't returned yet,   because we have some work to do. And that's going  to involve calling fib(4), which has to complete   before we ever tried to finish fib(6). And fib(4)  involves calling fib(2). And so all of these are   active frames at the same time. Fib(2) calls  fib(0), fib(0) actually returns. And once it   returns, it's no longer active and so it's just  going to disappear. And instead, we have replaced   it with a frame for fib(1). So notice we had f1,  and f2, and f3. We created f4, but then got rid   of it because we didn't need it anymore. And now  we're up to f5. So if we continue this process,   we'll see that once fib(4) was done computing  fib(2), the fib(2) frame was removed. And now   we have the fib(3) frame, which is the other  part of computing fib(4). So that goes on for   a while. And eventually, the fib(4) frame has gone  entirely. And we only have the original f1 frame,   because we're not finished computing fib(6).  And we have the f11 frame that was created for   computing fib(5). That does some work. Eventually,  that gets deleted, and fib(6) can finally return   the value of 8. And then there's no more work to  do. In our code, we can also see how many frames   are being used. So let's define a higher-order  function called count frames, which takes in some   f and defines a counted version, which takes some  argument n. What it's going to do is increment the   open frame count. It's also going to keep track of  the maximum number of open frames at any time. So,   if the open_count is actually larger than the  max_count, we can change the max_count to be   the open_count. Now we'll get the return value by  calling f on n. Now it's time to close this frame,   which just means subtracting 1 from the open_count  and then we can return the result. The open_count   starts out at 0. The max_count starts out at 0.  And we can return the counted function. So if we   define fib really quick, we already know that  it makes many, many recursive calls. But what   we don't know is how many frames are open at  any given time or what the maximum number of   open frames is. So we can figure that out by  calling count_frames on fib. And calling fib   on some numbers such as 20. So it's computed the  20th Fibonacci number. And fib.open_count should   be 0 because we've returned from every call to  fib that we've made. But the max_count will tell   us the maximum number of frames that were open  at one time, and the answer is 20. So that's   an indication of how much space is used by this  function. It doesn't need to open 6000 frames at   a time, only a few. Now, how can we understand  why the number came out 20? Well, here's the   tree-shaped process that we use to compute fib(5).  And let's say we've done all this work already,   we still have to do all this work, and we're about  to return from this call to fib(1). Well, we can   figure out which calls have an active environment.  So this one, this one, this one, and this one,   which haven't returned yet. The ones over on the  left have already been called and returned. So   any memory used by these frames can be reclaimed.  And then over here, these haven't been called yet,   and so we don't need to worry about that. So the  maximum count of frames open is the longest chain   you can find in this tree, which in this case  goes from fib 5 to 4 to 3 to 2 to 1 is length 5.
