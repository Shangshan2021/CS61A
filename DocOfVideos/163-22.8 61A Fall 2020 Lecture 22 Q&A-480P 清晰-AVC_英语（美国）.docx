61a lecture number 22 q a the question is about creating attributes inside of a function which uh i did in an example from this lecture it turns out that if you have a function that function itself can have attributes now right now it doesn't have an attribute if i call f on 10 i get nothing because it has no attribute y but i could give it one and now when i call f on 10 i get 15.
you know functions can have data associated with them that's been true for a long time since we talked about higher order functions in in in lecture four i think and here we have another example of a function with data associated with it i um basically what's going on here is that functions are values they're objects objects can have attributes it turns out in python that any user defined function can have arbitrary attributes and so this is one way of just associating data with the function by storing it as an attribute in the function and the nice thing here is that it is mutable so you can kind of change it later um there's no control over who can change it so that it makes it a little bit too flexible in some cases but this is an alternative to for example using non-local assignment or a higher order function is that you could just store the data right there as an attribute in the function yeah great question the question is about space complexity and whether recursion uses up a lot of space because every time you make a recursive call you're allocating more space to hold the frame that represents the kind of first frame in the environment for that recursive call and so if you make 50 recursive calls then you're creating 50 frames um yeah that's exactly right there is one answer to this that exists in other programming languages but not in python um which is that there there's like a special case where it turns out you don't need to create a new frame you could just kind of reuse the old one uh called tail recursion we'll talk about that it's an optional topic in a few weeks but this is just like one particular esoteric point i guess the main point is that yes when you make a bunch of function calls then you introduce a bunch of frames and this incurs some space overhead so if you could avoid it that's not a bad idea at all so typically when you'd write a um when you have just some iterative process you want to like go through all the elements in something then in python and most other programming languages the best way to do it is just with a while or for loop and not to write it recursively recursion isn't really for that it can be used for that but what it's really for is for tree recursion and processing trees or other hierarchical data structures that's where it's quite helpful and if you think about those cases actually the space use tends not to be that large so in a typical tree recursion you're going to have a massive amount of computation if you don't memorize because you're like building out this whole tree of many many different recursive calls but the space that you need is only the length of the longest path through that tree and you could have many more nodes in the tree than you could have the height of the tree and so for that reason the space usually isn't the kind of important limiting factor for a tree recursion problem it's usually time making all those calls um rather than the amount of space it takes to capture all the active ones at any particular moment usually you know depends on the problem yeah and 20 years ago space was a real concern these days it's a little bit less of a concern memory is cheap everybody's got a terabyte of memory so we worry a little bit less about memory but you're absolutely right michonne is there are certain recursive functions we have all written that you would never really do recursively there's no reason not to do them iteratively it's just more of the exercise of learning recursion and if you think about a tree recursion problem like count partitions where you're kind of uh making branching calls there's a way to do this without recursion but it does use the same amount of space if you do it without recursion you basically just have to track all the frames explicitly in a list instead of having the interpreter do it for you so it's not like avoiding recursion tends to help you much there and then some problems um so if you watch the the lecture on the towers of hanoi they just the solutions are just so much easier recursively like they have to think through the iterative solution can be really gnarly so every once in a while you know there's a very clean and elegant recursive solution those are the ones i particularly like and i guess the final case to talk about is when you're doing something with a tree that's a common case for uh recursion and in that case like the tree is already there you've already like used that much memory so having an extra frame for each node in the tree you know it's more but it's not like a lot more um so it tends not to be a big issue that was a long answer to a simple question but uh but i guess it wasn't that simple [Laughter] no it's a great question michonne it's absolutely the right question and so if if the kind of essence of the question is should we not use recursion for stuff where we could just use a while loop basically that's a good piece of advice yeah okay so the question was about the exam prep sections uh worksheet number six which covered object drawing and programming and had the following question on it fill in each of the blanks and the code such that the expressions and outputs in the table below are consistent okay so it gives you a bunch of examples and uh i assume that effects from previous subpart persist to future subparts i think that's like as we go down here changes are going to accumulate so we have a party class which has a guest's linked list as its class attribute some minute that will have to work out some notion of attending and then we have a costume party which is a subclass of party that's got its own in it it's going to do something to party's class attribute called guests and it's going to do something to its own instance attribute um and it's got its own notion of attend and it's got its own rapper method which i guess is going to be pretty interesting here so um let's take a look at what's going on um when you create a linked list you create it with two arguments the first element and the rest of the list if you left this link that empty out and just passed in one argument you get the same thing because link that empty is the default value for the rest of the list and link has a wrapper method which generates uh an expression that would create an equivalent linked list okay um so that's what we see here and here what we see here is that when you create a party with one as its time and you look up the guests you end up with a linked list that's got 2 in it we don't really have a story for why that would be except that here we have an assignment line that we could use to change partygut yes to be something else um or we could change the instance attribute for guess to be something else and the tricky thing about this problem is that we don't actually know which one it is yet like you can't tell from this expression whether guess is an instance attribute or a class attribute but since the class attribute is there already hopefully it's that okay when we call party3 and then dot attend now we have well an interesting pattern is emerging which is that uh this is one more than that and this is one more than that and um then something a little bit crazy happened here this is not a linked list but instead well it is a linked list but it doesn't have three elements instead it's got two elements where the first one is four and the other one is its own list so if we were writing this in a python list this would look like four with two as the second element that's what this link four link link two structure is equivalent to um and how we got here i guess we don't know yet but we can take a look at what attend does so attend uh does something and then it returns self.guest is party.guest okay so that must be true because otherwise we wouldn't we'd just be getting false and that's not what we're getting we're getting a linked list and so it's returning party.guest so this is an interesting hint self.guest is party.guest means that there really is no instance attribute on a party instance instead it must be a class attribute for these two things to be the same thing so it must be that we're manipulating class attributes here and uh we can look at how that happened we um added something to the linked list and then somehow we like got this nested structure which i guess we're going to have to understand it's plausible that the elements were added here and that the nested structure was created here maybe this is more of a puzzle than i would expect um but uh i think we're making some progress so uh let's see if we can fill some of this in and then i'll stop and ask take questions so it seems like this has to be that party dot guests is being changed and how's it being changed well as far as i can tell we're taking time adding one to and putting that in as a new element in this linked list how do you take a existing linked list and put something new on the front well you call link with the new element on the front and then keep the rest of the list in there so the original list becomes the rest of the list you would write that as party.guests so this just makes like a linked list of numbers every time you call party then you get like a another element now why is it that guests and time are somehow related i have no idea but i didn't write this problem so um here we are now we have to think about this nested structure how could it be that um after calling party one and party three we had uh guess as like a nice linked list that looked like link four link two and somehow we got an extra link in here we're to need an assignment statement in order to do that i think in order to get from here to here let's see if i can line these up a little bit better we have to change the rest of this linked list in order to be a linked list that contains whatever was there before this is a valid thing to do um maybe we'll do a python list version of it in a minute but let's talk about what it would look like so this would be like party.guest.rest equals link of oh i typed it wrong party dot guests this particular assignment statement would get us from here to here because all we did was replace what was in this position with a linked list containing what was in that position then if you evaluate this you'll find that self.guess is parted i guess so that's true and and uh expression will always return the second thing if the first one is true and so the second thing is party.guests which means we're returning this whole linked list and that's what we see so this is now the value of party.guests nothing in the chat yet people want to ask questions you could just chime in otherwise i'll keep going here's a question john why is it not party.gus.red for what's in the link parentheses oh yeah i probably shouldn't i think that's right if you go down to the yeah i think that's right otherwise the the party 7 wouldn't have worked i think yeah otherwise we would have had a four in here and we don't want a four in here we just want the rest of that all right thanks that's right thank you raymond okay um what's going on with this costume party well let's take a look so when you call a costume you're passing a bow and a tie which is gonna update party i guess that rests somehow and it's going to update this instance attribute and then we're going to attend which calls this it doesn't necessarily call the party function at all what it does is it prints a wrapper string for self dot ie [Music] and what came out was [Music] nice link costume these both have to have appeared as a result of this print call because a 10 doesn't return anything so none of this is due to a 10's return value this all has to be from the print so when you call repper on selfie you are invoking the rapper method for the class of uh of selfie so um this is not immediately going to invoke the repper method for this value itself because instead it's just going to invoke oh come on invoke the wrapper method for whatever this link is that we've created now if this link happens to contain uh the costume party instance then we'll get a call to this repper man this is a convoluted one so um we need to construct this value such that we get print nice right here i'm gonna make a hypothesis then we'll trace it through and see if we got it right or not i think the trick is to print nice here to return costume here and to oh create here a linked list with only one element and that element is self let's see what we've done i'm gonna ignore this line for a while just work with what we have if it's the case that we create a costume with five and six so far we're ignoring the five and the six and we're creating an instance attribute which is a linked list containing just this costume instance now when we call when we invoke a tend we're calling this method which prints the result of calling wrapper on selfie which is a linked list containing the costume when you create a linked list uh when you create the wrapper string for a linked list what it does is it gets the um the string that represents each element and puts those into a larger expression so let's take a look at it this is true of all kinds of lists we happen to write it explicitly when you want a wrapper string here's an example the way you do it is that you recursively get the repper string for the rest but you also get the wrapper string for the first and then you put those together into an expression it's like link of whatever the first looks like and whatever the rest looks like so to get a wrapper string for this linked list you need to figure out how to write down the number one and you need to figure out how to write down the rest of the list and then you put them together into one expression that's what's happening here here we are trying to draw this as a string which means we have to call repper on self when we call wrapper on self that invokes this wrapper method which prints out nice returns the string costume that's the string that's representing this costume instance and then it is the wrapper method of the link class that puts the word link and the parentheses around whatever i returned right here and that's not even the end of the question apparently there's a there's a part there's a whole other part to it this is a good i have to say this is a killer question yeah if the exam prep is difficult then maybe the exam will seem more reasonable or maybe not we'll see so um this is changing what party.10 does in some arbitrary way i think the easiest way to get this behavior would be to just kind of ignore everything and say oh from now on party.attend just returns uh this text [Laughter] that's really bizarre that's one way to hack it to do what we want that you would be right there totally could be another way that involves getting party.guest.rest to be oh there's no way there's no way you're converting the what's the current party for yeah no that's got to be the way to do it right john well no there's this opportunity to like reset party.guest.rest to whatever we want so ah it was this but we could rewrite it to have uh an eight and a four and a five in it there yeah okay and then we could like print that out but in any case i think this solves the question party seven just does whatever it does who cares uh because now whenever you invoke a tend you just get this probably not the answer that was intended but okay a really great exercise i would say is uh trying to figure out how some nested structure would be represented as a linked list if you have this thing what's the linked list equivalent so you know let's call this s what's the t well it's a linked list that starts with one the next element is actually another list and what's the last element just a number oh it's never a good sign so s looks like that t looks like some monstrosity but there is a stir method on linked list that does something kind of reasonable basically this was designed let's look at that this stair method which you get when you print something out oh look this example looks very familiar um this method was designed so that it behaves in basically the same way as the built-in lists wrapper so that you can kind of look at the correspondence between the two now it's still the case that in order to access stuff in here you know accessing something in here like getting the 2 would look like that but getting the 2 in here means you have to treat it like a linked list you have to get the rest and then you have to get the first and then that turns out to be a linked list and so you have to get a number out of that so still the operations are different because it's a different kind of data structure but it can represent the same sort of nested stuff that you could 