We finished our restaurant search application but  it's too slow to find all the Thai restaurants   and list all of their similar restaurants. It  doesn't happen instantly. In fact, it takes   about 0.7 seconds. And things are even worse  if we look at cafes. Since there are more cafes   and it now takes 1.7 seconds in order to list  all of the results. Why is it so slow? We could   go through in time each part or we could just  think about what's happening in our program. We go   through each restaurant to see if it matches the  query. That's linear time. For each restaurant,   we call similar on every other restaurant. That's  also linear time. And what about computing the   similarity itself? Here, we go through every  reviewer for restaurant r and check if that's a   reviewer for restaurant s. And how does it do that  check? Well, it goes through every reviewer in   restaurant s to see if it's x. So this operation  is actually quadratic time. It's comparing all   pairs of a reviewer in r and reviewer in s to  see if they're the same. I think that's what's   slow. Which gives rise to the question, could we  figure out the number of users that reviewed both   r and s in just linear time? Indeed we could.  Here's the trick. Instead of just keeping a   list of reviewers for each restaurant, we'll  keep a sorted list of reviewers and then we'll   write down a linear time procedure that checks  for the amount of overlap between two sorted   lists. Given two sorted lists with no repeats, we  want to return the number of elements that appear   in both lists. Let's start with an example. If  I have this sorted list and that sorted list,   the way we'll find all of the elements they  have in common is to pass through both of them   together starting at the beginning of each. If  one of these elements is smaller than the other,   we know it doesn't appear in the other one because  it's smaller than this and this is smaller than   everything here. So one must not appear anywhere  in this list. Therefore, I can advance into the   second list because one is smaller than 3.
3 and 3 are the same, so I found an element   that appears in both, and I can  advance both of these positions.  4 is smaller than 5, so it's also smaller than  7 and 8, meaning it doesn't appear anywhere in   the other list so we can discard it and move  on. Likewise, 5 doesn't appear in 6, 7, 9,   10 because it's smaller than 6 and everything  after 6, so we can move on. 6 is smaller than 7,   and now we found another pair. So we remember that  we found a second element that appears in both and   we advance both. 8 is smaller than 9, which means  8 doesn't appear anywhere in the first list and   now I've reached the end of the second list which  means I'm not going to find any more elements   that appear in both. Now that you have a picture,  try to implement that procedure. I recommend that   you pause and I'll go over the answer in 3, 2, 1.
We'll use i to index into lists s, and j to index   into list t. And we'll keep going as long as i is  less than the length of s and j is less than the   length of t. If I found an element that appears in  both, then I increment the count and move forward   in both s and t. If the element I'm considering  in list s is smaller than the element in list t,   then I know it doesn't appear in list t anywhere.  And so I can move forward in s. Otherwise,   I move forward in t. Let's see if it speeds  things up. It takes 1.5 seconds to list out   all the cafes and their similar restaurants.  But what if we were place reviewed both with   a new implementation? Here's the modular way to  do it. We should define the overlap between two   sorted lists generically for any two lists,  whether they're lists of reviewers or lists   of something else. And here's the code from  the slide. And then reviewed_both should call   fast_overlap on the particular lists that are  needed in order to compute reviewer overlap.   Instead of 1.5 seconds, now it takes only  0.7 seconds. So we've made it twice as fast,   at least for that one run. And what about Thai  food? Is that faster than 0.7 seconds? Yes,   it is. Now it only takes half a second. And that  means that our program is responsive enough to   make it interactive. We can do that by saying,  forever search for whatever the user types in,   and print out the results. In order to indicate  that it's time to type something, let's put a   little prompt there. So I've started my restaurant  search engine and I can look for Thai food, or I   can look for a cafe, or I can look for coffee, and  learn all about Berkeley's restaurants that way.
