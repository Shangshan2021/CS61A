Let's talk for a moment about designing functions.  There are lots of different functions that do the   same thing, but some are better than others  because they're easier for people to read and   understand and also because they are more useful  in more situations. Now there was a time when   people programmed without functions. They just  had statements and the statements would tell you   to go to other statements, and the whole thing  was just a mess. But now we have functions and   they're universally accepted as the right way  to organize large programs, at least in part.   So designing them is an essential skill for  anyone who wants to work in computer science.   Here are some characteristics of functions. A  function's domain is the set of all inputs it   might possibly take as arguments. A function's  range is the set of output values it might   possibly return. So knowing the domain and range  of a function tells you where it can be used,   what kind of thing goes in, what kind of thing  comes out. Finally, a pure function's behavior   is the relationship it creates between the input  and the output. Let's look at some examples.   We have the square function that we've been  talking about for a long time. Now we have the   Fibonacci function which computes Fibonacci  numbers. What's the domain of square? Well,   it's any real number x. What's its range? Well,  square always returns a non-negative real number,   meaning positive or 0. And what's its behavior?  Well, the return value is the square of the   input. It's pretty straightforward. Okay, so we  describe it in this way, just to say what kinds   of things come in and out. For Fibonacci, n,  the input, is an integer greater than or equal   to 1. It returns a Fibonacci number and the  return value is the nth Fibonacci number. Now,   pythons doesn't necessarily force you to specify  the domain and range in code. So these are   conceptual aspects of what a function is meant to  be used for. And oftentimes, these issues appear   in the documentation. So you see, compute the nth  Fibonacci number for n greater than or equal to 1   here. Here's a quick guide to designing functions.  These are just heuristics based on experience,   but they hold up in lots of different situations  so they're worth considering. One is to give each   function exactly one job. Another is don't repeat  yourself. The DRY principle. Implement a process   just once and then you can execute it many times.  And finally, define functions generally. So I   search the internet for some images and here's  what I came up with. It's a good idea to model   your functions after scissors, which have one job,  which is to cut things, as opposed to a Swiss Army   knife which has many different functions.  If something has many different functions,   it should probably involve many different  functions, not just one. Don't repeat yourself   because it's a lot of work. Puppies are also a  lot of work. Here, in quadruplicate. And define   functions generally. So here's a counter-example  of what you shouldn't do. When the world designed   electrical sockets, they solved this problem  in lots of different ways. And for that reason,   we have all these crazy adapters in the world  and it's really hard to plug stuff in. Instead,   wouldn't it be nice if there was just one general  way to plug something in? That's what you should   aspire to with your function, not the chaos that  exists in the electrical outlet world today.
