61a lecture number 23 q a so here we've got fall 2019 midterm two question four and i think we'll just go through it implement stable which takes a list of numbers as a positive integer k and a non-negative number and it returns whether all pairs of values in s with indices that differ by at most k have an absolute difference in value of atmos and okay so numbers near each other in the list need to be near each other in quantity the functions that aggregate iterable arguments on the metric to study guide have the following behavior when empty list is zero okay is this saying john like it's sort of sorted uh yeah kind of it's kind of sorted kinda sorted right you go up and down a little bit but yeah you go yeah i have two numbers that are very different next to each other right right cute okay so let's see what we have uh a bunch of numbers that are all near each other all the adjacent values differ by at most two there's the two there's the adjacent and so we get true and then we have an example that says uh same numbers but a different k this says even numbers that are two apart like three and six or five and two are supposed to be only two away from each other in quantity and that's not true so we get false and this last example um has ones and fives next to each other and that's bad all right so what are we going to do well um go through all the numbers this is what this says well actually this goes through all the indices so we get all the positions within s we're going to get a range of other positions and it's called near which i think is an indication that these are the numbers that are kind of just before it why just before it well it goes up to but not including i and then we have an if statement and some big gnarly expression that we need to fill in and then we return false so this general structure which says for a bunch of examples if we find something is true then we return false otherwise after we've gone through all the examples if we never found something that proves it false then we return true is kind of a typical structure for checking some condition about every position in a list or something like that so you go through all the positions in the list you look and see if the condition is violated if so you're done and if you never find such a problem then you have decided well it's stable so what is this condition we're going to look for we're going to look for two numbers and where the difference is to be so the way i would think about this is to say let's pick an i we're gonna go through all the i's so let's pick uh i equals 0 1 2 3. and this is an example so if i is 3 then we need to be able to detect that 5 and 2 are too different from each other so what are we going to check for all the other values j we're gonna have to check one and two check compare s1 to s3 and compare s2 to s3 so that helps me figure out what my range is if this is three then i need to go from one to three which i think is i minus uh what's that is it k or n n magnitude and k is how far you go now um we kind of don't want to go off the beginning so it might be worth saying i don't want this to ever be smaller than zero and john can you explain why you're not going in the other direction like why are you only looking backwards not forward oh good question yeah so this would only look backwards um and if you check each number and everything before it since this is kind of a symmetrical check that's the same as checking each number and everything after it so you kind of don't have to do both even though the condition is described as pairs of elements it's it's fine to get all the pairs of elements by taking each one and then the ones before it we could have also changed the range not to start at zero we could have started at a k because there's no reason because the first then we wouldn't have to worry about that max but i think it's fine the way it is too uh yeah i'm sure there's other ways to write that okay so now we need to figure out how to check for this condition well let's see what we have we're building a list comprehension that says yes something greater than n for j in near so j and i are both gonna be bound in this expression right here i was bound up here to three j is bound down here to one and we're trying to figure out whether that pair of indices causes a problem and that problem would be if the absolute value of the difference between s i and s j is greater than it so this expression is going to give you true if there's a problem and it's going to check each index in turn for all the different js one and two in this case if any of those is a problem then there's a problem with the whole sequence so that's why we will aggregate with the any function which takes in a list of true false values and tells you whether any of them is true if any of these differences is bigger than n then the whole sequence is not stable then someone asked if i could explain the near part again yeah so near is supposed to i is already set for us and so it's gonna go through from zero to one to two to three to 4 for these examples and for each of those ending values we're going to consider other numbers that are nearby and we need to come up with a range of indices for those other numbers and we do that by computing how far back do we have to go from i if we went back to zero that would be too far the condition is only about stuff that's nearby and then i think it's worth just thinking about examples so if i is three when i is three then what we really want is a range from one to three so we can get i'm doing this example this center one so that we can get 2 and the 3 and compare that to the 5.
if i is 1 then we really just care about the 0th position so that would be a range from 0 to 1.
if i is 4 then we care about a range from okay so i is four we care about comparing that to the three and the five that's index number two and number three so we really wanna go to two and three and so like you can just think about each of these examples and figure out what's a general expression that describes the first number in all of these and the second number is always just i the next question was whether there were any good resources for learning how to think logically because solving these problems isn't just about knowing the mechanics of the programming language you also have to think logically about how to solve the particular problem yeah let me before i i don't know about a lot of resources but let me point out a few things when you're solving these problems i think there's a tendency because of the way the educational system tends to work is to favor and reward memorization right like i've seen this problem i see the problem again i know the answer done and a lot of mathematics frankly is taught that way and it's pretty bad and so the thing to take away from these problems is not you know this is how you solve this problem but it's the logic for example that john just gave us that said there's a really nice construct here where you check something if anything returns false then you are done otherwise you return true so what you're going to see in a lot of these problems it's not about solving stable it's about the constructs that we use it's how we put together the constructs and the conditionals and the variable assignments and all of that so part of the part of the goal here is to really um um separate yourself a little bit from the actual details of the problem and think about the overall structure of how we're putting these pieces together and then what you'll see is that those are what generalize across problems you'll see themes over and over again right so you know there's a finite set of problems we can we can specify but what you'll see is that the underlying structure is pretty similar well you'll see patterns across that is what i should say maybe john has suggestions for other resources yeah i thought that was a good explanation i don't uh know of any resources about logical thinking that are like really great um most people learn it kind of by working through a lot of problems in this course and it's not uncommon at all that it is not something that just comes easily but practice does seem to help a lot and there are relationships between problems just as honey said i think that's uh that's true that as you kind of work through more of these problems you just recognize like oh this is pretty similar to something i've seen before and if it's something you haven't seen before well sometimes you can just kind of work it out on the fly and sometimes you can't and so that's why uh practicing a little bit beforehand just to have seen some similar problems is a good way to prepare okay so we're gonna look at uh spring 2020 midterm two question two part b and try to focus on the question of you know when you make a recursive leap of faith um does it work i guess and what can go wrong so uh we've already let's say solve this power which takes positive integer and returns whether s is a power of the base okay and now we're gonna do implement powers a generator function which takes positive integers n and k it yields all integers m that are both powers of k and whose digits appear in order in n oh fantastic so what does this mean you look at the digits that you're given one two three four five and you can take subsets of those digits like just the two and the five and if that's the power of five then that should be part of the result doesn't sound easy but we can take a look so we are filtering basically like when i see filter i assume this is about find all of the ways in which you can build up numbers just by taking digits of n and then we're gonna filter them to have only the ones that are a power of k so this will worry about the power of k and this will find all the numbers that exist within it so let's just worry about the numbers that exist within n and talk about kind of building that up recursively so there's this notion of a seed and this seed is i think the digits that we still get to work with if there are no digits then there are no then we can still build one number which is just zero otherwise we're going to go through something and uh do something with it i guess now we have to find some recursive structure and i think the recursive structure is that if you take a number like this you could find all the numbers within it by finding all the numbers in one two three four and then for each one of those either stick a five on the end or don't so that will give you all the different possibilities is that if you find all the numbers within n divided by 10 all of those are also oh sorry not n build or seed in c divided by 10 then all those numbers are also in seed but there's another number within seed which is what you get when you put the last digit of seed on the end of whatever x is by the way this is i'm going to come back to steve's question in a second we've seen this many many times exactly this construct where john is peeling off a number with the integer division and then creating the base so that that's another pattern that we've seen over and over again for this type of manipulation yeah exactly and the recursive leap of faith happened right here where we're kind of trying to list out every possibility so we assumed we had a way for listing out all the possibilities if i just had a smaller number one two three four and assuming that works then i can start putting uh different variants of that so if i find 12 in there then i want to yield both 12 and 125.
and notice here too that john did something very clever at the beginning where he went all the way to the bottom said ah there's a filter so what must be happening is i'm going to generate all possible solutions and then narrow them down into the ones that satisfy the constraint um so that that makes it a little bit easier up top and now we now he has to do some hard work yeah okay so now let's look at the filter now build has given me everything 12 13 14 134 and in there somewhere is the 1 and the 5 and the 25 and 125.
these are all powers of 5. so i need something that's only true if uh i call it on a power of 5. well that's exactly what the is power is that what it's called is power function that i implemented in part a does but is power takes two arguments and by currying it i get to fill in one argument and then wait until the other argument is available so the first argument i'll fill in is k and then what filter is going to do is it's going to call basically it's going to call is power k on every element of build n leaving us only with the ones that are powers of k yeah life is so much better if you fix fixate on an example so if c is this then c divided by 10 is that and then the hard part which is what happens when you build one two three four well you get one and two and three and four but also twelve and thirteen and fourteen and also 123 and 124 and also one two three four and also zero and also 23 i don't know if i said that already but that's the thing that's the leap of faith is to say build is gonna give me all those possibilities and then all i have to do is like stick a five on the end or not yeah good question so it's about lecture and about um using sets and why they're fast i guess um the built-in set has like two useful properties one it gets rid of repeats but the more useful property is about its efficiency which is that figuring out whether something is an element of a set happens in what's called constant time so if you watch the efficiency lecture this means that it doesn't scale with the number of elements that are in the set so if you have 50 elements in the set and figuring out where something's in there takes about as long as if you have 5 million elements in the set and this is achieved through a technique called hashing which you get to learn about in 61b got to leave something for 61b so that's like one of the topics that we don't cover in this course but you could read about it if you want and um it's a wonderful technique so basically anytime you're trying to figure out whether some thing is in a group or in a set um you want to use this particularly efficient technique which is called hashing and um and it's built in to the set but we haven't really talked about how to re-implement it you'll do that in 61b um yeah so we have an implementation in this project which comes up with the um number of elements between here and here is that what this does oh yeah there are five and six and seven so if instead of writing this code and using sorted lists we instead had two sets that one and that one then uh i could there's a built-in functionality for taking the intersection between two sets i can get the length of that and now i have a fast overlap that didn't take a lot of code okay so here's an optional question from lab write a function reverse other that mutates a tree said 3 is input and we're going to change it such that labels on every other odd depth are reversed so if we start with 1 2 4 3 then we reverse the order of the 2 4 branch and the 3 branch and so uh oh actually we don't reverse the order of the branches we just reverse the order of the labels themselves so the branches are still the same structure except for we've uh changed the two and the three to be three and two oh it says notice that the nodes themselves are not reversed only the labels are okay and here's an example okay sorry i gotta get all these zoom things out of the way um so how might we do this well um well okay so when you're doing something that's like every other depth you really have two choices one is track what depth you're on this is a good good way to go and another is to only process even depths and then you assume that the level below is an odd depth so we could do it both ways i don't know if if you all have a preference but let's try this this notion of process only the even depths so we assume that t is either the whole tree or it's a branch of a branch meaning another even depth that would be depth two or it's a branch of a branch of a branch of a branch that would be like depth four that's one way to do that okay so um one way to solve this recursively would be just to focus on the first odd layer that would be um the labels of the branches and then make recursive calls to handle all the other odd layers so the labels of branches would be b dot label for b in t dot branches if uh t is a leaf then there are no such things so i guess we can just return at that point um otherwise we want to get the reversed labels of branches so there's various ways to do it there's a built-in reversed function i think maybe the uh well this is a fine way to do it we can practice some of the stuff that we've learned in earlier lectures so reversed is something i can call on labels of branches and then i kind of get them in the other order now the tricky part is that i have to take each branch and i have to find the appropriate label for it so in this example now i have which example should we do let's do this example we've got two and six and eight now we have an iterator over eight and six and 2 and that's what we're supposed to slot in as these labels so we have to go through in parallel the branches so we can update their labels and the new label values and we did in fact learn about a built-in function that does this called zip so this would go through every branch and every new label that we get by zipping together tdot branches and the reverse labels and now we will set b dot label to be its new label what about the recursion well we don't actually want to call reverse other on the branch because then we'd have an odd branch as t so instead what we want to do is go through all the uh grandchildren and call reverse other on that this would be grandchild sorry [Music] i'll probably do the trick let's try it oh it doesn't fit now it fits nope uh probably we need to know what a tree is yeah it works um you are supposed to know what zip is but it's kind of an esoteric topic and you should know what reversed is but we could actually try to solve this without reversed and without zip just fine we could instead go over indices and that would be a fine thing to do so if we did something like for i in range of the len of b dot t dot branches we would then find the appropriate branch and change its label to be the label in the like reverse position one way you could write this is negative i or if you wanted to be more explicit you could write len of branches minus i uh oh but it doesn't work yeah so oh is it yeah something seems wrong but i don't know what it is uh let's see if we can fix it real quick oh name error b is not defined oh it's a boring problem so this needs to be t dot branches oh see we were in the wrong line of code nope no what's wrong uh it didn't reverse oh no you're going this is just the wrong index yeah we're going to fix it so this is n minus i or while you don't have n so if this is zero this needs to be negative one yeah it's uh oh i see yeah yeah and this is one this needs to be negative two yeah so it's oh it's really negative i minus one yeah classic off by one error the next question was what does super do when you have a class that inherits from two different classes well good question so if you use super on a class that inherits from two different classes what have you built you built something very strange but basically what you've built is it's the same object except for it's going to not look up things in its class it's going to look at them up in one of the base classes and which one well it looks at them in the order that you inherit so if you have a class that inherits from both b and c it's going to look in b first and then it's going to look at c to find the corresponding attribute that you're looking at all 18 midterm two number six implement replace which takes two non-empty linked lists s and t as well as positive integers i and j with i less than j it mutates s by removing elements with indices from i to j and replacing them all with some other list t afterwards s contains all the objects in t so a change to t would reflect reflected in s as well t may change as a result of calling replace okay so it's okay to change t and we assume s has at least j elements so what's going on here if we had printed this out it would say three four five six seven and then we replace elements from two to four so that's the five six elements that's element two and element three but not including element four so now we have three four something something seven and what's that something something well it's the elements in t the zero one two so we're left with three four zero one two seven instead of three four five six seven and this is supposed to demonstrate that if you change t t dot rest of first equals eight that's changing the zero one two to a zero eight two this is also changing s so now we have three four zero eight two seven whew uh well i think this is not gonna be that quick but let's take a look if i is greater than one then we're kind of not where we need to be to make the change i think is the story there because with the linked list you can kind of only change the first thing and the rest but um things later on you'd usually handle with recursion so oh i can use pdf annotation that would work much better can you not see my screen anymore uh we see your screen but no annotation yet john now we have it so if i is greater than one then i think we need to just kind of move on it's the same thing as replacing the rest of s with t with a smaller i and a smaller j so how did i get that well basically like replacing two to four with an s is the same thing as replacing one to three within s.rest that was the idea there okay so we've kind of moved forward into s until we find the place where we're gonna make this edit we've found this place where uh i equals one is i ever zero no positive integers i okay so now we basically know that i is one and that means we're going to make some edits this says k times or sorry j minus i times so uh kind of the length of the part that we're removing which would be like four minus two okay so we need to remove two elements we need to remove the next element and we saw this in lab as well you can remove the next element by changing s dot rest to be start rest.rest so what did this do this just remove element at index one uh okay so um just like in lab that's how you get rid of the elemented index one we're doing it a bunch of times j minus i times in order to kind of get rid of all the elements that we want to get rid of okay now we have an interesting expression n equals t while something n equals and rest i think what we're doing is we're finding the last element in t yeah how would we find the last element in t well we'd start at the beginning and then if we haven't reached the last element then we move forward in t by calling end equals n dot rest how do we know that we've reached the last element if end dot rest does not equal link dot empty so it might be that t only has one element and we've already reached the end in which case we need to make no updates but if not then we need to continually go through end until it really is the end until there's nothing after it meaning the rest of it is empty now we found the last thing in t by the way when you see that end equals n dot rest that's basically i equals i plus one you're incrementing through a list that's a classic how do you make your way through a list yeah exactly great great point and and so now i think uh we found the end of t we know where we are supposed to be splicing in this t which is right at the position one within s because i is one remember so we're going to change s dot rest to just be t but what about everything after like what about the old s dot rest that's supposed to appear after t which means we can change the end of t to be everything that used to be in s dot rest i don't want to sign this one i don't know it's it's you can consider it artwork john i think you should sign it when you're done there we go so um you know let's think about this example what we did is we had three four five six seven we kind of worked our way past the three until we just had four five six seven and i was one then we got rid of the five so we had four six seven we got rid of the six we had four seven and that was called s in our recursive call s was the link for seven now we found end n started out being 0 1 2 then we went to the rest so it was just 1 2 and then we went to the rest and we found that the end was this link 2. and then we made the following updates after four comes t which was zero one two and after two comes whatever used to be after four which was seven and then we ended up with three four zero one two seven think about it uh imagine you have a train that's connected uh you know all the cars we essentially deleted a bunch of cars and now you have two pieces and you have to splice something in so that requires two splices at the front and at the end yeah so that's basically what's happening here that's why i have to keep track of 