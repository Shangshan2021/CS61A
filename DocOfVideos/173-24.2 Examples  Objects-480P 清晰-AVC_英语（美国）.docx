Let's look at an example of using the object  system. Here's something to remember. When you   look up an attribute by name on an instance,  you find instance attributes before you find   class attributes. And if you don't find the  attribute on the instance, you look in the class,   If you don't find it in the class, you will  look in the base class. And in this way,   class attributes are inherited. Here's an example.  Let's say we have a class of worker. The worker   greets others as 'Sir', has a constructor that  sets an attribute elf to the class worker,   has a method work, which returns the greeting  of the object passed in itself plus 'I work',   and finally, has a special method __repr__. And  this __repr__ method is used to display what a   worker instance looks like when you're running  an interactive session. Now, this __repr__   string is very weird. And instead of doing  anything with self at all, it takes Bourgeoisie   and returns its greeting. The Bourgeoisie are  the landowners, the ones who own the means of   production. And so instead of working themselves,  they gather wealth by employing their Peons. To   work, they say, I gather wealth. Jack is a worker,  John is Bourgeoisie. And here we've assigned the   greeting attribute of Jack to be 'Maam'. If  you want to work through this problem yourself,   from Fall 2014 Midterm 2, here are some of the  prompts. Let's go through exactly what happens   when we execute all of this code. So the first  thing is that when we have a class statement,   its body gets executed immediately and so it  creates a new class called worker, where there's a   class attribute greeting which is valued at 'Sir'.  This isn't an environment diagram. This is just a   sketch of what's going on. The Bourgeoisie  class inherits from worker and has its own   greeting 'Peon'. In this case, you don't change  the greeting of the worker. It's just that if we   looked up the greeting for a Bourgeoisie instance,  it would find this before it found that. Then   these two lines create a worker instance and a  Bourgeoisie instance. The worker instances created   and then passed immediately into the constructor  where it gains an attribute elf, which is bound to   whatever the name worker is bound to. And worker  is the name of the worker class. So elf value   is this whole thing, the worker class. John gets  created because Bourgeoisie does not have an init   method. It inherits the init method from Worker.  So we look up, is there an init in Bourgeoisie?   No, there's not. So we look in the base class,  and we apply this one which has the same effect.   So both Jack and John have the same elf. Finally,  we have the line jack.greeting = Maam. If we just   looked up jack.greeting, we'd look here and find  there was no greeting. So we would look in the   class and the answer would be 'Sir'. However,  attribute assignment has the rule that it always   assigns immediately to the object to the left of  the dot. So the effect of jack.greeting is that   now Jack will have its own instance attribute  greeting bound to 'Maam'. Jack greets people   as 'Maam' and the other worker greets people  as 'Sir'. Now let's go through these examples.   Worker with parentheses after it creates a new  worker instance. Here we invoke its work method,   which gets the self.greeting for the newly  created worker. The worker doesn't have a greeting   instance attribute so we look in the class and we  find 'Sir'. Adding 'Sir' to 'I work' returns 'Sir,   I work'. Okay, Jack is a worker. When I just  write Jack and then evaluate that expression,   it evaluates to this worker instance. But we want  to be able to display that as a line of text.   That's how interactive sessions work. And the way  they work is by computing the repr string for the   object, that's the value of the expression. So  what's the repr string of Jack? Well, Jack is a   class worker. Worker has this special method name  __repr__, which is exactly what gets invoked every   time you want to display an object. So what does  it return? Well, it returns Bourgeoisie.greeting.   Here's the Bourgeoisie class. It's greeting is  'Peon'. And so what we'll see here for Jack is   Peon. What about jack.work? Jack is a worker,  the work method return self.greeting + I work,   or self is bound to Jack. Jack's self.greeting  is specialized, it's 'Maam'. So what we get here   is that self.greeting evaluates to 'Maam' at that  ', I work' and you get 'Maam, I work'. What about   john.work? Well, we look up the work method in  John. The instance doesn't have one, but the   bourgeoisie class does have a work method. And  what it does is it prints the result of calling   the work method of Worker on self. Self is John.  Okay, the work method on Worker is this work and   so we're going to print out John's greeting, plus  ', I work'. And what is John's greeting? Well,   John doesn't have a greeting instance attribute,  but his class does and that class has the reading   attribute 'Peon'. So we print out Peon, I  work. After that's finished and printed out,   this returns 'I gather wealth'. So what we see  is Peon, I work 'I gather wealth'. Now this one   has quotes around it because it's a return  value. And so we're trying to write down a   repr expression that evaluates to the same  string that was returned. Peon, I work does   not have quotes around it because it was printed.  Printing a string does not print the quotes around   the string, it just prints the contents of the  string. Finally, we have john.elf.work(john),   what's going on there? When we look at John's  elf attribute, which is the worker class,   the worker class has a function work. So this  is the one we're calling and we're calling it   on John. So we have to look up John's greeting,  which is 'Peon'. We looked at that already. Add   that ', I work' and we get 'Peon, I work' as a  string. When you return a string, you see it with   quotes around it. That's the representation  of a string that evaluates to that string.
