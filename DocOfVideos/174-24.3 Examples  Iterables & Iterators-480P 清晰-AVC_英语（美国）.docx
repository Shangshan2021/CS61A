Let's look at some examples of manipulating  iterables and iterators. And let's just focus on   using built-in functions, and list comprehensions,  and dictionary comprehensions, in order to perform   some moderately complicated data manipulations.  These are things that can be done in a line or two   if you use the tools correctly, and manipulations  like these often show up as the core part   of some larger problem. So I'm just going to lay  a bunch out there and then I would recommend that   you pause and just try them out on your own. And  then we'll walk through them one by one together.   So here's an example. What are the indices  of all elements in a list s that have the   smallest absolute value? So if I have a list s,  the elements with the smallest absolute value   are -2 and 2. But we want their indices.  Indices in a list start at 0. 0, 1, 2, 3,   4, 5. So here are the smallest elements and  absolute value and their indices are 2 and 4.   So how would we take this list as input and have  this list be the output? Or if this list is the   input, the smallest element by absolute value is  the element at index one. We're trying to list all   of the indices, corresponding to the smallest  elements by absolute value, so we get a list   containing 0. There's the first exercise. I'm just  going to go through them all. What's the largest   sum of two adjacent elements in a list assuming  that the length of the list is greater than 1?   So here's a list. If I sum these two elements, I  get -5, that's not very big. Sum these two, I get   1. If I sum these two, I get 6. So the answer here  is 6 is the largest sum of two adjacent elements.   Here's a similar list, but I fiddled with the  negative signs. And in this case, we don't get 6,   we get -2 at the end, that's not what we want. We  can get a positive number 1 by summing together   3 and -2. So that's the biggest thing we  can get by adding together two adjacent   elements in that list. Alright, another one.  Create a dictionary mapping each digit d   to the list of elements in s that end with d,  or d as an individual digit. So if I have this   list of integers, I'm supposed to create a  dictionary that says here's all the elements   ending in 1. Here's the elements ending in 3.  Here's the elements ending in 4. Here's the   elements ending in 5. Notice there are two of them  5 and 55. There's only one for 8 and one for 9.   And finally, does every element equal some  other element in s? So given a list, is it the   case that every element equals something else?  Well, -4 only shows up once, so that's False.   But here, 4 is there twice, and 3 is there twice,  and 2 is there twice, so every element equals   at least one other element. So this would give  us True. So if you want to pause the video and   work through some of these, I recommend that.  Now we're going to go through and solve them.   Okay, for the first one, what are the  indices of the elements in list s that   have the smallest absolute value? We're going  to start with this example, try to work it out.   So here's s. Smallest absolute value is not the  min of s. But it's actually not the min of s using   key=abs either. That would give me the element  in this that has the smallest absolute value.   It wouldn't give me the smallest absolute value.  So if my goal is to actually get the smallest   absolute value, I would need to first call abs on  each element, and then take them min. Which I can   do by mapping abs over s. So now I have the min  absolute value. What can I do with it? Well, I   can find all the indices, or the absolute value of  the element to that index is equal to this min_abs   value is equal to 2. This is different than  finding all the elements with that absolute value,   which I could do with a list comprehension. If I  wanted to know all the elements x for x in s if   the absolute value of x is equal to min_abs,  that would give me both the 2 and the -2.   But that's not my goal. My goal is to find the  indices. And for that, I need to go through   for i in, not s, but a range of len(s), which  gives me all the index values for s. And we   adjust this expression accordingly. We actually  want just the index values and we have to adjust   this expression accordingly as well. We want to  know if the absolute value of s[i] is equal to   min_abs. That will give me the numbers 2 and 4.  So there's a two-line solution to this problem.   Whenever I use a list comprehension, I could also  use the map and filter built-in functions. So I   could have rewritten this by first defining a  filter function that takes in some index and   tells me whether it's one of the indices that I  want to keep. Then if I take this same range of   indices, and I filter it using f, I almost  get what I want. But this is a filter object,   if what I really wanted was a list, then I would  call list on it, and I'd get the same correct   result. So I could have replaced this expression  with this expression, and gotten the same thing.   Okay, let's go on to the next problem. What's the  largest sum of two adjacent elements in a list s?   And here, we're using the same s that  we had before. Were meant to get 6.   There are two reasonable ways to do it. One is  to think about indices. range(len(s) will give me   all of the indices. But range(len(s-1) will give  me almost all the indices. Here it is as a range.   If I go through almost all the  indices, just leaving out the last one,   and I compute s[i] + s [i +1], then I'm  summing together two adjacent elements for   every pair of adjacent elements. And I'm leaving  out the last one because there's no i + 1   for the last element. So that's why I use this  shorthand range. Okay, this just gives me what   all the sum of adjacent elements are. If I  want to know the biggest one, then I should   just call max on that. So there's another use of  an aggregation function in order to do the work.  Okay, so we're done with this, you're  copied in there and call it a day.  Another way to solve the same problem, though,  is with zip. So if I zip together s with s,   I get a zip object. And what are the elements  of this zip iterator? Well, let's list them out.   They're giving me an element from  s along with an element from s.   These are not adjacent elements.  They're just the same element.   But if instead, I had zipped all but the last  element of s, with all but the first element of s,   now I have five elements here and five  elements here. And when I zip them together,   I see all the pairs of adjacent elements. So I  had built two sequences, -4, -3, -2, 3, 2, and   -3, -2, 3, 2 4, zipping them together gives  me a list of pairs. What happens if instead of   listing out the contents? I add together the  elements in each pair. a + b for a, b in zip.   I get those same sums of which the max is 6. So  there's another way to solve the same problem.  Okay, let's try another one. Map each digit d  to the list of elements in s, that end with d.   The result is a dictionary. So we're going to  use a dictionary comprehension. This one's going   to get a little bit long, so I made some space.  It's a dictionary where the key is a digit and the   value is a list. The list contains all elements  of s that end in that digit. So we look at x,   figure out its last digit, and see if it's  equal to d. That's a key-value pair in the   dictionary. We want one of these for every digit,  for d in range 10 would give me all the digits.   But notice in this result that there's  no 2 because there's no element in here   that ends in the digit 2. So I need to filter  out some of the d's. We want to keep a d   if any of the elements in s ends in d.  We can use the built-in any function.   Any of the elements in s ends in d is expressed as  any element ends in d for all the elements in s.   So this is the filter clause. Here's what  we're iterating over the digits 0, 1, 2,   3, 4, 5, 6, 7, 8, 9. And for each digit that  has this property, here is what we're building.   Now, to figure out whether this actually  works, we need to set s to be this value,   and then evaluate our big expression, and look,  that's what we get. So one implementation for this   would be just to return that. And while we've  solved this problem, this looks like a pretty   long expression. So maybe we should be breaking  it up in some way. One way to kind of break up   this whole process and the steps is to  get the list of last digits in advance.   So what are the last digits of all the numbers  in s? Well, that would just be x % 10 for x in   s. Then we could rewrite this as is this digit  in last digits, and we get the same result.   It's only a little bit shorter, but at least it  only has one big gnarly expression instead of two.  Okay, next question. Does every  element equal some other element in s?   And here's an example s. One way to solve this  problem is to focus on some particular index.   So let's say the index 1, s[i] is 3, there it is.  We could figure out if 3 appears anywhere else, by   building a list containing everything except for  this. s up to i gives me everything through 4, but   not including the 3. s[i+1] on gives me everything  after the 3. So if I were to add those together,   I'd end up with everything in the list except for  that 3. We haven't gotten rid of all the threes,   we've just gotten rid of the element at index i.  And I can ask whether s[i] is in this new list   that doesn't have element i in it and it is, that  means that 3 appears somewhere else. So now that   we have an expression to check whether the element  in index i appears anywhere else within the list,   we could just check that for all the i's. Is  it the case that all of the following are true?   This expression, s[i] is in the rest  of s not including i, for every i   in range len(s). Let me just write  that all on one line correctly,   without forgetting the last parenthesis so  you can see what's going on. So that's one   way to solve this problem. But there are other  ways to reason about the same thing. Like,   let's say we didn't want to do it about indices,  we just wanted to look at the values themselves.   Well, one useful expression would be y for y in  s if y = 3, tells me how many threes there are.   I could get how many threes there are by taking  the length of this. Or as an alternative,   I could collect ones instead of threes and get the  sum in order to figure out how many threes there   are that way. But we don't care about how many  threes there are, we care about how many there   are of any particular value. So we could write the  same expression as part of a list comprehension.   I think this one might get long, where instead of  the 3, we want every x for x in s. What are these   twos mean? This means that there were two 4s,  that there were two 3s, that there were two 2s.   And then this is kind of redundant. There are  two 3s, there are two 2s, there are two fours.   If we want to make sure that each of these  is above 2, then one way is to say that these   are all greater than one. Another way would be to  compute them all, find the minimum value in there,   and make sure that that minimum value is greater  than one. Now you know that they're all greater   than one. So just two ways of writing that kind of  equivalent idea. And all we're doing here is just   counting the number of times that x appears in s.  And in fact, it turns out that that's built-in.   I could just say s.count how many  threes there are and it will tell me.   So I could simplify this a bit by saying I want  to know s.count(x) for every x in s. And it will   tell me that the smallest count there is two. And  since those are all greater than one, we know that   every element equals some other element in s. So  maybe that's the simplest way to solve this one.   Okay, and if we did this right, then  all of our doctest did pass and they do,   so it appears that we've solved  all four of these problems.
