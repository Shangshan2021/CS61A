Let's do some linked list processing. I'll  just show you a few exercises, you can try   to solve them on your own and then we'll work  on them together. How do we write a function   that tells us whether a linked list s is ordered  from least to greatest? The elements of this are,   the elements of this aren't. How would  you tell if a linked list is ordered   from these two greatest by absolute value?  So these are 1 3 4 are the absolute values,   whereas these are not. And why just absolute  value, we could have any key function that   tells us whether they're ordered after  you call the key function on each element.   Here's a classic exercise, create a sorted link  containing all the elements of both sorted links s   and t. So if I have sorted s and sorted t, how  do I create sorted s and t? And this builds   a new link list out of these two. But what if we  wanted to do the same thing but never called link?   Instead, we could take the original s and  t and mutate them in order to create this   linked list structure. How would we do it?  Well, instead of having the rest of s be 5,   the rest of s would be 1 4 5. You can pause  here and try to work these out on your own.   Now we're going to go solve them together. So  here's our linked list class down here, takes   up first and a rest, the rest is empty by default.  And how do we check whether something's ordered? 1   3 4 is ordered 1 4 3 is not. Well, there, we're  going to use recursion. Checking the first two   elements are ordered and check to make sure that  everything after that is ordered as well. If   it's the case that s is link.empty, or s.rest is  link.empty, then this thing is definitely ordered.   Because it's only got zero or one elements,  there's not enough there to be out of order.   If it's the case that s.first is  greater than s.rest.first, that's the   element at index zero is greater than the element  of the next one, then they're not ordered. If you   don't know that it's ordered, and you don't know  that it's not ordered, but you do know that the   first two elements are ordered, then you have to  just check everything else. Return ordered s.rest.   Now, this gets a little bit more interesting if  you allow for a key function to tell you what   values you really want to think about ordering.  So are we ordering the values that are there?   Or are we checking the order of the result of  calling abs on these? So abs 1 is 1, abs -3 is 3,   abs 4 is 4. 1 3 4 are ordered. So this would be  true using a key function abs. We're using this in   much the same way that key is used for sorted or  min or max. We'd have to add in a second argument.   By default, it just has the identity function.  But if you pass in abs, then that's the   condition we should check. Is it the case that  abs(s.first) is greater than abs(s.rest.first)?   Well, that would handle the absolute value case.  But we want this to be generic enough to handle   any possible key function. So we just replace  abs with key. That means by default, it will take   the identity function. But if you want, I could  take the abs function instead and apply that.   Alright, let's look at the next one. Merge  return a sorted list with the elements of   sorted s and t. So when I merge together  a and b, 1 5 and 1 4, then I get 1 1 4 5.   If s is link.empty, then the merged results  should just be everything that's in t. If t   is link.empty but s is not, then I think the  merged result should be everything that's in s.   Now we know that there are elements in both s  and t, so we can compare s.first and t.first.   If they're equal, it doesn't really matter  what order you put them in. So we'll just   put less than or equal, but we'd be  equally correct if we put less than.   And here we're going to create a new linked  list that starts with the smallest element,   s.first, and is followed by the merged version  of everything else in s and everything in t.   This result has everything in s. There's the first  and there's the rest, and it has everything in t.   Otherwise, if t.first is the smallest element,  then that's what should be the first element of   the result. We still need all the elements  in s and we need the rest of t as well.   And what about merge in place? The idea  here was that we started with a and b.   We called merge in place, and we got all  of the elements in a and b in sorted order,   but we never call link. Well, in fact, the  implementation is almost the same as this.   Base cases are the same. But instead of  calling link, what we need to do is change   s. So that s.first is not the same, but  s.rest is. What would that look like?   Well, instead of returning a new link, we're  just going to return s, but we're going to   change s.rest to have everything in s.rest and  everything in t as part of it. And likewise,   if t has the smallest element, and that's the  one we're going to return, but we're going to   change its rest to make sure that it contains  everything in s and everything in t's rest. Let's   