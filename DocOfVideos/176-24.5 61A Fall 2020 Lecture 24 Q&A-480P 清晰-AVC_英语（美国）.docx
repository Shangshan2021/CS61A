lecture 24 q a although i don't think any of the queues were actually about lecture they were all about past exam problems okay here we go so this is a mock mid-term from spring 2017 which you could find on the resources page and number four you are an apocalyptic society and have been charged with making an engine or a generator that computes all of the n perfect numbers however in this apocalyptic society built-in and user-defined python multiplication is forbidden in any form okay so we cannot multiply you have a blueprint for building a few engines from a natural number generator so here are some perfect squares and here are some perfect cubes and this blueprint is supposed to help us figure out how to make perfect squares i think by adding together odd numbers for a while so if you add together the first three odd numbers you get nine i think that's what i'm supposed to be reading from this all right let's see how we're getting these cubes what's that second row doing john uh is it the sum of the two no well it's definitely sums of things yeah but uh but there's a gap that's interesting what's that gap doing there uh we skip multiples of three maybe this is one of those annoying like math problems isn't it uh maybe they're skipping every third one so this is one two skip the three four five skip the six seven eight seven nine okay and then uh once you have done that still not clear why that's particularly useful what kind of question is this if we add one and seven we get eight yeah i saw that and what's 20s and if we add 1 and 7 and 19 then we get 27.
okay so if we do this operation of summing up every other one then we get the cubes i see but what's the yeah i see the every other one to get from row two to row three yeah yeah it's kind of the same pattern as you had in the two gen case yeah but what's row two yeah well row two i think is this uh so this appliance operation except for ah um you don't skip every second one you skip every third one right so after discovering this mathematical pattern which we did not formally know about and it seems like a lot to ask for uh a midterm but i guess a mock midterm it's okay because here it is okay so now it's your job to build the perfect engine and power society out of the apocalypse good luck okay so we have natural numbers can i say if there's an apocalypse i'm not going to be making an end generator i'm just saying this is a ridiculous promise okay so so we have this notion of skipping um which uh i bet is important so let's say we already have a bunch of numbers maybe they're the natural numbers maybe they're some other sequence and we want to skip some we're not quite sure what n means yet but we'll try to figure it out okay so if this says if n equals one meaning take every one then i think you just yield from jen otherwise you're gonna have to skip some okay so uh if you're taking every one then you just yield from jen otherwise you got to only yield every other one or every two out of three or something like that what a strange question i still am not totally sure what create skip is let's see if we can figure this out yeah the comment says a generator that yields all natural numbers might be helpful right oh that's the that's how we start with the the base sequence oh yeah i see i see i see yes yeah i'm not sure but now we need to like build up these tiers you know yeah uh so we need to skip something i think we need to we need to skip every end yeah uh starting with our trusty natural numbers and then wow while n is greater than one we need to decrease it so presumably for the square that only happens once and then the cube it happens twice that's the one two and then three yeah yeah so the way you describe the second sequence from the first is you're summing everything you've seen in the first sequence but you're skipping every nth one so we might as well start at zero and it's not time to skip yet we're gonna go through all the elements in gen if it's time to skip then we don't really want to do anything at all i think but we do need to change skip back to one otherwise we need to change current to be whatever it was before because we're kind of taking sums as we go plus the element in the sequence skip increases and we can yield the current i can't actually promise this is right i think that's the basic idea is that there's like some pattern or basically you're summing as you go but you're skipping some elements along the way so if i'm summing everything from 1 2 3 4 5 6 7 and yielding the sums then i'd get a pattern that's like go through all the elements add to the sum so far and then yield the sum that i have so far except for here we're not summing all the elements we're summing every other element so we have some mechanism that says keep this one in but skip that one keep this one in but skip that one so if n were two meaning we skip every second one then um we would start with skip equals one which means we're not going to skip the first one but then we'll add one to skip the second time through skip will be two which is in so we'll skip the second one switch skip back to one and then we'll do it again austin confirmed that john is a rock star because i think it looks like it's right miraculous yeah good question so what's what's cur equals curve plus lm a better name for kerr would be sum so far yeah and it starts out at zero and then it's not about indices it's about the total that you've seen for all the numbers so far yeah that's a bad variable name okay so what's going on with this while loop and why is this n greater than one well i kind of just extended from these two examples and hoped that it would work for anything else i mean i have not thought at all about perfect uh what's next after cubes quads quads or whatever so i'm just guessing this pattern extends but what i saw here was that you have to kind of do this sum and skip operation once for squares and you have to do it twice for cubes and so uh when n was square we wanted to go through and do this once that's why i got n greater than one feels like it's a little too early for that question that's a rough way to start let me tell you so this is a question from the summer 2020 practice midterm question three called close which takes end smallest and d and a sequence is near increasing if each element but the last two is smaller than all elements following its subsequent element that is element i must be smaller than elements after it but not just but you can ignore i plus one so it has to be smaller than everything except for maybe the next one implement close which takes a non-negative integer n and returns the largest near increasing sequence of digits within n as a number okay so we're treating n as a sequence of digits and the arguments smallest and d are the parts of the implementation which we get to use if we want okay so we can use recursion and we basically get to pass in three things and something called smallest and something called d and they have these default values but when this is actually used then we just like start out with these at 10 and maybe we'll change them later in the recursion but yeah for example if you want to find the largest sequence what does it mean a larger sequence this is basically largest integer where when you look at the digits there were digits within here and they have this property of being near increasing which means one has to be smaller than everything after it except for maybe the five which happens to be right next to it if n is zero it has no digits i think that therefore we need to return something with no digits now we have a recursive call that says uh close n divided by 10 smallest d uh no seems like a hint to me to say we're not using the last digit in in n and that seems clear from this expression so um this kind of hints at a recursive strategy let's think about the strategy first then we can think about the code a recursive strategy would be either you use the last digit or you don't if you use the last digit then everything before it has to be smaller than it because it's going to go with the end except for the thing right before it doesn't need to be smaller than it but everything before that needs to be smaller than it because that's how you get this property that like for every element everything after it is larger except for the element right after it this near increasing idea so uh i said that recursive decomposition would be either we use the last digit in the result or maybe we don't if we don't use the last digit i think life is pretty easy we just pretend it's not there and run the same operation on everything else that's um that's left over so it might be that the largest sequence within this number has no 7 in it at all and therefore it's just the same as the largest sequence within 98535 are there any examples of this no what a poorly constructed question but it is certainly possible that you wouldn't use the last digit of the input and and there just happened to be no examples of this but i think we could imagine that happening so for when might it happen uh let's invent a new case okay so if you have the one there then i think the best you could do uh with the one is so the biggest thing you could have is 71.
but without a one right you could have four five six seven which is even bigger that would have been a nice example for them to provide to us which they did not do um so yeah like you could ignore the one and then find the biggest increasing or near increasing sequence within the rest or you could try to use the one but if you use the one you have this constraint which basically says anything before the one before it has to be smaller than one at this point a student asked to clarify what the question is even asking so let's go back and just talk about what this question is asking you start with some sequence of numbers you start thinking about all the different numbers that are contained within it like one number that's contained within it is seven another one is 57 another one is just five another one is 837.
so it's asking you to consider all of these possibilities another one is 900 or 9557 or whatever and another one is 550 so if we just wanted to list out all of those possibilities life would be a little bit easier so like uh everything in n would be if n equals zero then there's only really one possibility otherwise we would have to either keep the last digit or not so we'd have everything in n divided by 10 is in n but then there's other stuff within n which is okay so let's say for for rest in everything divided by 10.
um that number is an n but there's something else that's in n2 which is uh if i stick the last digit on there so um here's just like a simpler problem which is yield every every number within n and notice here there's no john's not putting any constraints on the relative we're going to get a little bit more complicated in terms of the order but this is just all possible numbers inside in order dropping or including a number yeah yeah exactly and so here's only a subset of the possibilities i didn't write them all out because there just really are a lot um the question is asking you to find among all of these what's the largest one that has this kind of funny property where the digits are increasing meaning each digit is larger than the last digit except that you're allowed to skip one when you're when you're checking this so for element i it has to be smaller than elements i plus 2 and i plus 3 and i plus 4 but it doesn't have to be smaller than i plus 1.
so for example in this number this is element zero has to be smaller than element two and element three well there is no element three but if there were would have to be smaller than that but it doesn't have to be smaller than element one john i just noticed it's not asking for the biggest number it's asking for the longest sequence okay well the nice thing about uh integers is that the longer they are the bigger they are i mean saying longer sequence is actually kind of problematic because it doesn't tell you how to break ties or if they just said the largest one then it would tell you how to bring it up but yeah it should just be the largest one right because of the ties okay so yeah step one figure out what this question is asking step two since it's a recursion question try to think about how you would do it and here's the plan that i suggested it was one forget about the last digit and just uh find close of n divided by 10.
or use n divided by 10 n percent 10 the last digit and make sure that the everything before it forms a near-increasing sequence according to the definition and then at the end we'll just uh return whichever is longer among one and two so we just don't know which one is going to work out so we'll just try them both often times recursion problems look like this you're considering many possibilities break them into two groups decide uh what's the best thing from group one what's the best thing from group two and then compare them in the end and that's the best thing overall now we have to think hard about strategy two if i decide to use the last digit then i have to think about making sure that the rest of the digits i include before this one actually obey this property so it might have been the case when you make a recursive call that you've already included some digits the very first call hasn't included any digits but it might be that you're now calling close again after having included some digits and you kind of need to know what's the smallest thing that you've committed to already and if the smallest thing is smaller than the current digit then i don't think you're allowed to use it but if it's not if smallest that you've used so far is bigger than the current digit the kind of last digit of the current n john how are we controlling for we don't care about i plus one we only care about i plus two to the end well i think that's why we have two of these i think maybe we'll stick the most recent digit in here and smallest will not be the smallest digit we've seen so far but the smallest digit we've seen so far except for the one that we just saw right that's the best i could come up with okay so now we need to figure out what's the small what's close um something goes here something goes here we're going to multiply that by 10 we're gonna add in this last digit look familiar it's a lot like this except for um what this is going to do is give us kind of the longest sequence that i could make if i included n percent 10 the last digit of the current n along with anything that i've committed to so far and then since i'm looking for the biggest one i'll just like take the max max of integers should basically do the right thing in terms of finding the longest sequence and if i wasn't allowed to do this then i'll return just the one that i was allowed to do which is ignore the last digit and use n divided by 10.
this is a doozy okay uh it's supposed to cop it's almost post-apocalyptic john except you can multiply here so you know it's not that bad so if i were thinking about this as just a loop then i would say um i need to assign d to be the digit that i just included and i would need to assign smallest to the smallest thing i've seen so far including everything in the like long ago part of the number and including the digit that i had just seen because now i have a new digit that i have just seen um but not including actually n percent 10 that will come later i think this would look something like min of smallest and d i got to tell you my confidence is not terribly high so before we try to yeah aaron is right this is not an easy problem okay well okay so it worked that increased confidence it really is moderately yeah this is a tough one um so yeah so what are the elements here whenever you're doing recursion you need to track some state like what's the rest of n that you're gonna process that part i think is fairly straightforward you carve off a digit each time and deal with smaller and smaller digits but in those recursive calls you had either decided in advance that you were going to put some digit on the end or not when you put a digit on the end then you have to pass information about that digit that you put on the end into the arguments of the recursive call in order to make sure that you don't uh do bigger ones along the way uh john there's a quick question in the chat about mixing return and yield my recollection was you didn't used to be able to do this but did they change that in python 3 yeah so mixing return yield is where um return kind of behaves differently it basically says stop the sequence inside of a generator function so you can write return and that basically means uh don't yield anything else after this which is a different notion of return than what you're used to which is why i would say like i mean i've never mixed them in any code that i've ever written but it is allowed yeah i think you can do it in python 3 but i do think it's a weird thing to do just conceptually okay let's let's solve a simpler one more complicated than this but less complicated than this let's get rid of this notion of near increasing and just uh look for the longest increasing sequence within n we would need to keep track of some notion of what's the smallest thing i've done so far um so what does this do return the sequence of digits within and sorry the largest sequence of digits within and that is increasing so how might it work if i call increasing on here's some digits let's see what we got we could have two then four then seven and eight that's pretty long try one more uh we could have three four five six seven that's pretty long i didn't check too carefully but it's about right how will we do this one if n equals zero return zero otherwise if um the last digit of n is less than whatever is the smallest thing i've seen so far then i might want to include it so i'm going to just write this as maybe i'll use n percent 10 in the result maybe not if and if the last digit is not allowed because it's bigger than something that i've already decided i'm going to use then i just can't use it so that means the best i can do is find the biggest increasing number within n divided by 10.
okay so now we're going to have this notion of no and yes no says i ignore n percent ten this is the same as that which is why this had kind of a funny structure we'll talk about that later it is important that when you're looking for the smallest thing within and ignoring the last digit you still respect how whatever digits you've decided to keep already along the way so you have to pass in this notion of what's the smallest thing i've already decided to use and then if you decide to use n percent 10 which is smaller than the smallest now you can still find more digits but they're not allowed to just be smaller than the smallest thing you had previously seen now they have to be smaller than n percent 10. it turns out that this could be simplified because we know that this is smaller than that so i could trim this down and i'd get the same result but i'm going to leave it like this just so we can compare it with the other thing in a minute and then here i would say well maybe i found the best thing without using this digit or maybe i found it with using this digit works for my two examples must be right that was a joke because it might not be right but i think it looks okay so uh so what now if you can understand this then you can eventually understand this but i agree that like close is just a much like a considerably more complicated version of increasing so i would focus on understanding this first what's going on here let's just look at the mechanics we either use one or we don't in the in the choice where we don't we just kind of pretend it's not there and then we either use six or we don't and in the choice where we don't we just pretend it's not there and then we either use eight or we don't in the choice that we do now we have to make sure that everything else that we choose from here is smaller than eight so we're going to have eight in the end but we make a recursive call that is i want the longest increasing sequence within eight seven two four seven you know everything that's left over except for all of the digits there have to be smaller than eight and that's how i got this number so if that makes sense then look at the difference between this and that the difference between this and that is that like we're just tucking away the most recent digit and we're gonna include it in this notion of smallest one step later than we otherwise would so you're allowed to ignore the five when you're checking to make sure that one is small enough because that's just the rules of how this works here's uh we're in spring 2019 midterm two question four we're not going to solve the whole problem we're just going to talk about a particular assignment statement and it's strange behavior so a student observed that if you have l dot rest comma l equals l.ref.rest l.rest.rest you actually get different behavior than if you switched the order of l and l.rest here here's the reason the way you execute this statement is you evaluate everything on the right like we said and then assign the results to everything on the left um but when you assign to everything on the left you do do it in order so you're going to be changing l.rest and then you're going to be changing l which turns out to be different than changing l and then changing l dot rest because l rest will be a different thing than it used to be if you change l first this by the way is exactly why i don't like the simultaneous assignment operators even when they're straightforward i find them a little evil i just prefer to have it sequential i never ever use these simultaneous design operators and my perspective is a little different i think they're great as long as you have you know different unrelated names on the left but here is a particularly diabolical thing where you have l dot rest in l which is referring to a part of a hole but if you change the hole first then you're talking about a different part like a part of a different hole than if you change the part and then you change the whole yeah i think this would really only show up if you were changing an attribute and you were changing the name that you were using to refer to that attribute at the same time which you know i think it's a fairly rare scenario but here it is good question so um the question here is in the fall 2017 midterm two we're not going to do the whole thing we're just going to analyze if you have a garden instance and you look up its smell and you call that which one do you get do you get the instance attribute or do you get the method and the answer is you get the instance attribute this is a general property of python's object system which is that you always look for instance attributes before you look for class attributes and if you find an instance attribute even if it's a function that's the one you use so it's not like functions are special in any way you're really evaluating this expression first which is if i have a garden what's its smell and you look for anything that's an instance attribute and if you find a smell there then that's the thing you're going to 