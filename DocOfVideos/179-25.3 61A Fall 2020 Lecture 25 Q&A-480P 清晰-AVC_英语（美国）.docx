61a lecture 25 q a there were no questions about the lecture but there were some questions about lab homework and past exam problems one of my favorite things john about that video was the use of the vhs tape to play the videos during the talks wasn't that great yeah yeah that brings me back so back in the day by the way when we used to do presentations before we all had laptops we would um take pictures of our physical slides uh develop them as 35 millimeter slides load them into a carousel tray get on an airplane with that tray show up at the conference hand some guy that tray and they would literally put that tray on a carousel and like slip through it and without fail every single talk had like at least one slide upside down and the audience was all instead of doing this trying to see the slide that sounds excellent the good thing about that by the way was you know now when you go to conferences and talks everybody's on their laptop and device so back then there was nothing to do you just listen to the goddamn talk now it's hard to get people's attention yeah now at conferences everyone's writing their talk that's going to happen i like sitting in the back so i could see everybody else's talk being worked on i'm like what are we doing here if we're all working on our topics exactly i miss those days yeah i took one class from a postdoc who decided that transparencies were better and i think he was right like he had this huge stack of printed out transparencies and he put each one on the overhead projector and you know he'd ride on it as he was lecturing and it was very nice but i did get a panicked email to the whole department once saying my four foot high stack of transparency has gone missing it's like my life's work has anybody seen it i had the problem where i used to go to talks and every once in a while they were in a box and i would drop the box and the slides were like all over the place let's see if there's a real my favorite thing that i ever did this is what i did when i introduced my job at dartmouth so we had this problem with transparency it's called keystoning so if the projector was very close to the um the uh uh screen the slides would be really distorted because you were projecting sort of upwards yeah so i had three versions of my slides that i printed with the inverse distortion oh so when i put the slides down they were almost paralyzed people were just complete this by the way this is what what passed for high tech 20 years that will definitely get you a job that's amazing yeah and it was just a ho and then i had a slide showing it's just a homography oh by the way it's if you were if you were present for the first lecture where i talked about the license plates it's the same map that did the license plates very nice yeah all right okay so we're in lab nine question four number of binary trees where you're taking in and it tells you how many different binary trees have exactly n leaves and it points out that there is a closed form solution i think unbalanced parenthesis which is unacceptable but uh there it is so this closed form solution let's see what that looks like uh oh it's just pointing to the wikipedia page that says like there happens to be a formula for this thing all right well michonne's right that's not really acceptable um but the goal here is actually not to just write down that equation in code but instead to think about this recursively so just to get you started if you want to build a full binary tree with three leaves well you got to have some number of leaves in the left branch and some number of leaves in the right branch in this case there's two in the left branch and one in the right branch once you've decided how many are left and how many are right you can just use recursion to count up all the ways of completing the left branch the ways of completing the left branch is all the full binary trees with two leaves because we decided there are two over there and on the right branch that's the number of full binder trees with one leaf because there's a one there and so either both of those can be counted with a recursive call so the basic idea is you decide okay i'm looking for three leaves okay so it could either be uh zero on the right three on the left one on the right two on the left so on and so forth and then once you've established that for the top level well then everything else is just recursive and then i don't know how to do this non-recursively by the way it's not obvious to me yeah i mean there's this formula but you know yeah but besides that that's uh that's all i mean it looks like a recursion problem um now i mean i guess what's interesting here is that it's an unusual way of combining the two recursive calls so uh you know we can talk about this for just a minute longer you know okay so if n is one then there's just one tree we saw that as as a demonstration right but otherwise let's forget the template for a little while we'd want to go through all the ways of dividing up and so uh for we've got to have at least one on the left and then what's the most we could have on the left well we could have up to n minus one so we'd go to range n how many left is this i think you need an i in there john or something and then how many on the right well the rest of them and then we um can figure out uh like uh the number of trees possible trees on left that's just a recursive call for the number of variables variable names are getting a little long okay well i'll trim it a little bit that was that was absurd [Laughter] and how about on the right well that's symmetric but then you do have to think about what you're going to return which is that if you have eight different ways of building left branches and five different ways of building right branches how many different ways are there of building a whole tree well you can take any from the left and any from the right so for any of the eight on the left you have five different options on the right so for the first one you have five for the second one you have five for the third one you have five fourth five four five so what's uh five plus five plus five plus five plus five plus five that's eight times five uh so um there's like a notion of a total which you get by multiplying together at the left and the right but that's just for one split now you have to think about all the different splits that you have so uh really we should have a total that starts at zero and this is just describing if we picked a particular number of leaves on the left how many total trees would there be and we need to add that to the total and return the total okay so now you can think about how to get that all in one line which you can do with uh with some uh you know we're making a sum of a bunch of different options and maybe there's a list comprehension in there somewhere but i just tried to describe why there's a product uh like a multiplication in the middle of this it's really because you're saying like i can take any one of the options from the left and any one of the options from the right and pair them together and that's how you get a full binary treat there's a good lesson here too is when you see these templates i always feel like you know i've got like one hand tied behind my back but when you're thinking about the problem you can break free of the template figure out how to think about the algorithm and then go back and shove it into the template um that's how i usually think about these problems you know when we talk about clever although i was teasing john a minute ago about his variable name there's a reason to do that it's not just good programming style it's particularly with recursion it sort of helps you jump over the cliff yeah because you can see what this thing if you believe that this is what it is well then that's what it is a follow-up question was why we're multiplying let's say that um i give you uh uh let's say a red let's see if this analogy works here i give you two things in my left hand and three things in my right hand yeah and i ask you what are all the ways of combining them yep well okay so i can take one thing from the left hand and put three things from the wait no that's not quite what i want is that right john yeah i think like if you have a b c in one hand and you have one two in the other hand yeah what are all the different combinations you could have you could have a1 a2 you could have b1 b2 you could have c1 c2 that's six things that's because it's three times two so like if you ever think about how to pair something from your right and something from your left what are all the possible ways of doing that you end up multiplying yeah so it's it's we're looking for all we're not summing them up so it wasn't like oh here's the answer for the left here's the answer for the right and it's the sum of them we still have to combine everything and we can combine them by picking all the different ones from the left hand all the difference in the right hand and doing all permutations of those yeah okay let's take a look at homework five question six which is one of the optional ones called yield paths define a generator function path yielder which takes a tree a value and returns a generator which yields each path from the root of t to a node that has that label called value t is implemented with the tree class and each path should be represented as a list of the labels along the path in the tree you may yield the paths in any order oh and they gave us some starter code see what they did so i guess we're gonna have to make this one big we have an example tree here um so one is at the root two and five are its children three and four are children of two oh sorry three four and five are children of two and six is a child of four um and then when we call pathfielder on six it finds this one path to six which is that you have to go from one to two to four to six okay then there's the list but since there are two different fives then we need two different paths the one two five path and also the one to five path it says like uh iterate a little bit so um sometimes you find that the label of the tree the root label of the tree that you're on is equal to the value you're looking for if so i think it's time to yield a list containing just that label or just that value equivalently so that would handle the case if we were doing path yielder of one and we wanted that uh list containing just one like a really short path that's only got one element in it the other thing is that this will allow us to build up longer lists because we've returned a list that's got the right last value in it and then we're going to have to add stuff onto it to get the full path that we want okay so we're going to go through every branch for each branch it might contain a bunch of paths to this label we're looking for and we need access to every one of those paths in the branch so that we can then yield paths in the whole tree here's an opportunity to use recursion if i call path yielder on the branch and the value i'm looking for what i get back is a path through the branch but what i really want to yield is a path through the tree and so i just write that down i want to yield a path through the tree which is everything through the branch but it also has the label at the front might be something like that nope probably need a you know when the two is not defined it's saying yeah you know what a tree is okay that works next we did the spring 2020 midterm two question number one so this question involves plunking the leaves off a tree one by one a tree with unique positive integers no repeated labels a plucking order for a tree is a sequence of unique positive integers that are all labels of t and a valid plucking order if uh the plucking order has all the labels in t and there's something special about the order the labels for each note of t appears after the labels of its descendant nodes so you have to pluck the leaves and then you can pluck the appearance of the leaves and then you can pluck the parents of the parents of the leaves etc okay uh i think we probably have to do a in order to do b so let's just do the whole thing implement order which takes a number tree called redwood it returns a valid plucking order as a list of numbers if there is more than one valid plucking order your order function should return any one of them oh how nice uh so we have something that's empty uh it's called redwood for some reason instead of t but redwood.branches um it seems like we can just get a plucking order for the branch and add that to our plucking order you have to know which method to apply if you have a list already and you're trying to add a bunch of elements from some other list then the way to do that is with the extend method okay all right here's the question you actually asked about b implement pluck which takes a number tree called pine okay and returns a function that is called repeatedly on the elements of a plucking order if that plucking order is valid the final call returns success otherwise if one of the repeated calls is on a number that is not part of a valid plucking order the error string says hey not valid interesting so we take a tree we then get a function back we start calling it on numbers if they are a plucking order let's see what happens i plucked the nine then the eight then the seven and the six i can't plucked out one yet because it's got stuff still but i can pluck the five and the four and the three and the two and then one is bare i could pluck the one at the end and then it would tell me success but if i ever try to pluck something out of turn then it says hey not valid okay cool what a beast this is probably the longest problem we've ever seen on a midterm let's read it together uh here's the function that we're going to return and we return it right away so the only reason that we're returning this function is because it has as its context the tree itself so we can refer to the tree that's good we have this notion of pluck one leaf which takes in something return a copy of cyprus oh it takes in a tree without a leaf k and check that k is a leaf label not an interior node label okay so this is the moment where we build a new tree that's kind of like the old tree except for we've plucked off one of the leaves and then okay so however this does it we'll figure that out later we say non-local pine which is interesting i think non-local pine is gonna mean we're gonna change the tree we're talking about to one that has its leaf plucked off if pine is a leaf then um [Music] it makes sure that it's the right label and then tells us success otherwise we need to change pine to be the result of plucking a leaf off of the current tree if is instance pine stir oh this says if plucking a leaf caused a problem that problem is a string that says something like wow you screwed up oh hey not valid and so we'll return that otherwise we return the same plucker function that we had before because we're just going to call it again all right so uh it seems like pluck one leaf has to not only build a new leaf that uh has one less um leaf sorry build a new tree that has one less leaf in it but it also has to sometimes return a string that says we screwed up all right so let's uh figure this out in a second but this says if plucked branches equals okay so we're gonna go through all the branches and build new branches there's some condition under which we skip a leaf and if we don't skip this leaf then we pluck a leaf from the branch um and this might be a string and if it's a string then we're done otherwise we probably put this into our plucked branches append the plucked branch so this is how you build a new treat as you'd have a new list of branches you'd go through all your old branches and you'd put in the new branch which is like a plucked version of the old branch um and then at the end we'll build a tree and that tree is just um the old tree cypress dot label with the plucked branches i feel like we're getting close what does it mean to skip the leaf well it has to be a leaf i think that's a method we'll check it in a second and it has to have the right label what's it called oh not value okay why k k is the next value we're supposed to pluck sounds about right so this goes through checks all the branches gets rid of the one that we're supposed to pluck and um if it's impossible to pluck it for some reason then it tells us so but we still don't have this case where we're supposed to return that something has gone terribly wrong when would that happen i think that would happen if you um if you look at the root of cyprus and it turns out that that root is the k as opposed to a leaf being a k so here i'm assuming cyprus is not a leaf itself and if it's the case that cyprus dot label equals k that's bad why am i assuming cyprus is not a leaf well let's see where we call it we call pluck one leaf um here where we've already checked that this is a leaf and handled that case so we know the initial call to pluck one leaf is on something that's not a leaf and then where do we make recursive calls well if this thing's a leaf then we're gonna skip it so we must be calling it on a not leaf here miraculous that's the understatement john uh well it helps that i did once upon a time write this question apologies to all students whoever had the ticket oh man you put this on an exam well it was an experimental exam the experiment didn't go very well so this is the first time that we gave people an interpreter and i thought that might help them a lot it turns out it didn't help them very much um that's a good homework problem though and yeah i mean you know the key to this question is really understand what you're trying to do it's not about like memorizing some pattern you've seen before but instead just focusing on uh you know like what exactly is the process that i'm trying to describe with the code but the reason this is you know it turned out not to go well uh is that there's all this like error handling of strings and that turns out to be hard to process but but at least i ain't now giving you a description of why it is the way that it is yeah good question so how would you approach a question like this and especially if you read some part and you're like i don't know how this part works well i mean i hadn't looked at this problem in quite a while um so it did feel a little bit new to me although uh not entirely new because i wrote it but um i wasn't sure what was gonna happen in here when i was reading the skeleton so i kind of just skipped it as i was going and i had this idea in my mind that that we'd like have a tree and we'd like remove one of the leaves and then we'd have another tree and we'd remove a leaf from that like and i was wondering how's that gonna happen and like i have a function to do it but this has to be called many times and so i ended up skipping ahead to here to try to look for the mechanism that involves just like removing one leaf at a time and doing it over and over again and this part i think wasn't um wasn't so confusing to me whereas this you know upon skimming it it seemed like quite a beast because there was a bunch of blanks and uh you know now it looks reasonable but uh but it didn't at the beginning um but this idea that we would kind of keep track of the tree that we were plucking from and then pluck leaves from it i guess that is one entirely separate question from how exactly you go through and get rid of a leaf so i think in a really big question like this um looking for ways in which you could solve one part and solve another part modularly might make it more manageable okay so let's take a look at this this is fall 2018 question seven a trictionary is a pair of tree instances k and v that have identical structure each node in k has a corresponding node in v the labels in k are called keys each key may be the label for multiple nodes in k and the values for that key are all the labels of all the corresponding nodes in v okay so k can have two labels that are the same and if you uh want to know all the corresponding things for two well you'd have to look up the corresponding labels c and a in the v treat and so that's why we see here key 2 has two values a lookup function returns one of the values a lookup function returns one of the values for a key specifically a lookup function for a node in k is a function that takes v as an argument and returns the label for the corresponding node in v okay so remember v is a tree here uh so a lookup function takes the whole v tree and tells you which label to get or like gets one of the labels and returns it implement the generator function lookups which takes a tree instance k and some key it yields all lookup functions for nodes in k that have key as their label the new lookup function is part of the implementation okay so oh i said that other thing was really big but this is big too okay so i think we should learn how this works you call lookups on some k tree which is this one that's given to us as an example and some value like two it gives us back a generator over two functions each of those functions takes this entire tree in but the function knows something about like what path it's going to follow and so it gives you the corresponding value for some particular position in k so calling f the first f gave us c and calling the second f gave us a so this question is all is kind of a mixture of traversing trees and also dealing with generator functions and higher order functions so it's synthesizing a lot of topics in this course but i don't think you have to like discover how to do it so much it's like lookups is going to go through and find paths to the number two but it's going to encode those as functions and those functions are going to go find the same path through v and give you the the corresponding label okay so how will lookups actually work if something yield a function that takes in uh [Music] okay the whole tree and does something with it otherwise we go through all the branches and we make a new lookup um for everything in here interesting um these lookup functions like f they take a tree and they have to somehow get you all the way to a label that you want i think the simplest case is if what you look up is at the top so if it's the case for that k which is a tree's label is equal to the key that i'm looking for then that means the the corresponding value labels right there at the root so if i took in a tree full of values i would want to return the one at the root otherwise this key that i'm looking for could be in the branches somewhere and so i'm going to go through all the branches but this doesn't go through the branches it goes through them by index for some reason well we see the reason is that we use the index here um and we've got a hint here that we need like a lookup function already and then we're going to build some new lookup function that basically uh uses this i somehow so i'm going to put in a sketch of what i think might work and then we'll take up new lookup and see what it does i think if you want to introduce this name lookup um really we're going to have to go through all of the different times that key appears in this branch and get a lookup function for it that sounds like uh use of recursion this is i guess quite similar to the problem we just did where here we're not going to look it up in k but we're going to look it up in a branch of k can't type well we're still looking for the same key that we were looking for before and this says yield a new lookup so let's think about what this function would do this function would look through a branch of v and find the corresponding values that match the key but we want to look through all of k and find the corresponding value so we build a new function here it is that takes in the whole tree v it has to uh look up within one of its branches i the label that we're looking for where i'm assuming here that assuming f is a lookup function for a branch of v so what does new lookup do basically like if you have a way of looking from here and finding or sorry let's do it over here if we can look from here and find the a what we're building is a function that can look from here and find the a that's what this does and then how are we building all of the functions that find both the c and the a well we're going through all the different branches so here's this branch this branch and this branch and then we're going through all the times that i found the key in this branch which is only here and here i'm taking the function that knows how to look through here and find the corresponding c and the function that looks through here and finds the corresponding a and building new functions that can look from the top of b oh that was a mess questions yeah great question so the question is you know when would you do this and how does it relate to everything else that you know um this is quite abstract but the following pattern shows up a lot which is that if you want to build something that is you know four things long you start with something that's three things long and you put something on the beginning or sometimes the end a linked list look like this you've seen this pattern when just using regular lists here we're seeing it using functions where a function could be representing uh most of a path and then we're building a new function that represents an even longer path basically just by like sticking something on the front now the way this function is implemented is by calling the function that represents the rest of the path and so if you call g you're kind of calling the whole path now why would you want to call a whole path well calling a path is like doing something with a tree in this case we're extracting a particular label from the tree um so in that sense it does look like the same concept you've seen before but certainly in a different way this is now using kind of the mechanics of functions to do what you could otherwise do with a linked list and um yeah and and knowing that you could achieve the same thing in different ways is part of computer science but it's it's this is like really a new thing that was presented to you on the exam as like a new way of synthesizing um existing ideas that you know you know how to use functions you know how to use linked lists you know how to use paths but here you're asked to kind of put them together in kind of a new method okay so let's finish up by explaining why yield the new lookup i look up again okay so um let's focus on an example the example will be when we're looking for the number three we have not found it at the top it never showed up here we did get one lookup in this branch and so if i call lookups on this branch um then i get a lookup function but i called lookups not on the whole tree but just on the branch and that means that the lookup function i got is really only prepared to process this branch of the corresponding v tree it knows how to take in this branch and find the s but it doesn't know how to take in this whole tree and find the s so we need to create a new function that is based on the one that knows how to find the s in this branch and can instead find the s in this whole tree that's why we call new lookup where i is the index of this tree index one and lookup is the function that can take this branch and find the s and then what we do 