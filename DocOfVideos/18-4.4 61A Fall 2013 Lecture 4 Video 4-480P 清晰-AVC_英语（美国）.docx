Higher-order functions are a feature of a  programming language that allow us to design   functions as we should, as I just described, by  expressing very general methods of computation.   Let me show you what I mean. So what we'd like to  do is to generalize patterns by defining functions   that take arguments that give us back the specific  instances of those patterns. So as just a general   example, let's look at how we compute the area of  geometric shapes based on their length. So here   are three shapes, square, circle, hexagon. And  the relevant length for each is the side length   for the square, the radius for the circle, and  the side length for the hexagon. And the area   of each of these can be expressed simply as r  squared, pi r squared, and 3 square root of 3   over 2 r squared. So what we're going to do is  look at these three formulas and find out what   they have in common and what makes them specific  to a particular shape. So it's these constants,   1, pi, the 3 square root of 3 over 2 that are  specific to the shape we're interested in. The   rest is just how you compute the area of a  shape. So if we find this common structure   among similar related problems, we could share the  implementation. All right, let's actually do that.   So here we are. We're going to write some code  about generalization so we can define a function,   the area of the square, of side length r by  returning r times r. And we can define the area   of a circle with radius r as returning r times r  times pi. And what's pi, well from math, we can   import the constant pi. And then we can come up  with the area of a hexagon with side lengths r,   which is return r times r times 3 times the square  root of 3 divided by 2. So now we're in business.   We can take the area of a hexagon with side length  10 and it will tell us it's a little bit less than   260, which is great. It will also tell us that  the area of a hexagon with side lengths negative   10 is the same thing, which is not quite right.  So what are we going to do about this? Well,   let me show you something. It's called an assert  statement. It starts with the keyword, assert,   and then is followed by an expression which is  a boolean context. If that expression evaluates   to a false value, then an error message  is printed to the user whenever they run   the Python program. So 3 greater than 2,  that should always be true. If it's not,   then math is broken somehow. So when this assert  statement executes and this is a true value,   then nothing happens. But if I said something  that is in fact false is false, then I will get   an assertion error and the message that I printed  out. So we can put in a search statement in here,   assert r is greater than 0, and then a message  if that's not true. A length must be positive.
Now that fixes the case for area square and we  also need to make sure that r is positive in   area circle and r is positive in area hexagon.  So I could copy this line and I could paste it   in here and I could paste it in here. But  then I would be repeating myself and I'm   not supposed to repeat myself. John told me  so. Okay, so what do we do about that? Well,   we can generalize these three examples by  factoring out the part that they have in common,   r times r, and also this assert statement that a  length must be positive. So we're going to define   a function called area which takes a length and  then it also takes a shape constant. It gives us   the area of the shape that we're interested  in. We're going to assert that both length   is positive. And then we're going to return r  times r times the shape constant provided. Now,   this function isn't necessarily that intuitive.  It certainly requires some documentation,   which I'll skip for now. But what it is useful for  this is for defining all of these areas square,   area circle and area hexagon functions that  we already have. So to take advantage of   a common implementation, we can just call  area with the appropriate shape constant.
So finally, we have area r then 3 square root of  3 over 2. So if I now execute this file and then   start an interactive session, I should be able to  compute the area of a hexagon with side length 10   and get the same result that I had before.  What if I pass in a negative number? Well,   I'll get an assertion error that a length must  be positive. We can also generalize not just over   numbers but over computational processes. So the  common structure among functions might not be just   the number like we saw with the shape constant.  It could be something more complicated. Here are   three different mathematical equations. One is the  formula for summing up natural numbers. So the sum   for k equals 1 to 5 of k is shorthand for 1 plus  2 plus 3 plus 4 plus 5, which is 15. And the sum   for k equals 1 to 5 of k cubed is a bunch of cubes  to 25. And here's the third formula. The sum for k   equals 1 to 5 of this expression, is these terms,  which sum to 3.04. Well that's interesting. We'll   look at this formula with more terms and we'll  see that it eventually converges to the number   pi. Okay, so we have three formulas. They do seem  to share something in common. So they only differ   in that this has a k, this has a k cubed, and  this has something complicated. Other than that,   they're all summing from 1 to 5. So it seems  that we have some general computational process   going on and then something specific about it  it. The thing that's specific about it isn't   just a number, it's an expression. Okay, we  can write code to generalize this as well.
All right, I don't think we need all this anymore.  So let's try to function some naturals, which   takes in an argument, a number of natural numbers  to sum and it sums the first and natural numbers.   So how would we use this? We'd call some naturals  on, for instance, 5, and we get back 1 plus 2 plus   3 plus 4 plus 5 is 15. So we can implement this  via iteration by writing total and k is 0 and 1,   or total is the sum that we're going to return  and k is which natural number we're going to   sum next. So while k is less than or equal  to n, the last number that we want to sum,   we are going to rebind the names total and k  to total plus k and k plus 1 respectively. And   then we will return total. Okay, now I have  a function that sums natural numbers. Let's   make sure that it works. Yes, it does. Next, we'll  write a function that sums cubes, def sum cubes.
Sum the first N cubes of natural numbers. How are  we going to call this? Well it would look like sum   cubes and then I would pass in some number such  as 5, and I would get back 1 cubed plus 2 cubed   plus 3 cubed plus 4 cubed plus 5 cubed is 225. The  implementation starts by binding the names total,   and k to 0 and 1 respectively. And then  while k is less than or equal to n,   the last number that we want to sum the cube of,  we will rebind the names total and k to total plus   the cube of k and k plus 1. And then we return  total. See how we did. Okay. So our test pass,   which means some naturals and some cubes do in  fact do what we'd like. Notice that there are some   similarities between these two implementations.  They're basically entirely the same, except for   this has a k and this has a pow (k, 3) cubing  the number k. So maybe we can do better. Maybe   we don't have to repeat ourselves. That is  in fact the case. Let's start out by defining   functions that represent the specific aspects of  some naturals versus some cube. So I'll define   a function identity which takes in a number k and  returns it right back. So the expression which is   a function of k that we sum here is just k itself,  whereas down here, to cube k, we will return k   raised to the third power. Now we need to write  the generalization over some naturals and some   cubes. We do that by writing a function summation,  which takes in the number of natural numbers that   we're going to sum over. And we're also going to  take in a term which is a function that tells us   how to compute each term of the summation.  Okay. Sum the first N terms of a sequence.
And how's this going to work? We'll call  summation, sum five terms and we have to   then pass in how to compute each term. For  instance, if we want to cube each term to get 225,   we use the name cube which is bound to a function  that raises k to the third power. Alright,   for the last time, we will repeat this logic  in its most general form. So we bind total and   k to 0 and 1 respectively. And then while k is  less than or equal to n, we rebind total and k   to total plus something and then k plus 1. Now  how do we get this something? Well, we have to   defer to the particular argument that we passed  in, the function that computes terms. A term needs   to be a function that takes in k and returns the  term that's the kth term of this sequence. So if   we pass in cube, we will get k cubed and we pass  an identity, we'll just get k. And then finally,   we return total. Alright, let's run our dock  test and see how we do. So it appears that we've   implemented this correctly. Summation 5 cubed  gives us back to 25, which means we don't need   this implementation at all. We could just return  to summation of n with identity. And likewise,   we don't need any of this. We just return  summation of n with the cube function. And   does everything work as it's supposed to work?  That's not what I wanted. It certainly does. So   it tries to sum cubes, it tries to sum Naturals,  it runs summation with the cube function,   and all tests passed. Ta-da! All right, let's take  a look at actually what happened there. So we try   to generalize over all of these things. We did it  for example by defining a cube function and then   defining a general method of computation called  summation, which takes in some number of terms   to sum and then a function which we'll call  term, which does the summing. Okay, so this is   a function of a single argument. Notice that this  function is not called term. It's called cube. It   cubes numbers. There is a formal parameter of the  summation function that will be bound to the cube   function, the function that cubes. So that within  the body of summation, we can refer to whatever   computes each term. Okay. So in term k, this call  expression actually calls the function that's   passed in and here and the call expression for  summation do we decide what function to apply to   k each time we want to compute a term. The cube  function is passed in as an argument value and   that is a higher-order function. It's a function  that takes another function as an argument.
