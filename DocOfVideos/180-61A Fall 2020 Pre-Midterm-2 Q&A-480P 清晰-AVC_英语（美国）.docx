61a q a right before midterm two so here we are we're going to talk about fall 2016 question seven which is kind of like a count partitions from lecture so maybe we'll talk about competitions uh and we'll talk about this problem but let's read the problem and see what we have to deal with and then we can review how to structure these what are called tree recursion problems now there's no trees instead it's the kind of the computational process that evolves from running the code that creates some tree-like structure tree recursion is about when you make multiple recursive calls within the body of some function okay so this has implement sums which takes two positive integers and in k it returns a list of lists containing all the ways that a list of k positive integers can sum to n results can appear in any order so for example if we call sums on four that's what we're summing two and uh we have to use exactly two numbers to get there and they all have to be positive then there's nothing that includes a four only stuff less than four so we have three plus one and two plus two and one plus three that's the story here um and um here we see that if something then we get to a base case otherwise we're building up the list so uh y is an empty list we'll return y eventually and y dot extend just takes some other list and puts all of its elements into y so we're just going to kind of like build that up as we go um i think you know with any recursive problem the first thing to look for is how can you decompose it into a first decision and then a recursive call that does the rest of the work so looking at this example i think one thing you could do is have your first decision be what's the first number in the list so we're going to come up with all these different lists but what's the first number in the list and then you can decide uh what are the rest of the numbers in the list and we'll have to ask ourselves like does the rest of the numbers in the list involve some recursive call or not yeah sorry honey sorry so steve look also at the the second example sums five three and notice that there are three examples with a one in the first position yeah one three one one two two one one three now look after the one the three one the two two and the one three and now look up that's exactly what that is yeah so that tells you that's a good indication that you're gonna do something recursive you're gonna you're gonna put the one in the first position and then just solve using only two numbers summing up to uh five minus one which is four yeah which is basically the recursive call from above well thank you [Music] great so now we've kind of discovered the recursive structure it's pick the first number and then make a recursive call to fill in the rest of the numbers and uh yeah if you pick three there's only one way to do it but if you pick two then there's two ways to do it two one or one two and then if you pick one then there's these three ways to do it so that should give us some indication about what the recursive call looks like if i'm building up a list of three numbers then my recursive call is about filling in the other two so we'll kind of subtract one from k and what do these other two have to sum up to well whatever the total is minus the first number that's the kind of rest of the recursive structure here so now that we kind of know what we're after we have to figure out how to write it um this for x in something i think is an opportunity to iterate over the first number possible values so that to me looks like a range where the lowest value is one and the highest value i'm kind of assuming here that there's more than one number we're going to add up and so uh we can't go uh all the way to n because then like we'd have some zeros in there and they're not allowed right we have to have positive numbers in fact you can actually calculate what's the biggest first number you can have based on n and k i think the biggest first number you have is when all the rest of them are one so to get there you'd start with n and then you'd subtract out all those ones um but you're allowed to have this number and remember ranges go up 2 but not including the last one so we get a plus 1 in there so when you have a complicated expression like this it's always good to look at an example what would happen if n was 5 and k were 3 well we get 5 minus 3 is 2 plus 1.
that doesn't look right at all oh because uh after this there aren't k numbers there's k minus one numbers so i think we really need like a plus two in there okay let's see if this does the right thing so we do five minus k gives us 2 but we really want to go up to 3 and this expression gives us 4 which is good by the way our killer right off my ones are killer but the way to deal with them is just look at examples i think it's almost always the case um so examples won't tell you the exact expression you have to kind of know what you're after we're kind of trying to make space for all those ones but then like have you done it exactly in the right way well then your second example by the way john would it have hurt if we just went to end wouldn't it have just fallen out eventually great question so what if we go to and i think we'd have to decide what to do in the base case yeah we don't really have room here for a base case that says i have an incompatible um n and k value like a negative n or a k that's zero um so uh yeah i guess that's something to worry about yeah okay but if we were writing this totally from scratch like there's lots of ways you could do it okay so then what happens um we're making recursive call to sums we kind of talked about what this would look like is probably there's a minus x value here we've put x as the first element and then how many more numbers are we gonna have in this list well k minus one so this got us to if x is three then our recursive call is going to be summing up to two one plus one is two um and then we have to think about what this returns so this is going to for example in this one if we make a recursive call with x equal to one we'll get one of these values back because we'd call sums for two when you're given one of these values back and you want to create this value you have to write some code that goes from here to here this thing the result of the recursive call is called s and this thing is the result of whatever expression i put in here so then i can think about how do i build 1 2 2 from 2 would be something like put x in a list and then add that to the values that are there before that's how you build a longer list from an existing list okay so what happens i guess the simplest case would be uh i think it would be okay to stop when and when k is one or when k is zero but you know k is one i think is a little bit more intuitive here so what happens when k equals one then i think there's exactly one way to do it we're supposed to return a list of lists so our result should look something like this we knew that by just reading the problem description but in this case there's only one way to build a sum of n using just one number and that's to put n in the sum uh great question so this uh kind of list of x plus s is that a common trend and when does it show up here's when it shows up is when you want to build a long list one element at a time then um you know there's two ways to do that really you could be appending things onto the end or you could be adding things onto the front um which one do you want well this addition operator makes a new list which is quite nice when you're doing recursion recursion gets very complicated when you start changing lists in the middle of it so if you start like appending to something then that usually causes more problems than you want um so addition is nice because it will create new lists every time you won't have to worry about accidentally changing s as you go and anytime you're building up a long list one element at a time basically like you have most of it and you're adding one more thing on then you'll see this pattern and this is the way to have the right kinds of values on both sides of the plus so if you have a list over here you need a list over here too if x is a number then you have to make a list out of it before you can add uh noah is asking i'm gonna work up through the chat the comments in reverse order no one's asking how would this return the empty list as in the second doc test oh good point this says uh what happens if you want to list all the sums from two to three okay so if we hit the empty list um this is not true right yeah we'll start with an empty list oh go through an empty range and we'll end up with an empty list i i will say like really quickly um that i think you'll get the same answer if you had that as your base case um but uh you do need to like have a base case where you're returning a list with some lists in it otherwise you'll run out of trouble questions like this are out of scope for this midterm you can ignore them um we covered this a little bit in the optional efficiency lecture in the past this has not been optional uh but this semester it is so if you see anything with like how fast does something run and you see like thetas or o's and mathematical expressions we just didn't cover that um in discussion in lab there was a lecture but it was optional won't be on the test but don't worry that your education is being compromised this will be covered a lot in 61b when you take it so you don't have to worry about it now you have three and a half years to understand big theta and big o lemon xv a lemon copy is a perfect replica of a nested list's box and pointer structure if an environment diagram were drawn the two should be entirely separate but identical so they don't share any objects but they look the same xv is a list that contains only ins and other lists the function lemon generates a lemon copy of the given list xv the is instance function takes in a value and a type to determine whether the value is a given type which is something we have seen so if i have a y and i call them and copy on y and assign that to lemon y i'm supposed to get the same picture but what's interesting is that it might be the case that objects are repeated in here um and so there could be like arbitrary interesting structures there so here's some examples if i start with x is 200 300 and then append x i end up with a structure that looks like this then i have y equals xx so i have a structure that looks like this and here's the call to lemon on y which gives this structure and here's a bunch of checks to make sure that they uh don't share any objects but um but have the same structure interesting this looks a little tricky so uh we're given x y there's a helper function that's called on x y i imagine this will be recursive as we kind of traverse the structure there there's this list lemon lookup and you notice it's outside of the helper which means every call to helper is going to have access to this same list and the name lemon lookup gives me a hint that maybe this is about figuring out whether i've rebuilt this piece of structure already or not so like everything that's in here i have to make a new one of somewhere here but i don't want to do it twice i don't want to like recreate this chunk twice i just want one copy of it so that might be what lookup is all about okay um if something returns something we'll pause there but my guess is when you get to a number it's probably time to just return that number you don't have to worry about whether two numbers are the same or different there's really only one five and um and that's really not an issue so it's only for mutable values like lists that you have to think a lot about whether you're creating a new one or not okay so here we iterate for old new in um the value that we're dealing with uh old new is a funny name isn't it okay we're making a new xv we're going to um append x pair into this lemon lookup list which keeps track of for my xv here is the new xv we're going to go through for every element in there and do something i think this is probably where we make sure that we don't make two copies of something and then we'll return the new xp so let's see if we can make some progress if something returned old new one i'm not sure why we would do that oh i think this is about going through the things we've already built for old new in lemon lookup if the old new zero is xb then we just return old new one so what's in here this is pairs of something in the original structure and new version of that thing okay i think that's what's going on here so if i've seen uh xv before then i just want to return what i constructed now i get to the point where i've never seen it before i therefore have to build something new um i'm going to make sure that i remember what i built and then i'm going to go through for every element in xv i'm going to new xv dot append the result of copying that and if it's the case that i get to an integer then i think i can just return that okay let me see if this worked and then we'll talk about it well it looks pretty good so um i think the the like interesting recursive part is here so let's just make sure that's okay this says and and like without that if we forgot all of this stuff and just said if i hit a number then i return that number otherwise i make a new list i go through every element in the old list that element might be another list with lists with lists in it or it might be a number i don't know what it is but i know i need to copy it so i call helper which basically is the copier and i append a kind of copy of that thing to this new list that i'm creating and then i return that new list so that's really the core of making a deep copy of a list that contains other lists which contains other lists and the only thing we've added here is to make sure that if i've copied something once i don't copy it again and so that's what this is is recording when i've made a copy i want to store it and then before i make a copy of something i check and make sure i haven't seen it before a good question so where is like is xv in lemon lookup it's actually this whole loop um it goes through each pair of something in the original structure and the new version of that thing in lemon lookup checks to see if xv the thing that i'm supposed to copy is the something in the original structure that i've seen before and if so then return the new version of that thing okay we're taking a look at lab nine question five generators generator and here's what it looks like right the generator function make generators generator which takes a zero argument generator function g and returns a generator that yields generators my goodness i stopped saying generator it was a little scary when i highlighted the word generator it showed up so many times it doesn't just stop here it's like down there too okay so for each element yielded by the generator object returned by calling g a new generator object is yielded that will generate entries 1 through e yielded by the generator returned by g so g is the input so basically like if g goes uh one two three then or i guess g goes zero three six nine then um we're getting generators that go zero and then stop and then zero three and then stop and then zero three six and then stop and then zero three six nine and then stop well and we got a nice short template here so we'll take a little work let's see if we can make some progress so um here's we make one of these and what do i mean by one of these one of the generators that goes for a while but not all the way up and we get as an argument some i which i think is good this is going to like tell us how far we get to go now what's interesting is that g might go forever so the the nice way you might think about this which is like get all the values in g and then start slicing it isn't going to work because here's a oh no this doesn't necessarily go forever this stops but maybe g could go forever so anyway that's the thing about generators is sometimes you don't want to like get all the values that are in them because there could be a lot so you kind of want to process them incrementally if you can um so at some point we have to get uh the contents of g a typical way to do that would be is g something we call oh on n and m so we make generator generators on this thing which takes no arguments so we have to be able to call this but i guess we know that it takes no arguments at some point we're going to call g and get all the values that are in it and so let's call that an x i kind of feel like we need to keep track of this like here's everything i've seen um and then for each element that i've seen i need to yield a new generator oh good question so what is 4x and g this says for a generator function get the get all the values that it yields and bind x to each one in order that's kind of the right way to interpret that so g all right go ahead like will it like read like like because i think when we learn generators like it it goes and then it stops after like each yield statement so does this like implicitly yield and then would it like start over once it got to the end or just stop a good question this will never start over this will only go through all the yields in g once and what this says is go until g yields bind x to whatever g yielded and then do this stuff and then after this is done go let g keep running again until it yields again x is now bound to the next thing it yields and do this stuff we need to pass in something um it's not clear to me why i need this eye yet but we'll think about it so we're supposed to yield a generator that goes through all the values in here um which is a for loop for all the x in scene i'm not sure why there's an if what a strange template okay i thought this was just gonna go uh uh i thought i was just gonna go like that and this is the land of scene hmm i wonder if this just works where are we yeah that works okay so now we can try to figure out why there's this other template and what it's supposed to do i guess um uh yeah another way to write this might have been if i equals zero just yield c in zero otherwise yield from gen i minus one that probably works too oh no that didn't work at all oh this needs to first yield c and i that didn't work at all either uh i mean it's like that oh now i got them backwards whew okay well there's another way to do it but neither of these ways fit the template um for whatever reason i guess the easiest way to fit the template would have been to say uh put a comment there john uh if false nothing here is cheating [Laughter] yeah print i know and then uh nothing here either [Laughter] oh what have i done right oh you didn't do the recursive call on jen i think right well this was supposed to be my boring version where it just kind of went through all right the elements oh this is supposed to be jj anyway um sorry i'm i'm a little lost on the template as well i'm afraid to say um but uh it seems like the the logic is a little bit simpler um maybe whoever was writing this problem wasn't thinking of creating a list of the values that you've seen so far and maybe there's some other mechanism to kind of track that implicitly but i don't see what it is yeah good question so in like a real program there is a slight speed advantage to not creating new objects so in that case like if you're going to build a bun a big long list one element at a time then appending is better than just using plus sign and making a new list each time um we don't worry so much about efficiency in this course that's more of a 61b thing so that means that you can kind of get the same result just by adding lists together and that's fine too oh sure so the question is about how you might reverse a linked list um so let's just say we have a linked list of numbers i don't know how exactly they did it in the lab orientation but we can talk about one way to do it so like originally you have that how is it that you would um reverse it no it's not supposed to be a arrow but you get the idea this is supposed to be the end of the list okay so um one way to reverse it is just to like keep the same link structure that you have but just change the values so you know you could find a way to swap the three and the one or something like that but i think that's probably not what they were after instead i think what they're after was change the link structure so i don't know how to get a second color but just pretend that things are disappearing as we go so basically change the list structure so that this goes here and this goes here and this doesn't go anywhere this is the end that will be a way to reverse the list but you'd actually have to end up returning this thing over here so uh you know this is gone and this is gone and um this thing over here is the result all right so we can try to write some code that does that we'll see how far we get the trick here as john is setting up is linked lists are incredibly fragile so if you don't hold on to as you start to rewire things you have to be very careful to hold on to the pieces because you start to break the links things can separate so the trick here is always going to be to make sure you're holding on to the pieces as you rewire so if we get an uh linked list with one element in it then i think reversing it is pretty straightforward otherwise we assume that we have at least two elements what are we going to do we're going to reverse everything else in it i think would be a good way to do it so uh reverse of rest is the reverse of s.rest which should have like recursively fixed up everything except for um yeah this guy isn't really part of it right now uh you know s dot rest last element would be empty because it would end there but you don't want it to end there you have to include this thing as well so so you could fix those last two links reverse of rest.rest equals s this thing is s and you'd want to change s dot rest to be linked empty but you wanna return the reversed thing what is the reverse thing this doesn't look right let's get some names i'm gonna do a little more annotating that's this that's just that rest this thing is um rev of rest oh i just texted her so i do think we probably need to keep track of this kind of stuff so this is like the original rest was uh s.rest that's this thing so now we have a new name for that as well uh now we'll go through and do some reversing so now we have a name for this um it's really the original rests rest that we want to change to be s the original s hasn't changed its rest should be linked that empty and then we should probably return the reverse of rest so if i have a linked list let's make it extra long and i reverse it oh something worked oh except we didn't really reverse it in place we just built the reversed thing by changing all the arrows the question is do you really need this or not i think the answer is probably no you probably could have just called it s.rest here as well but you know i thought it was a little bit easier to think about it the other way 