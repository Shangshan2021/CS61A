So far, you've learned about functions and data,  much the essence of programming. In fact, you've   mastered the fundamentals of the Python language.  So it's time to move on to a new language, Scheme.   And by learning Scheme, we'll see that many of  the ideas learned about one programming language,   easily transferred to another. And Scheme is  an older language that was very influential   in the creation of Python. So we understand  it for its history, its beauty, and also to   see which ideas transfer from one language to  another naturally and we'll find that that's   many of them. Scheme is a dialect of a language  called Lisp. And Lisp is one of the two oldest   programming languages that is still used today.  And it's certainly the oldest one that's rapidly   growing because more and more people keep getting  excited about using Lisp for new applications.   What are people saying about Lisp? Alan Kay,  the inventor of object-oriented programming,   said that it's the greatest single programming  language ever designed. My favorite sci-fi author   said that it's the only computer language that  is beautiful. And Brian Harvey once told me,   it's God's programming language. Even xkcd seems  to love it. Lisp is over half a century old,   and it still has perfect timeless air about it. I  wonder if the cycles will continue forever, a few   coders from each new generation rediscovering the  Lisp parts. These are your father's parentheses.   Elegant weapons for a more civilized age.
So hopefully, that gets you excited about   learning a new programming language. The beauty  of Lisp is its simplicity. The entire language   can be learned in a day. And yet it can be used  in order to build programs as complex as the ones   we've seen throughout this course or much more  complex than that. Here are the fundamentals.   Scheme programs consist of expressions,  which can be primitive to just 2, or 3.3,   or true, or + is a primitive expression, or  quotient, which does division, etc. And there   are combinations. So a combination looks like an  open parenthesis, and then some other expressions,   and then a closed parenthesis. And in this  way, we can express the quotient of 10 and 2,   which is 10 divided by 2 is 5, or we can express  through combination, that not true is false,   etc. So numbers are self-evaluating, but symbols  are bound to values. Call expressions look like   combinations. And they start with an operator,  followed by 0 or more operands all in parentheses.   So this is a little different than the syntax of  Python. Normally, we put the operator outside,   but here we're putting it inside. So let's  look at some examples. If at the Scheme prompt,   I type (quotient 10 2) and I get 5. Quotient names  the built-in integer division procedure. In Python   we called things functions, in the Scheme they're  called procedures but they're fundamentally the   same thing. You can nest call expressions. I could  say what's the quotient of the result of adding   together 8 and 7? Well, that's 15 divided by 5  is 3. And if I want to, I can spread these call   expressions across multiple lines in any way that  I see fit. Here's a typical way to use indentation   just to make the expression clearer. So this  says I'm going to add two things, the result   of this subexpression and the result of this  subexpression. And that's why they're indented   to the same level. Now, the Scheme interpreter  doesn't care about indentation at all. These   are here in order to make the program as readable  as possible for people. So combinations can span   multiple lines, spacing doesn't matter. Going to  new lines doesn't matter. All that matters is that   you close the parentheses that you open. The way  to read this is to say that we're adding together   two things. The first is a product of two things.  The first of that is 3 and then we need to add   together what you get when you multiply 2 and 4 is  8, and you add 3 and 5, that's 8 again, so summing   that together is 16 times 3 is 48. Okay, what  about down here, well I subtract 7 from 10 to get   3. And I add that to 6 so I've got 9, 9 plus 48 is  57. So this whole expression would evaluate to 57.   Let's do some more demonstrations. Here's a Scheme  prompt. I can evaluate 2, I can evaluate the sum   of 1, 2, 3, and 4 is 10. What happens if I add  together nothing at all, what do you think? 0. I   can multiply 1, 2, 3, and 4 to get 24, or I could  multiply together nothing at all. What? Okay, so   I can multiply together 2 and 2 and 2 and 2 and 3  and 3 and 3 to get 864. And I can nest this. So if   I then want to, let's say, subtract 1, I would do  it by surrounding the whole thing in parentheses,   placing a new operator at the front. And I can  not only subtract, but I can also divide, add, or   multiply again, anything I want to do. And  the result will be computed using the normal   call expression procedure. We'll first try to  evaluate the operator and operands and then I   apply the procedure to the arguments. So it's the  same story as evaluating Python. But this time,   we put the parentheses in slightly different  places. In addition to these arithmetic procedures   that are built-in, such as plus, there are also  various other procedures built-in. I can ask   whether something is a number. 3 is a number, + is  not a number. I can ask whether some number is 0,   2 is not 0, which is why we get false. But 0 is 0,  which is why we get true. If I actually subtracted   2 from 2, I would end up with 0, which is true.  And we can also evaluate whether something is an   integer. 2.2 is not, but 2 is. Now, these question  marks are just part of the name. The name is   integer question mark. And the reason the question  mark is there is that it's supposed to help you   figure out what the procedure does. So just like  in any programming language, we'd like to use   names that help remind us of what things are going  to do. And this integer question mark name is a   good reminder that this is something that returns  false or true, based on what its arguments are.
