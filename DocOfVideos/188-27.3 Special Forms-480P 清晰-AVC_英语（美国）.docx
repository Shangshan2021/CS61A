We haven't learned all of this Scheme language  yet. We only know about call expression so far but   there are other types of expressions. So they're  called special forms. A special form and scheme   is any combination that's not a call expression.  For instance, there is an If expression which has   a particular syntax, so it looks just like  a combination again. Except for it has this   special keyword if as the first subexpression,  and then it has a predicate, a consequence,   and an alternative that are all expressions. In  order to evaluate this, we first evaluate the   predicate expression, and then we pick based on  whether it's true or false, whether to evaluate   either the consequence or the alternative. The  consequent is like the suite of the if statement   and the alternative would be the suite of the else  clause and a conditional statement in Python. And   and or are also special forms, because while they  have a bunch of different expressions that we're   going to combine logically, they might not all get  evaluated. Because you can't figure out whether   the and of a bunch of things is true or false  without evaluating some of them. You can look   at the details of that when you do your project,  which will involve building a scheme interpreter.   An important special form is how we bind new  values to symbols and that's with define. So   we define some symbols to be the value of some  expression. In order to do that, we evaluate   the expression then bind it to the symbol. So if  I define pi to be 3.14, and I can use pi as the   symbol in future expressions. The symbol pi  is bound to 3.14 in the global frame. Yes,   Scheme uses the same model of environments that  we've been using in Python. You can also define   a new procedure with a define expression that has  a slightly different syntax. So you know you're   defining a procedure, when after define, there  are parentheses. And this combination is not a   call expression. Instead, it gives the name of the  new procedure, and then its formal parameters. And   then after that, we need the body. So how does  this look? Well, an example is that we can define   the absolute value procedure, which takes in some  argument we will call x. And every time abs is   called, it evaluates this body expression, which  says, if x is less than 0, then we return -x,   otherwise we return x. So this is the predicate  consequence and alternative of this if expression.   And if I take the absolute value of 3, I get  -3, I get 3. Okay, so this creates a procedure   and binds the symbol abs to their procedure in the  first frame of the current environment. And since   we're in the global environment, that's where it  gets bound. Okay, let's define some procedures   ourselves. So we can define what it means to  square something, is multiply it by itself. And   then we can square 16 to get 256. We can define  what it means to average x and y. Remember it's   okay to go to another line. It's totally up to  us how we indent or space things out. So let's   say that this involves adding together x and y  and then dividing the result by 2. So you do have   to be careful to close your parentheses in Scheme  because we want to make well-formed combinations.   So that one closes the define, at which point I  can average 5. Oh, let's do 3 and 7, and we'll   get 5. Now in Scheme, we already know how to  evaluate call expressions, and call expressions   can contain other call expressions. And it's okay  to define recursive functions in Scheme. In fact,   they are everywhere. Let's build one. Let's define  how to take the square root of x. How do we do   that again? Well, we have a bunch of updates. So  let's define an update function that takes a guess   and then gives us a better guess if we need it.  And what will that better guess be? Well, if it's   the case that the square of the guess is already  equal to the number that we're trying to compute   the square root of, then we really don't need a  better guess at all. We better stop the recursion   at that point. So this is a base case. And we'll  just return that guess as the value of the update   because we're done. Otherwise, we need a better  guess. And how do we get a better guess? Well,   we'll update something that's even more useful  than what we had before using the Babylonian   method that was invented many thousands of years  ago, where you're going to have a better update   to the square root of x by averaging your current  guess and what you get when you divide x by your   current guess. Okay, so we'll close the define,  we'll close the average, we'll close the update,   we'll close the if, we'll close the define. And in  order to actually take a square root, we'll start   with a guess of 1 and update that. And update,  we'll update it again until the square of guess is   in fact x. Close the define, and now we can take  the square root of 256 and get back 16. So we've   used a lot of features of the language already.  We have a square root defined here. Within there,   we've defined an update, and Scheme, like Python,  is lexically scoped. So within the body of this   inner function, we can refer to the name x, which  is a formal parameter of the outer function.
