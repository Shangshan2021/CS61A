So we went through all this work to come up  with a general version of summation   and we use it to some natural numbers and cubes.  But what about the summation of those terms that converge to pi?  Well, let's do that too,  interactively.  From operator import mul.  Step two, we'll define a function that computes each term of the sequence that converges to pi.
Let's call it a pi term, which is a function of k, and returns 8 divided by 4 times k minus 3 and 4 times k minus 1.
Recall summation. Let's sum a million terms  of these pi terms. And what do we get?  3.141592, and that is wrong. It's an approximation, but it got us pretty close.  Okay, one more example for the day. We're done with this. We'll clear this out. I'm going to show you how   to define a function that returns a function  as a value. This will be called make adder,   takes an argument, which is a number. We'll  call it n. and it's going to return a function.
This function will take one argument, we'll call  it K, and return K plus N. So what does that mean?   That means we can create new functions on the  fly. Like, we'll create one called the add three,   which we'll get by calling make adder on the  number 3. Once I have this function add three,   I can call it on some other argument such as 4 and  it will add 3 and 4 together to get 7. So part of   this function that we create called add three  is that it remembers that three was the thing   that it adds. Now how do we define this? Well, we  define adder, a function, with formal parameter k,   which returns k plus n, just as I said in the  dock string. Now, let me - oh, excuse me. Let   me tell you the structure of this. We have one's  def statement here, which within it has another   def statement. Now this return line is part of  the body of adder. Whereas this return line,   as you can see, is part of the body of make  adder. So make adder returns a function, adder   just returns a number. And the interesting thing  is that adder can use names that are its formal   parameter and the formal parameter of make adder,  the surrounding function. So that was an example   of functions as return values. When a function  is defined within another function's body and   the function that's created is bound to a name in  a local frame. So here's the code for make adder   which we just saw. Make adder is a function that  returns a function. In the duck test that I wrote,   add three was bound to that function that was  returned. Now we have a local def statement here,   def adder (k), which can refer to names in the  enclosing function. So n is bound here, k is bound   here, and both k and n are available in the body  of adder. What happens if I type something like,   make adder (1) (2)? These spaces are just here,  extra space. Well, what you're looking at now is   a call expression. With an operator, that's also  a call expression. And an operand, which is just   a numeral. So an operator is any expression that  evaluates to a function which is exactly what we   get back from make adder. And an operand is  an expression that can evaluate to anything.   So how do we evaluate this? Well, we evaluate the  operator, which is a call expression, which means   we have to evaluate its operator. Getting our make  adder function, its operand giving us 1. And then   we call make adder on 1. And what we get back is  the adder function. So we have the adder function   available to us. What's it going to be called  on? That's 2. So this adder function is going   to add together 1 and 2 to give us a value of  3. So let's see this in action. Python3 - ix.py,   make adder (1) (2) gives us 3. Make adder (2000)  (13) gives us 2013. But I can also do this in two   separate steps. So I can say make adder (2000).  Now I have a function and I can call on 13.
So what's the point of all this? Well,  first of all, we've shown that functions are   first-class values. Meaning, they can be passed as  arguments, they can be returned as return values,   just like any other value in our programming  language. A higher-order function is a function   that does these things, takes another function  as an argument, or returns a function. Now,   higher-order functions are useful because they  can express general methods of computation,   how to sum things together without worrying about  what I'm summing together. They remove repetition   from our programs because we only needed to  define the act of summation once. Finally,   we can separate concerns among functions. We  want each function to have exactly one job.   And having higher-order functions allows those  jobs to be very general methods of computation   or their functions which they take as arguments  or return as values can be much more specific.
