Now I'll talk about three other special forms.  These are going to be covered in lab and   discussion. And they'll show up in homeworks  in the next project. So you'll get exposure   to them eventually. But I'll give you a preview  now, just so that you know what's coming. First,   we'll talk about cond and then begin. The cond  special form, or cond that's short for condition,   is like having elif clauses or a big  if-elif-elif-elif-else statement in Python. So in   Python, you can have one statement with multiple  different clauses. And you can have as many elifs   as you want, as long as you start with an if. And  then there's this optional else at the end. And   you could achieve the same result just using if in  Scheme, by having that last consequent expression   have another if in it and its consequent to  have another if in it. So you don't really need   anything new. But if you have a lot of elifs,  then this nested if idea is kind of annoying,   which is why there's cond. So here's a  scheme example that does the same thing.   Cond has as the rest of its expression, a bunch of  pairs, where the pairs are the condition, and then   what to do if that condition is true. So this  says if x is greater than 10, then print big.   Otherwise, if x is greater than five, print  medium, otherwise, print small. Much like   in Python, the else case is optional, there  can be only one and it has to be at the end.   Both of these have the same property that only one  thing will be printed, no matter the value of x.   So if x is 12, it's both bigger than 10 and bigger  than 5, but only big will be printed, because   x greater than 5 is the condition of an elif  that comes after the x greater than 10 that   gets triggered first. And the same is true over  here. Now, a cond expression does have a value.   So if instead of printing, I just said that I  want an expression whose value is either big,   medium, or small, depending on the  value of x, then I would write it   like this. And I could do something with  add value. For example, I could print it.   Now, these two expressions are equivalent. They'll  either print big, medium, or small. But this one,   I think is shorter, because it has  only one print instead of three.   So that's cond, you can still use if. And usually  what happens in practice is that if you're just   choosing among two alternatives, then you use  if and if it's more than two, then you use cond.   The begin special form combines multiple  expressions into one expression. The value   of a begin special form is just the value of its  last subexpression. And the reason begin is used   is so that you can do things, for  example, printing for a while,   or defining some symbols as particular values  before you compute the result that you want.   So here's a Python case where within the  suite for an if clause of printed twice.   And likewise for the else clause. How do you do  that in Scheme? Well, you need begin. You say,   here are some conditions, the first of  which is that if x is greater than 10.   I want to both print big and printed guy. But  there's only space in Scheme for one expression   here. And so the begin expression allows you to  put as many things as you want as subexpressions,   and they'll all get evaluated. And by the way,  since there are only two alternatives here,   it would be a little bit more natural to just  do it with an if. And you can indent however   you want or go to new lines however you want. So  here's an equivalent expression that just says if   x is greater than 10, then print big and print  guy. Otherwise, print small and print fry.   And finally, we'll talk about let. Let is kind  of like define, but it's different in that it   only binds symbols to values temporarily just for  one expression. And then those bindings are gone.   There isn't really an equivalent in Python. But  we can talk about the difference just by showing   a Python example. And its Schema equivalent  using a let expression and how they behave   differently. Let's say you wanted to compute the  hypotenuse length of a right triangle that has   legs 3 and 2 + 2 is 4. So this would be a 3, 4, 5  triangle where this expression c should give us 5.  Maybe in this program, all I really cared  about was making sure that c was bound to 5.   But if I write this Python code, a and  b are still bound down here as well.   That could be a good thing. If you're going to  use them again, that could kind of be a bad thing.   If a was already being used before,  and now you've overwritten it,   or you want to just have as few names as possible.  Here's how to achieve the same thing in Scheme.   But the difference will be that after we've  defined c, a and b are not bound down here.   They are only bound temporarily in  order to compute the value of c,   and then those bindings are gone. Here's how  it works. We define c as the result of a whole   let expression where the value of the  let expression is what comes at the end,   in this case, the square root of a squared plus b  squared. But before that, you get a chance to make   temporary bindings. There's really just two  parts to a let expression, the bindings,   so here's where they begin and here's where  they end, and then the value expression,   which is here. And the bindings themselves are  pairs where the first thing needs to be a symbol.   And the second can be any expression that will get  evaluated in order to bind that symbol to a value.   So it's like having a bunch of  little defines here, except for   the bindings for a and b go away as soon  as you finish computing the value for c.   And in Scheme code of any like interesting  size and complexity, let gets used a lot.   Usually, in Scheme, define is used  for things that are really permanent,   like you want to define a new procedure  so that you can call it many times,   or you want to define some constant like  pie. Otherwise, most Scheme code doesn't   make a lot of definitions instead, if you need  to keep track of some temporary information,   you could use let to do that. And  this is mostly a stylistic convention,   but it's one that has some nice justification,  which is that you don't have to worry about   defining anything that you don't need later.  You can kind of just say I want c to persist,   