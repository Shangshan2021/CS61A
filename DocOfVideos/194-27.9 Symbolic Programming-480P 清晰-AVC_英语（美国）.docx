Lisp is well known for introducing the idea  of symbolic programming, manipulating lists   of symbols, which represent things in the  world as structured objects. So with Lisp,   you could do more than just compute a number,  you could manipulate whole equations. And for   this reason, this was the standard language  for artificial intelligence for many years,   and was also the standard language for any kind of  automatic manipulation of mathematical equations,   such as symbolic differentiation or automatically  verifying proofs. And there's just one feature in   the language that makes this all possible,  quotation. Symbols normally refer to values.   But sometimes, you can refer to the symbol itself.  If I define a as one, then a is the symbol and 1   is the value. If I define b as 2, then I have a  second symbol with another value. Now I can use   those symbols inside of an expression. But the  value that you get by evaluating this expression   has no a's and b's in it. It's just a list  containing 1 and 2. So we've lost all notion of   what symbols were used to create this value. This  value has no symbols in it. But quotation allows   the symbols themselves to be values. Quotation  is used to refer to symbols directly. If I make   a list where I quote the a, and I quote the B,  always with a single quote, and never with one   at the beginning and one at the end, but instead  just one at the beginning of whatever I'm quoting,   then I build a list containing the symbols a  and b. If I build a list with the symbol a,   and the value to which B is bound, I get a list  that contains a and the number 2. So as you can   see, these quotes weren't necessarily paired.  You can have just one quotation mark inside   of a larger expression and it quotes whatever  comes directly after it. The quote is actually   shorthand for a special form called quote. And so  this would be equivalent to writing list quote a,   quote be. The special form indicates that the  expression that is quoted is the value itself,   as opposed to needing to evaluate that expression.  Quotation can also be applied to combinations in   order to form lists. So I can quote the list a b  c. And that builds a list containing the symbols   a, b, and c. The car of that is the symbol a. The  cdr of that is the list containing the symbols b,   and c. Let's try some more demos. Quoting a  is the same as quoting a. I can use the value   a in any way that I want. For example, placing it  inside of a list. And I could do that using either   syntax. The nice thing about the single quote is  that it saves you a set of nested parentheses.   When quoting a list, you get a list. But all the  expressions within it are quoted as well. Now,   another way to build that same list would be to  say, give me a list of 1 and the symbol a. If   I were to attempt to build a list of 1 and a,  it would tell me that a is not a known symbol,   because I've never defined it to be anything. I  can't evaluate a until I've defined it. But I can   refer to a even before I've defined it because  it's just a symbol. It could mean something in   the future. It just hasn't been defined yet.  It's possible to quote a nested expression in   order to build a list that has as some of its  elements, other lists. So perhaps try to figure   out what is the car of the cdr of the car of the  cdr of this quoted list. You're welcome to pause   the video. I'll show you the answer in 1, 2, 3.
It's the number 3. The cdr is a list containing   as his first element the list 2 3. The  car of that is the list 2 3. The cooter   of that is a list containing 3 and the car  that is the number 3. And we could have   told exactly the same story if instead of  numbers, these were all symbols themselves.
