Programs are data. Scheme programs consist  of expressions. Those expressions can either   be primitive expressions, just the  number 2, 3.3, true, the symbol plus,   the symbol quotient. But everything else is a  combination. And each combination is a Scheme   list. So here we have a list containing the symbol  quotient, the number 10, and the number 2. Here   we have the symbol not and the primitive true.  The built-in scheme lists data structure that   we've discussed before is represented as a linked  list for the car and a cdr. But it can be used to   represent combinations in a Scheme program.  So if I evaluate the following expression,   build a list of quotient and then 10 and then 2,  what I get is a little piece of a scheme program,   a combination that says take the quotient of  10 and 2. Now notice, evaluating this doesn't   actually divide 10 by 2. Instead, it just builds  a list. But there's a built-in procedure called   eval. An eval takes any expression represented  as a Scheme list or primitive and gives you back   its value. So eval quotient 10 2 gives you  the number 5. The lesson here is that if I   want to write a program that generates scheme  code, I just build lists. If at any point,   I've constructed code and I want to  know what happens when I evaluate it,   then I just call eval. Python also has an eval  function built-in that takes a string and tells   you its value. What's special about Scheme is  that it has all this built-in functionality for   working with scheme lists. And all the code is  just lists. So it's easier to construct programs   by writing things like list quotient 10 2.
So one of the beautiful things about the   Scheme language, and this is true of Lisp in  general, is that it's straightforward to write   a program that writes a program. Let's do that  now. So I'll start up Scheme. And if I write   an expression that evaluates to a value, that's  pretty straightforward. If instead, I list out   all of these things, this is the procedure  that pluses the number 1 and the number 2,   then I'll get a list of those pieces. But this is  not Scheme code. Scheme code looks like that. So   the reason I have quotation here is to say that  I don't yet want to evaluate the plus. Instead, I   want to leave it as a symbol. And that symbol will  be evaluated just as soon as I asked Scheme to   evaluate the whole combination because this isn't  the operator position. So it gets evaluated to the   procedure that adds and then we apply that to one  and two. Now, if I were to list out plus, and then   have some more complicated expression here, 2 + 3,  I'd end up with an expression where this part had   been evaluated already because it's just part of  Scheme and Scheme evaluates the operator and its   operands and gives me back an expression that's  already computed the 5 but hasn't computed the   6 yet. Okay, now, let's load this small program  on the right. Fact is a procedure that if n is 0,   just returns 1. Otherwise, it returns n times the  factorial of n - 1. So that's a straightforward   recursive definition of factorial. If I take a  fact of 3, I get 3 times 2 times 1, or a fact   of 5 is 5 times 4 times 3 times 2 times 1. This is  just a Scheme program that returns a number. But I   could also write a Scheme procedure that returns  an expression that computes the factorial of n.   So this variant call the fact-exp doesn't have the  job of returning a number. Instead, it has the job   of returning an expression. One is an expression,  a perfectly good way of representing the number 1.  If I want to build an expression out of  smaller expressions, I need a list. A list   containing multiply the number that I'm  multiplying, and then the expression for   how to compute the rest of the factorial.  So now when I compute the factorial of 5,   I still get 120. But if I asked for an expression  that would compute the factorial of 5, I now see   how the factorial of 5 is computed. 1 times 2  times 3 times 4 times 5. So here's a procedure   that returns an expression. If I take that  expression, and I evaluate it, then I get 120.  Let's do one more example following the same  pattern. First, I'll define Fibonacci number   n. If it's the case that n is 0 or 1,  any number less than or equal to one,   then fib n is just n. Otherwise, I have to add  together the two previous Fibonacci numbers,   fib n - 2 and fib n - 1. So Fibonacci number 2  is 1, Fibonacci number 6 is 8. How did it compute   8? Well, using tree recursion, I could also  have written a big nested expression. So here,   we're going to change fib to fib x everywhere, in  order to say that the goal of this procedure is to   write down an expression that computes Fibonacci  number n. And that expression is constructed by   writing down a list of what operation I'm going  to perform and then applying that to the result   of two smaller expressions that compute fib  n - 2 and fib n - 1. So fib 6 is still 8. But   the expression that computes fib 6, is that I  add together fib 4, and fib 5, or fib 4 is an   expression that looks like that. And here's the  expression for fib 5. Now, if I ever go through   and evaluate this nested addition of zeros  and ones, I get the result fib 6. But this   is a procedure that gives me back an expression.  This is a procedure that gives me back a number.
