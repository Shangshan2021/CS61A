So why Scheme? Do people actually  use this language? Well, they do   for variants. And why are people drawn to  these programming languages based on Lisp?   Well, because the code looks like just  a bunch of symbols in parentheses,   you could actually write a program that generates  programs. Before we do that, I'm going to teach   you one more feature called quasi quotation, which  is a lot like the quotation you already know.   But there's an important difference, which is  that you can unquote parts of a quoted expression.   So there are two ways to quote an expression,  you can use quote, which we saw before,   or you could quasi quote, which is represented  using the backtick symbol, which is in the upper   left corner of your keyboard. And in many  situations, it does the same thing as quote.   But here's the difference. Parts of a quasi quoted  expression can be unquoted using the comma symbol,   which is the unquote symbol. So this is quote,  this is quasi quote, this is unquote. Let's say   I've already defined b to be 4. If I quote a b,  I'll get a b, doesn't matter that I've defined it.   If I quote a, followed by the result of  unquoting b +1, well, this whole thing is quoted.   So we're not going to use the value for b. We're  just going to write out exactly what's here.   A followed by the value of unquoting b + 1. So  here we have a list within a list within a list.   But writing the same expression  started with a quasi quote   will give me something that I think is more  useful, a list a 5, where five is the value   of evaluating the expression b + 1. Why did this  expression get evaluated, whereas a did not?   Because of the unquote. So the way to read this  quasi quote, a list a followed by unquote + b 1   is that we're going to build a list. That's  what we've said here. It's going to start with   a symbol a, because that's all quoted. But now  this unquoted expression is going to be replaced   by its value. So by using all the same rules  of evaluation that we have already for Scheme,   we evaluate b + 1, which can depend on  the current environment, b is 4. So b + 1   is 5. And then we get a list of a and 5, mixing  together stuff that was quoted and stuff that was   evaluated. Quasi quotation is particularly  convenient for generating Scheme expressions.   If I want to define a procedure that makes a new  procedure, taking in some n and building a lambda   expression that says lambda d + d n for whatever  n is, and then I call make add procedure on 2,   what I get back is a list. A list whose  first element is the symbol lambda.   Second element is a list containing just one  element d. And the third was a list containing the   symbol plus, the symbol d, and then number 2. And  quasi quotation makes it convenient to write new   code on the fly. Instead of having it be lambda d  + d n, for two different variables d and n. Here,   we have an expression that evaluates to  a procedure that takes only one argument.   And the n has now been filled in with 2. So here's  a procedure that writes code and it writes code   with particular parts filled in.
Okay, let's do a longer example.  While statements. Well, in Scheme, there are no  while statements. But wireless statements are   awfully convenient. Like, let's say you wanted  to know what's the sum of the squares of even   numbers less than 10 starting with 2. So 2 squared  plus 4 squared plus 6 squared plus 8 squared.   What would you do in Python? You'd set x equal to  2, total equal to zero, while x is less than 10.   Increase the total, increase x. And at the end,  total gives you the answer to this question,   which is 120. How do you do this in  Scheme? Well, you want to iterate,   but you're not allowed to use a while  statement. So you have to use recursion.  You have to write a new procedure  that takes in x and total. This is   the kind of current value of x as we're going  through while and the current value of total.   If it's the case that you're still iterating if  x is less than 10, then you make a recursive call   updating x to be x + 2, updating total to be  total plus x squared. If on the other hand,   this is false, that means you're done. Well, then  you should just return total. But after defining   this recursive procedure, I need to call it with  the right initial values total starts at 0, x   starts at 2. And now I've written two expressions  instead of one. If I wanted to fit it all into   one expression, I would need to use begin.  Okay, so it can be done in Python, it can be   done in Scheme. I find the Python easier to read.  There's nothing inherently recursive about this   expression, it just happens to be that the way  you express it in Scheme is through recursion.   And you could do more of these. What's the sum  of the numbers whose squares are less than 50   starting with one? So 1 + 2 + 3 + 4 + 5 + 6 + 7  is still seven squares to less than 50, but not 8.   Well, it's basically the same code,  except we changed the initial value,   we change the while condition, we changed how  we updated total, we changed how we updated x.   And so likewise, those things  need to change in the Scheme code.   But what if there were a bunch of these? And,  you know, someone told you, you have to write   Scheme expressions for all of them? Wouldn't it  be nice if you could just get Scheme to write this   whole thing for you? Well, that's exactly what  you could do. So I'm going to start us off with   that example that you just saw, of summing numbers  whose square is less than 50, starting with one,   but I want to be able to define a procedure  that creates one of these sum-while expressions   out of an initial value for x, a condition  for the while statement. What to add to total?   And how to update x? And how would I call this?  Well, I want to call it on an initial value for a,   a while condition, like I want to keep  going as long as x squared is less than 50.   In this case, I'm just adding x to total. And  how am I updating x? Well, using the expression   x + 1. I think it should be the case that  this call generates this expression. But   now we're going to do something interesting,  we're going to make this generic. We want to   return an expression that starts with begin.  And that expression should always say define   f as x and total, if something not  always this, but whatever condition   is passed in. The reason I unquote this is that  I don't want the symbol condition in the result.   I want whatever is passed in this expression in  the result. Likewise, I want this expression,   as what we update x width. So I'll unquote and  write update x. I always want to add something   to total. But what it is depends on what I want  to add to the total, which in this example, I   think should be x. The fact that I returned total  when I've reached the end of the while condition   stays the same. The fact that I call f starting  with total equals zero stays the same. But I do   want this to have some other value. So I unquote,  and put the initial x here. So now I have a quasi   quoted begin expression, which means that the  result of evaluating this quasi quotation will be   a began expression. But I still need to close the  parenthesis for the procedure that I'm defining.   Okay, I've rearranged a bit so that I  can load this file and make this call.   And look what it did. It built for me  something. Let's give this thing a name.   Result of evaluating this  expression. This result is a list.   It begins with begin, but it's also quote.  And when I evaluate that result, I get 28,   which is the result of adding 1 and 2  and 3 and 4 and 5 and 6 and 7 together.  If instead I wanted that other thing, the  sum of the squares for even numbers up to   but not including 10, then I would evaluate  something else. The result of starting at 2,   having a while condition that says x is less  than 10. What I add to total in this case   is not x but x squared, and I update x to go  to the next even number. This should give me   2 squared plus 4 squared plus 6 squared plus  8 squared is 120. And the way that it did it   was to actually produce the code that results in  120, including defining a new recursive function   and calling that and then eval actually define  that function and called it and got the number.   So this is an additional kind of  expressive power in a programming language,   to be able to write procedures that  write the code for other procedures.   And that's one of those things that get  people excited about Lisp and Scheme.
