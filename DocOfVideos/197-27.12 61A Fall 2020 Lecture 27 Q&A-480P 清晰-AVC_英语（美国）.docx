61a lecture 27 q a the first question was whether parentheses always indicate a call expression and whether adding a single quote before them an apostrophe converts that call expression into a list it is definitely the case that an opening parenthesis causes a call unless there's something special here in which case it's called a special form which kind of behaves like a call but always has some tweak on its behavior um but if you don't have some uh special form keyword there then this is the beginning of a call expression so what's the story with quotation well that basically says don't do this thing just talk about it that's supposed to be the metaphor um and so kind of like how you quote something in uh in prose so this won't make the call instead it will just output the call itself which happens to be a list containing the symbol f and the numbers two of three so a couple of things so i think let me make sure we understand the questions the question is write a function that takes as input a list and returns the sum of the even numbers so as john starts to do his magic let me just say you're you're absolutely right that the syntax in scheme is a little weird um it's okay that will come quick the concepts i think you probably one thing you can do by the way is make sure you can write it in python and once you can do that it's really just a translation problem now and that syntax will come it's a little awkward i always find scheme like all the parentheses make me a little crazy in scheme over time and it's hard to sort of keep track of it and one of the things you'll get good at is figuring out how to indent and space your code so it looks like sort of a python like program yeah yeah that's a great point i mean you mentioned that scheme seems to have a steep learning curve and it will not feel natural to you the first hour that you work with it that is true and i think that's true of most programming languages even if they look kind of familiar there's always some tricky parts that take a little practice to get used to so um the way this course is structured is that there isn't a whole lot of lecturing about scheme i mean we're kind of done with that but we do give you a series of labs and homeworks and discussions just so you get like enough practice that it starts feeling familiar um and it is true that a lot of what you know applies but everything's just slightly different in terms of the syntax and so you gotta get used to that okay so uh how would we define some evens um so we're gonna take in a list it might have some even numbers it might have some odd numbers if i put some odd numbers in here then it doesn't change the answer right is the idea and you know i wrote them in order but they aren't necessarily in order so i think it's a good idea to have some notion of whether something's even or not in advance and we could like test that the scheme convention is actually to name procedures with a question mark if they return just a true or false value so if you want to know whether some number n is even well um we got to figure out the scheme way of doing this right so uh the it's this might actually be built in i guess we should check is there even oh i guess there's even built-in okay so uh it kind of does what we'd expect um this is the symbol for a true value in scheme there's like a built-in true and there's a built-in false um but we could write this too i think that there's a operator to do modular arithmetic oh it's not called mod what is it called remainder i thought it was it's called remainder so uh one way to implement this would say is the remainder of whatever we're trying to figure out uh and um divided by two zero that would make it even one that would make it odd so if i did want to define this i think i would write it as is the remainder of dividing n by two zero and there's a built-in zero or you could do equal zero that would be fine too so and you know the way i work in scheme is i kind of check stuff as i go along so now i've made my own even does it do the right thing it seems to do the right thing okay so now i have a piece now we're going to try to sum the even numbers within s we're going to do it recursively basically how you process all lists in scheme is that you treat them like linked lists which you already know about and most linked list processing is either recursive or with a while statement but we don't have while statements so i guess we're stuck with recursion that means we do something with the first element unless there is no first element and then we have to decide what to do okay so if it's the case that s is empty and how do we say that well the most common way to say it is to say is if no s that basically is a way of saying is s this special empty list called nil in scheme um then what is the sum of all the even elements well i'd call that zero that's kind of the basic sum identity if you don't have anything to sum together otherwise you have to figure out how to make this sum well here we have to decide is the first element in s in the sum or not if even car s car s is schemes version of first element and here's how we check whether it's even if it is even we want to add it to the result so i would say plus car s and then we need to sum the evens in the rest of s so there's a recursive call some evens in the cutter of s what if s is not even well then we don't need to really subtract it we just need to ignore it and therefore sum all the even numbers ends the cutter of s and that will give me the same thing as the sum of the evens and all of s because the first number is odd now i can see what this does if i try to sum evens 2 4 6 i get 12 and if i try to sum evens 1 2 3 4 5 6 i also get 12. all right looks pretty good yeah good question so the question is how come there's no lambda in here and where's the function when you write define and what comes immediately after define is uh stuff in parentheses a combination you are defining a procedure which is same thing as a function just the scheme speak so if you define just a symbol you're not building a procedure necessarily if you really wanted a procedure you'd need a lambda but if you were ever writing a parenthesis right after define what you are building is a procedure so now i have an f which is a procedure if i call it on three then i'll add four to it and writing this is really just you know shorthand for a lambda is one way to think about it this would do the same thing well so this is the same thing as in python right we could write it as an explicit function or as a nameless function right the same way yeah it's just the syntax is just slightly different the next question was about a specific example of building a list out of an existing list so we ended up just doing a bunch of examples related to that so let's just go through and do some list examples where we build things out of the cons operator and the nil and some numbers and see what we get and why um writing cons 1 to cons 2 to cons 3 nil is a lot like in python writing link 1 link 2 link 3 or if you wanted to put in link.empty here you could but that part if you recall is optional but that's like the equivalent of nil this just builds a list scheme lists are linked lists and so if it's always the case that you're considering a number with another list in that order you're not going to get any nesting at all the only time you get nesting is if whatever expression you put in this element position evaluates to a list itself so you asked about one example what if instead of a number here i have an expression that evaluates to a list this is like there instead of the number one and what this builds is a list that contains four and three so now we have a list with as one of its elements a list this cons is just continuing the list without building any nesting into it so if i put a 1 here and a 2 here and a nil then i get a nested structure looks just like this except for instead of 1 i have 4 3 because the expression is the same except for instead of a 1 i have 4 3.
so that's kind of the story there if i already have a list i can use that in the place of a number i mean i can write any expression i want it's just a question of whether this evaluates to a number if it evaluated to 1 i'd be building this if it built it evaluated to a list like 4 3 or 1 2 then i would building a list of lists so this expression gives me a two element list there's that structure of it's a list here's the first element now we continue here's the second element it just happens to be that the elements are both lists so now let's do the first line in the chat and notice y is different right so notice where that s is in the first line you're building up this list the first element is the list for three and then the last element is well that's just the list one two so you're just appending a new element to the remaining list yeah no yeah good question are symbols different than strings i mean they're kind of an impoverished version of strings because you can't put spaces in them and you can't put new line characters in them and stuff like that what's special about them is that they can show up in code so like you would never have a name like an identifier or a variable in python that had a space in it and likewise symbols can't have spaces in them either so sometimes they're used like strings we'll do that in this course just so that we don't have to talk about strings so much in scheme the full language there are strings that are supported and there's like double quote marks to delimit them and they can have spaces and new line characters and stuff like that um so you'd probably use that if you were going to like you know write some program that really had a string interface to it but for simple examples uh symbols are sufficient a good question so the question is what's the difference between unquoting versus evaluating something um it's the same to unquote means to take part of an expression that has been quasi-quoted and evaluate that part so in that sense unquoting and evaluating are the same thing now evaluation happens automatically by default so if i type plus one two it doesn't result in a list containing a symbol plus and a one and a two you get the number three that's kind of how scheme works is that as you're processing scheme code things get evaluated along the way so quotation and quasi quotation are a way of presenting that if you have some longer thing i want 3 minus 2 gives me 1.
if i quote that whole thing then i end up with a nested list it is true that if i had that nested list and let's say i gave it a name i could then ask scheme to evaluate it as if it were code and it would tell me 3 minus 2 is 1.
quasi quotation gives you a little bit more control instead of just saying i want the whole thing quoted or i want the whole thing evaluated you can say i want this part to be evaluated to give me the number 3 but i want to keep the minus 3 2 structure intact so you know it's not a new idea to unquote it's just to evaluate but uh what's new about it is that within some larger structure you can pick which parts get evaluated and which parts though oh good question so what's the relationship between unquoting and repper in python i think the the roles are a little bit different so repper will give you back a string that if you were to evaluate it you would get kind of the value that is described by that string and when you unquote something you get the value that you get when you evaluate it so i guess there's kind of one more step in python right it's like if you've got the wrapper string of something you would then have to evaluate that thing in order to get a value whereas unquoting kind of does the evaluation immediately yeah great question so the question is in python can you generate code like by quoting stuff um and the answer is yes but it's not done very often so um python code doesn't look like a bunch of linked lists it looks like all kinds of stuff you know it's got colons and a mixture of parentheses and commas and all sorts of like square brackets and various things like that it is definitely the case that you if you have an existing value and then you build a string that describes some expression about it like i have a string that says i want to start with s and i want to slice it but how much do i want to slice it well i kind of want to start somewhere around 2-1 and i want to keep slicing to the variant i can build a python expression this way through string manipulation and then i could evaluate that in python and it would be as if i had just written this piece of code and asked python to evaluate it so yes python has this functionality as well lots of programming languages don't python draws a lot from the lisp tradition in fact and so it has this kind of thing but building python expressions is just basically harder and more awkward because there's so much variety in the syntax makes it much easier for humans to read makes a little bit harder for machines to process the next question was what a call to print returns in scheme ah good question so how do we figure out what this evaluates to i think we would try to bind the result of printing one to some symbol notice here that the one has already appeared and what is s anyway oh it's like it's not there at all what if we try to print it well we get this special value called undefined that's it's kind of close to python's none except for here's the rule this is like more of a conventional rule than enforced by the language but here's the rule is that you're never supposed to do anything with the undefined value whereas in python people use none for all kinds of stuff they like compare whether you know something is none etc that basically never shows up in scheme code so when you get this undefined value which happens to exist the idea is you should never do anything with it you should never check to see if it's equal to another undefined you should never check to see how many undefineds there are in a list or something like that you should just stop so basically like this expression is legal but it's a no-no you should never take the value of print and do something else with a follow-up question was what are the properties of this undefined value is it true or is it false so is print is undefined a true value or a false value um it i guess is a true value in the interpreter that we use but this is just an implementation detail it might be that in someone else's scheme it would be a false value or it would give you an error yeah so i would have thought i thought that was going to give you an error so that's something in the underlying interpreter that's different right so the idea of undefined is that the scheme specification for how scheme's supposed to work doesn't say anything about it is it true is it false when you add it to 12 what happens it's just something you shouldn't ever do um in like certain versions of lisp they check very carefully to make sure that you never use undefined so like this would probably error and this would error uh in our version it's it's there but um its behavior is as as it's described undefined so you should never really count on its behavior being true about scheme it just happens to be true about the interpreter that we're using okay so great question the question is about this example from lab where you have a procedure which takes x y and z if it's the case that x is true then it uh returns the value of y otherwise it returns the value of z and then we have this example that's like if two is greater than one which is definitely true then we want five otherwise we want print seven and since this is true you're expecting to get five which we will and the question is how come it also prints seven which it does when if for example i had just written this i wouldn't see this heaven so before you answer john can you do if one is greater than two and let's see what happens this may give us a little bit of an insight into what's happening sure if two is less than one we just see the seven and that's true in this case as well okay um this is behavior that's entirely similar to python the story is that before foo is called you evaluate all of the sub-expressions in order to figure out what to call fu on and in as a byproduct of evaluating this one you print out seven so before the body is even acknowledged before the scheme interpreter even really knows what it's doing it's already figured out that two is greater than one that five is a number and it is already printed seven which is much like you'd get if you uh define foo in python xyz oh what have i done this is hard this is really hard folks by the way this is going to happen to all of you you are going to start writing define in python so if you wrote something like this and then you called this foo in python on two is bigger than one and five and print seven then you'd see the seven because what actually got passed in here is true and five and none likewise in here you got true and five and undefined so to your question shyvana is that prince7 in the parameter of the function gets evaluated and what gets passed in in python is none and in scheme it's undefined right which is why you don't see print seven twice right and when it evaluates to false because it's undefined and undefined doesn't do anything yeah good question so the question is how do you evaluate some expression that has been quoted if i have a unquoted expression it will get evaluated automatically if i quote the same thing then it has not gotten evaluated at this point really the only way to evaluate it is to call the special built-in eval procedure which takes in some code represented as a scheme list and tells you what would happen if you evaluated it you might think that this is like a really complicated thing like a function that can just evaluate any expression but in fact that's already built into the interpreter anyway that's exactly what it does is it evaluates expressions so it's just triggering that ability that the interpreter already has to treat whatever value is the result of of evaluating this part as an expression now it might be that you wrote something that's not legal like if i try to evaluate one two three it's going to tell me int is not callable and if i build a list one two three let's say i build it like this not without quotation and i say oh i want to evaluate that let's just pretend it's code well it will pretend it's code this code and it will give you the same error that you would have gotten if you had tried to call one on two and three so um yeah it's eval is a way of taking some piece of data and pretending it's code and evaluating it and that will either work out or it won't depending on what the data is a follow-up question was whether you can evaluate using a comma yeah so i think this question is about quasi quotation if you start your quote with this backtick instead of the apostrophe then you are allowed to evaluate some parts of it along the way so if instead i didn't have this unquote i would have gotten this nested structure but with the unquote it just says well you know don't evaluate the whole thing but evaluate this part and you know i could have done this the long way i could have said i want to build a list where the first element is one the second element is the result of evaluating plus one one and the third element is three so it's not like quasi quotation is giving me any special power it's just um it's allowing me to quote something most of the way but then have some parts be evaluated and by the way if scheme is making sense on the quotation part you should not worry at all like this is just something like minor detail which leads to some cool examples but mostly you should worry about just quoting and what that means and or even better at this stage just make sure you get like defined and if making sense and then and then you're kind of on track yeah so the question is can you perform any kind of non-local assignment in scheme you know we have this uh example of a withdrawal function so here's a withdrawal procedure which has some balance oh no i think it was called make withdraw with the starting balance and what this did was define a withdrawal function which took in some amount that you want to withdraw and let's just pretend that there's always enough money what this was supposed to do was change the balance and then return the balance how do you do that well there are parts of scheme that we will not teach you in this course because you know we i kind of want to teach you enough schemes so that you get the sense that you could learn the rest if you wanted to but not so much that it takes the rest of the semester so um so we've kind of picked and chosen and we chose not to include non-local assignment but um it does exist it's called set so if you really wanted to change balance to be the result of subtracting balance by amount you could do it and then you could return the balance and then you could with turn withdraw and then i think we should be able to withdraw stuff so if i define my account as uh well maybe we'll call it a as make withdraw and i start with ten dollars and then i would draw two dollars then i have eight left and if i draw you know you can work your way down so anyway you do need this uh other special form that we haven't talked about called set in order to make non-local assignments i remember remembering right john i remember when i first learned scheme many many years ago there was some controversy around set there's people who think you shouldn't use it is that am i remembering right so um you're right it's the same controversy that we kind of talked about earlier in the course of the consequence of mutation is that you lose this notion of what's called referential transparency which is basically like things are easy to analyze because if you ever have a block of code you could just pretend that whole block is replaced by its value and you get the same answer and this notion of substitution where you can like look at some complicated piece of code you're like oh well this thing you know that evaluates to the list one two three and you don't have to think about whether it changes the environment in any way is really nice for trying to for a human trying to understand their own program and so if you never use set then you can do this forever you can just think about any expression is substitutable by its value now this is not true if you start setting things because there's a side effect so you know a lot of scheme code can be written with no side effects at all the fact that we never do any kind of assignment anywhere um except for defining some procedures and everything is done with recursion means that it's rare that you reassign anything ever and so that the goal there is just to preserve this notion of referential transparency so that you can think about your program more easily yeah good yeah so the question is do you need to know all the different notions of equality and uh memorize them in advance or will we kind of uh tell you when you need to know and it will be my goal to tell you when you need to know in fact i don't always remember there's like a number equality and there's an identity check and then there's like uh some kind of thing where if you ask if two lists are equal then it will tell you that they are uh even if they were built in different ways to uh yeah okay so anyway there's a bunch of different equals and no i don't think you need to know the difference between all of them but if you want to know like this is like is this is like nothing that exists in python because it only works for numbers this is this is a lot like the equal sign yeah in in python i think that just like uh this will check okay so yeah this will check whether two things are like generally equal just like in python 2 equals 2 is true and also a list containing 2 and a list containing 2 is true so um yeah this is usually the one you want but if you want to check for is it looks like that and this is some like weird thing that only works with numbers but no you don't need to know it yeah and i'm going to just reiterate what john's going to say is we're not going to teach you the full-blown scheme programming language it's really just enough to to get you going and then the rest when when and if you want to learn it will will come but you definitely need to know how like define works and lambda works and um you know just a handful of like basic arithmetic functions we usually feed those to you if you're ever like doing a homework or an exam we'll say like oh by the way there's a zero procedure that checks where there's something zero but also this manipulation is something you're meant to know so car and cutter and cons and list and null and that kind of thing this by the way is the best part of scheme is you get to say car and cutter all the time that's my favorite part of the 