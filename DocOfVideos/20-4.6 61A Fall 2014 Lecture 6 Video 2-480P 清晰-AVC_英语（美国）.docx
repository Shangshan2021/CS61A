Lambda Expressions are expressions that evaluate  to functions. Let's have a demonstration.   We already know that I can find some value to  a name x equals 10. Wouldn't it be nice if   somehow I could find a function to a name using  the same syntax, an assignment statement?  Now, I know I can bind a name to a function by having  something that evaluates to a function over here.   But what if I want it to be a new function that  I've never written down before? How do I do that?   Well, one might think that I can just write down  what I want the body of that function to be.  I want square to be that function that computes the  x times x. So, so far, I have x bound to 10.   And what's square bound to? Well it's not a function  at all. It's just the number 100. And why is that?   That's because I evaluated x times x in order to  get its value. and that's what I bound to square.   Now, what a lambda expression allows you to do is  achieve what we wanted in the first place. Bind to   the name square using an assignment statement,  a function that takes in some argument we'll call x,   and computes x times x as its return value.  Now this time, when I look at what square is,   I find that it is a function. Excellent. And what  does that function do? Well, let's try it out and see.  Oh, it squares things. Excellent. So a lambda  expression looks like this. This whole thing is a   lambda expression. And it's used to evaluate to  functions. I can either take that function and   bind a name to it so that I can refer to it later,  or I could even apply that function straight away   in a call expression where the operator here is  a lambda expression, and then I call it on some   argument. Let's see what happened right there. I  wrote x is 10. I wrote square equals x times x.   What happened when I had that assignment statement  is that I wrote down an expression that evaluates   to a number, and then square was equal to 100. But  the second time I tried it, the one that actually worked,  I wrote down an expression that evaluates  to a function. That lambda keyword introduces a   new function in the form of a lambda expression.  And the way to read a lambda expression is   as a function with formal parameter x that  returns the value of x times x. So eventually,   people will start to use the word lambda in casual  conversation around you. But what their meaning is   an expression that evaluates to a function that  can be interpreted in this way. It's important   to note that there's no return keyword in a lambda  expression. This is a quirk of the expression that   you just write down the return expression directly  after the colon without the word return. This   limits you to having just a single expression be  the body of the lambda function that you create.   So lambda expressions create functions but they  always create simple functions that do nothing but   evaluate a single expression. Once I've done this,  I can square 4 and get 16, and square anything I   want. Now lambda expressions are not particularly  common in Python. It's more common to use a def   statement. But they are really important in  general. And in some programming languages,   they're totally fundamental. In other programming  languages that didn't have them for a long time,   they're starting to appear because people have  realized just how wonderful a lambda expression   is. Lambda expressions in Python cannot contain  statements and so they are limited relative to   their close cousin the def statement. So just be  aware that if you want to put a while statement   inside the body of a function, you can't  use lambda. You have to use def. What else   is different between a lambda expression versus a  def statement? Well, let's figure it out. Face-off   time! Over on the left, we've got lambda x is x  times x bound to the name square. On the right, we   have the def statement version of square. How are  these different and how are they the same? Well,   it turns out they're almost exactly the same.  Both create a function with the same domain,   range, and behavior. Both functions have their  parent, the frame, in which they were defined.   So the rules for creating functions is exactly  the same whether you use lambda or you use def.   Both bind that function to the name square.  Well, they do it in very different ways. So   this first creates the function with no name  at all. And then it's the assignment statement   here that binds that function value to the  name square. Whereas in a def statement,   both of those things happen automatically. This  creates a square function and binds it to the   name square, all as a byproduct of executing the  def statement. Aha! We found the difference. Only   the def statement gives the function an intrinsic  name. What's an intrinsic name? Well, it's the   name that you see if you actually display what  the function is. So if I type in square, it tells   me this is a function called, well, lambda. It's  not called square, which is different than what I   used to get when I type in def square x, return x  times x, and then I would look at what square was.   And this said, function square. So there's this  one little place where you'll see a difference,   which is what happens when you try to look at the  function value and it has a name that's called the   intrinsic name of the function. Now they're both  referred to by the name square in the same way.   When you put them inside of an expression, all the  same rules apply. So they're virtually the same.   But this one difference does change a bit how we  draw our environment diagrams. So an environment   diagram for this example, including the case  where I define square equals lambda x x times x,   and then I call square on the number 4. It will  look like this. We have the name square bound   to a function, we introduce a new frame to call  that function on 4, and we get a return value   of 16. The name square appears in the frame  and these are the names that we actually use   in order to evaluate expressions. These are the  important ones. In here, we don't write square,   but instead, write the Greek letter lambda. And  that means that when I call this function and   I copy all the information over to a frame, well,  the name lambda sticks around. But that name isn't   really important either. It just helps us keep  track of which frame is which. But in contrast,   when I def square, x return x times x and then I  call square on the number 4, we get this familiar   picture where square is bound to a function that's  called square intrinsically. And when I call   square on some value like 4, then I get a frame  that says square in. Okay, so tiny difference,   really insignificant. But it comes with the fact  that this thing had a name when it was created,   whereas the lambda didn't have a name until the  assignment statement finished giving it one.
