returning from a function call means ending the function call and determining what is the value of the call expression so return statements we've seen but we haven't talked a lot about a return statement is there to complete the evaluation of a call expression when you evaluate a call expression for a user-defined function you have to execute the body of that function in a new environment and you keep doing that until you reach a return statement or you reach the end of the body so when you reach a call expression like f of X for some user-defined function f that's when you switch to a new environment and it's time to execute F's body why are we doing all this work in order to figure out what's the value of f of X when the return statement within F is reached we switch back to the previous environment the one in which f of X was being evaluated and now f of X has a value and that value typically determines what happens next in the original expression where maybe assigning the value of f of X to a name or passing it in as an argument to some other function whatever it is when we reach the return statement f of X now has a value and that value is the value of the return expression in that statement only one return statement is ever executed while executing the body of a function once that return is reached we're done so for example let's write a function that prints the final digits of an integer end in reverse order until D is found let's assume n is non-negative here's an example of what we're doing end of 3 4 5 6 7 is all the digits starting from the end of 3 4 5 6 7 until we reach a 5 and then we're done so we start with 7 and then 6 and then 5 we found a 5 so we're done how would we write this function well one simple way to do it is to write a while statement that just prints all of the digits 7 6 5 4 3 the approach here is to say that while in is great and zero we split in up into its last digit and everything but the last digit print the last one out now we need to make sure that Wendy is found we're done and we can do that with a conditional statement containing a return statement if I find D as the last digit in whatever piece of n we're currently looking at then we return none as a way of ending the process of the while statement once you return nothing else gets executed within the body of this function and let's look at some more examples of one we might return from within the suite of a while statement I'm gonna write a function search which is a higher-order function it takes another F and it keeps trying all of the integers starting at zero and working its way up until it finds one for which f of X is a true value now what's a true value true is a true value or a number that's not zero is a true value so we'll start with x equals zero and I want to keep trying exits just as long as it takes to find one where f of X is it true value one way to do that is to purposefully construct an infinite loop this while statement will run forever unless a return statement within it tells us that we're done Wow true if it's the case that f of X is a true value I want to return X if that's not the case I want to try a different X I could write this as x equals x plus 1 or the shorthand X plus equals one which will have the same effect if X is a number here's a simple function to search called is 3 which will return true just when x equals 3 putting these together interactively we can see what happens I want to search for an X such that when I pass it into is 3 I get a true value and that's because when I call it is 3 on 3 I got true but when I called it on - I got a false one I got it out of false etc so far this brute force search seems pretty useless well let's get a more complicated example here's the square function here's a version of the square function that is always non-negative because it takes a max of 0 and then we'll square X and subtract 100 so this positive function when I pass in 2 I get 0 and 3 I get 0 and 4 I get 0 and 10 I get 0 because x squared minus 100 is 0 if I pass an 11 I'll get 21 because 121 is the square of 11 so the goal of search is to find the smallest number X for which X gave a positive value now there were no trues and falses here or comparisons we're just using the fact that 0 is a false value and then any other number is a true value in order to reach this return statement and what's cool here is that 11 is related to the square root of 100 so so far we've come up with a scheme for finding a number that's one more than the square root of whatever I put there a method for computing square roots just by trying a bunch of numbers until I find it this is a general strategy for computing inverse functions the inverse of S is to return a G such that it's the case that f of X passed into G gives us back X and how do we find such a G well it's a function that takes in Y and then we'll just search for an X that satisfies f of X equals y so known as the square root is not built into Python but I can define it now by saying is the inverse of square now just like I can square 16 to get 256 I can take the square root of 256 to get 16 back or the square root of 16 is 4 and the square root of 4 is 2 now this version of a square root will only work for perfect squares right now it's searching for an integer that when you square it gives you 2 and there is no such integer so it's not the most ideal implementation of square root if you want to see our better version take a look at the Newton's method section of the textbook but for perfect squares it works just fine and it's pretty simple as a final question is there a way to write an even shorter version of search well sure I could say well it's not the case that f of X is a true value I want to add 1 and then I want to return X once I've found a true f of X and this version also allows us to compute square roots just like before so I think once you've written down an implementation for a function it can't hurt to stare at it for a little while and see if there's 