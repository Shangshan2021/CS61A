There are expressions that allow the Python  interpreter to skip evaluating some subexpressions.   Let's take a quick look at examples of those.
The logical operators, and and or, exhibit a   behavior called a short-circuiting. Here's how you evaluate some expression and some other expression   where we'll call them left and right. But these are  just placeholders. You evaluate the subexpression   to the left of and. If it's a false value, then  the whole expression evaluates to that false value.   Otherwise, you evaluate the expression on  the right and the whole expression has the value   of the right expression. So if this is false, the  whole thing is false. If this is true and this   is false, the whole thing is false. If this is true  and this is true, then the whole thing is true.
And these values need not be just true and false but  they could be any values in Python because every   Python value is either a true value or a false  value. So 2 and 3 would evaluate to 3 according to   this evaluation rule. Evaluating some expression  or some other expression is similar. Evaluate the   subexpression to the left. If it's a true  value, then you know the whole disjunction   is true and so you're done. The whole expression  just evaluates to v. Otherwise, you evaluate this   expression on the right and that's the value of  the whole expression. Why is this useful? Let's look at a couple of examples. Let's say I want to  write a function has big square root that tells   me whether some x has a really large square root.  Return the square root of x is greater than 10.   I chose 10 arbitrarily, but that's just because  I want a simple example. Now, let's say this is   part of the program where I'm interested in the  real parts of square roots. So I don't want this   to crash if x is a negative number. I just want to  know whether the real part of the square root of   x is big. I could write x is greater than 0  and square root of x is greater than 10.   When I run this code, has big square root, tells me  that 1 does not, 1000 does, and negative 1000   does not, because its real part of its square  root is 0. And the important part is that this   didn't crash. Even though I have an expression  whose subexpression takes the square root of a   negative number, this never gets evaluated because  of the way and works. Once it's figured out that x   is not bigger than 0, it's done evaluating  the hole and expression. Let's do an example with or.   You can divide. You could even divide a  really big number. But if a number gets too big,  then you can't divide 1 by it anymore. So 10  times a hundred isn't that big, but ten to the   hundredth power, now that's getting big. But it's  still not too big. I could divide one by that.  But what about 10 to the thousandth power? That's  a really. really big number and I can't divide   one by that without just getting 0 and losing  all of the precision of what's really going on.
It should be a decimal point with a thousand 0  and then a 1. But Python doesn't work that way.
As do most other programming languages, there's only  so small a number that you can represent without   it being rounded to 0. So let's say I have a  definition of whether some number is reasonable.  Meaning, it's not so big that you can't divide 1  by it and still get a non-zero number. Well, I could   just say is it the case that 1 divided by n is  not equal to 0. But this will crash if I pass n   equals zero. And zero is a perfectly reasonable  number, it's just not something that I can run   this particular test on. So I might write that n  is reasonable if n equals 0 or if 1 over n   is not 0. Meaning, it's not so big that it gets  rounded off to 0. So, here, is zero reasonable?   Well, sure. And 10 is reasonable. And, you know,  this big number is still reasonable. The only   unreasonable numbers are when I exponentiate  and get 10 to the 10,000th power. That's   just like a ridiculous number, not a reasonable  number. And the important thing is that none of   these crashed, including this one. We passed an n  as 0. We didn't compute 1 divided by n because   we checked this first and since this was true,  the whole expression was true. And that's why   this short-circuiting behavior, which is a form  of control, is useful in Python and exists in   many other programming languages as well. If  what you really want is to put the behavior   of an if statement in an expression so that you  can embed it in a larger expression, that's also   possible in Python, just not with a function.  You have to use a special kind of conditional expression.  Here's what it looks like. You write  some expression, if, some other expression, else,   some other expression. This is not an if statement.  Notice there are no colons, no indentation.  This is an if expression or conditional expression.  Here's how it works. You evaluate this thing   in between if and else first. If it's a true  value, then the value of the whole expression   is the value of the consequent. You evaluate  this. Otherwise, you evaluate the alternative.   That means that in Python, you can say x equals 0,  and then compute the absolute value of 1 over x.   If x does not equal 0, else is 0. What this will do is not  compute 1 over x right away, but instead compute   whether x doesn't equal 0. This is false. So it  chooses to evaluate this 0 and take the absolute   value of that as opposed to ever evaluating 1  divided by x, avoiding the zero division error.
