welcome to the lecture 4 q a there was a lot of confusion today because i left out one of the videos in the playlist for lecture four the one about lambda expressions right after the q a at about 9 a.m pacific time i added that video in so hopefully you saw it if not you might have seen this keyword lambda before it was ever explained and that could cause a great deal of confusion if that happened to you hopefully the questions and answers in this q a will help clarify and i'm sorry if that happened to you if not you'll notice there's a lot of questions about lambda which is fine even if you saw the video you probably have questions and this video might contain some answers i've edited out the students so you'll just see hani and i answering questions and occasionally i'll jump in like this to repeat the student's question if i think that will help you understand the answer yeah so the question is what is a lambda function and lambda expression because they were used in one of the lecture videos but they were not explained and for that i apologize so um a lambda expression is kind of like a def statement in that it creates a new function except that it has a different syntax and what's special about the syntax is that it doesn't give the function a name so normally you'd write def f of x return x plus two and you would create a function called f which adds two to things lambda expression doesn't include this f instead it does include the formal parameter name x so that you know how to refer to something it doesn't include the word return but it does include the return expression and evaluating this creates a function but this function doesn't have a name so we call it a lambda function just because there's no other good way to refer to it now the other interesting thing about a lambda expression other than it has a slightly different syntax than a def statement is that it is an expression meaning you can put it into some larger expression so i could for example say g equals this lambda expression i don't actually need the parentheses and now i do have a name for this thing g it's still a lambda function but i can refer to it as g and therefore i can add two to things that's a nine not a g using the function that i created with the lambda expression and yeah okay so i'll stop there honey can explain why can you make me a co-host so i can manage the assessments please and tyler the way to think about i mean john said it exactly right it's an anonymous function it's a function like any other function it just doesn't have a name and it may not be obvious why you want to do that but you'll see downstream sometimes it's nice not to pollute your workspace with a lot of function names when you don't actually need them yeah so think of it as just as an anonymous function and with a slightly different syntax to how you define a function and i think the question is what are these how are they being used together in the demo and can we kind of trace through how that works and that is exactly what we will do so in this example search was a powerful but rather simple function it takes in another function f and returns the smallest non-negative integer x for which f of x is a true value so basically just searches through all the integers until it finds an x where when you pass it into f you get something true so um if we wanted to know is oh this is probably the demo where the lambda shows that's where you use this three it must have been very complicated okay so let's use square to do something particular let's say um is uh 4 squared is a function now how would we use square to do this well we would return whether square of x oh square of 4 equals x so in in this world i'm pretending i don't really know how to square things i don't know what square of 4 is i'm going to do it's 16 but let's pretend we didn't and we wanted python to do the work well now we have a function that is only true for 4 squared so if i pass in 3 it will say no 4 no 5 no but if i keep doing this for a long time it will say oh 16 is 4 squared now instead of me typing this out i could use search to do it for me search for the smallest integer that is 4 squared and it will tell me it's 16.
so by using square and search together i've created a procedure for searching the integers until we discover four squared um that was part of the demo so why don't i pause there and see if there are questions otherwise i'll go on to what this has to do with inverse let me add one thing to here is notice that what is happening here is that the function is four squared is being passed into the function search um we're not calling there's no parentheses around that call right there so it's being passed as a parameter and then used of course um to evaluate in the conditional inside of that while loop okay so uh sounds like maybe this made some sense what if we wanted to go the other way and find a square root well then we could write a function is square root of 16. and what would this look like this would return square x equals 16.
okay so now we have a function where i don't know how to take square roots and like i actually don't you know uh it's some procedure that would compute the square root but this is the kind of thing that i kind of just memorized um is square root of 16 is not true for 2 or 3 or but it is true for 4 but not true for 5.
so if i run a search for what is the square root of 16 it will tell me that it's 4.
so in this sense we've inverted the square function square goes from 4 to 16. now we have a procedure for going from 16 to 4 which i did in a specific case here by writing an is square root of 16 function but this general format i think i could write in terms of not just 16 but in terms of anything i wish i knew exactly how my demo went but i think it was something like uh we're gonna invent the square root function which uh takes in some y defines a new is square root of y x which is just like this except for instead of hard coding 16 we write y and then we can return a search for a number that is the square root of y and now we can take the square root of 16 and it ran forever because i did something wrong um i never returned yeah rookie mistake sorry about that and we're turning the square root of 16 or the square root of 25. now this will only work for perfect squares but we do we've built a square root function that's kind of a generic version of the specific procedure that we did for 16 which is to create a function that tells us when we found the square root and then search using that function until we find the square root terrible way to find square roots is like very inefficient but the fact that we were able to do it is kind of interesting so that was the core of the demo and then what about inverse well let me pause here and see if they're follow-up questions let me talk about inverse yeah that's right so the question is what does positive have to do with any of this and the answer is nothing nothing it was just another example of using the search function yeah okay by the way let me just point out a couple of things in this example on the in the python interpreters notice that that that there's one function square root that's what's in the global frame inside of that function is another function definition the scope of that function is square root of y is only visible within the square root function yeah i think we'll talk more about that on friday in the environment but that is a function definition within a function definition and the reason we do that is because that's the only function that needs to do and so it's scoped within that function yeah so watch those indentations that what's indented will tell you about the scope of things so it's probably worth really quickly just following up on the what's a lambda function question by finishing this definition of an inverse which i wrote in this particularly tricky way but let's not write it that way let's uh take the code that we've built so far and make it even more general so the code that we wrote so far said make a square root function and then define the square root of y and then search for it but this is specific to squaring right the return again right there oh i did it again right there this is specific to squaring which is not what we wanted we wanted to uh not just take square roots but to take any inverse of any f and we wanted to do this by calling f of x equals y so now we've sort of just generalized from squaring to any f that might come along and then we've created an inverse of f function which if we pass square as f we'll get the square root see if this actually works while john is doing that i'll say i prefer this construction to the lambda construction you can see the lambda construction construction is particularly concise one minor code really elegant i find that code hard to parse um so those two things what's commented out with the lambda construction and what's sort of a little bit more clumsy is our equivalent um i'll say sometimes clumsy code is not bad because it's easier to read there's this balance between oh this is a nice elegant one line of code but it's a little obfuscated and we sort of first have to find that balance yeah in particular this leaves out all the names and the names are pretty helpful like what does this do it returns the inverse of f so if you name things well it's it's sort of easy to see easier to see what's going on now this is a function that returns a function that returns f of x equals y that's kind of the returns the result of searching for f of x equals y and this says the same thing a function that takes y which searches for the result of a function that takes x and computes f of x equals y so in that sense they do the same thing but this sort of makes explicit what the different pieces are good question okay so the next question is here's an example from the textbook what on earth is going on um compose is a higher order function that basically takes two functions and says when an actual value a number let's say comes in first apply g to it so if g is add one then we're first going to add one and then apply f to that result so if f is i don't know square then we'll add 1 to x and then square that result so if x were 3 then we would add 1 to get 4 and then we would square it to get 16.
but compose1 doesn't say what f and g are it just says that they're some functions it has yet to be determined what they will actually do all compose1 says is once i know what f and g and x all are here's the work that i'm going to do i'm going to apply g to x and i'm going to apply f to the result and so to be clear michonne this is like a standard mathematical operation this is not a python issue function composition is a normal thing you apply one function you apply another function to that and this python function is simply taking two functions input and do function composition yeah and now for the ugly part with the lambda expressions now this part says it's time to fill in f and g but not x so f is going to get filled in with and then you have to know how to read lambda expressions so the way you read a lambda expression is a function that takes x and returns x squared that's going to be f and this says a function that takes y and returns y plus one okay so that's gonna be g so here i picked a lousy name f this could have been something else like h yeah i mean no reason to make the example even worse than it already is okay let me interrupt just for a second michonne here and say we could have written this another way without lambda expressions so i could have passed in the function square which takes a single input and returns the square and i could have passed it a function name called add one which takes a parameter and adds one and that would have been exactly the same it's just a little convoluted here because the lambda expressions yeah okay okay so now h is something that takes in an x adds 1 to it and then squares it which means that h of 12 should be 13 squared is 169.
now the environment diagram shows you how that happens and how that happens might actually be more complicated than just thinking about what this code does so abstraction is valuable in this case i think in that if you think of like oh this adds one to things this squares things and compose says first add one and then square then you can predict what this is going to do without drawing the environment diagram but you also could draw the environment diagram to watch the step-by-step mechanics and what that looks like is that calling compose creates a local frame with an f and a g which are assigned to these two different lambda functions and since they don't have names it's hard to tell which one's which but if you look at the code you can see well this is the one that squares and this is the one that adds one it returns a new function so neither f or g has been called all of the calling happens when you call h so h is the name for the return value of compose1 and when you call h you get a lambda frame why is it a lambda frame well because you just called a lambda function why does it have x here well because you call this lambda function which has x as its formal parameter you bound this x to 12 and then you execute the body of this function which means you have to call f of g of x there's no f and there's no g here but they are here and these are accessible this is what we'll talk about on friday in some detail is that when you've defined this function inside of compose then it can refer to this f and this g and we talked about this in lecture today but we never really drew the environment diagrams that's the job for friday but the mechanics of it in an environment diagram is that when you look for a name you're looking for f you first look here in the current frame and if you don't find it then you look in the parent and the reason this has a parent of f1 is that it was created in the f1 frame and you can see it has a parent of f1 that's where this parent came from and so you find the f and the g there they're both lambda functions and that means you can call f which is a lambda function that adds one to things you make another call for something that add that squares things and then you finally get 169.
so so when you see the lambda john said it just right i read it like this lambda this is a function next thing that takes a parameter after the colon returns this thing so notice that it just doesn't have a def it doesn't have a return statement so you just have to sort of read it slightly differently but it's exactly a function definition without a name ah john's gonna do the example that i suggested so we cleaned that up well i'll leave the old one there so you can see the contrast but uh the nice version would be uh compose one of square and add one this would do the same thing we just uh wrote the functions using def statements and in fact this could be written using def statements too we could have said i want to def the composed function which takes x and returns f of g of x and that's what i want to return instead of trying to cram it all in one line and now i have equivalent code if i ran all this then you'd see the same environment diagram except for uh functions have names along the way like composed and square instead of everything being a lambda so it's easier to follow so you can see why the lambdas are nice you can see how much less code you had to write we didn't have to define square we didn't have to define add1 we didn't have to define a function within a function so it really tightens up the code but also makes it a little cryptic in in the real world john do people really use lambda functions or what's the the protocol in the industry i think it's um somewhat unusual that you'd see it here it's quite common that you'd see it here so if your goal is to pass in a function that's just does something really simple that's where you tend to see lambda expressions because it's nice to just kind of say like oh i want to call this function whatever it is on this thing and it happens to be a function so you use a lambda so they do appear uh out there in the world and um yeah i guess i've seen them a lot a lot more recently in like machine learning frameworks people use them but uh other than that they were not terribly popular in python they're really popular in other programming languages like ruby uses them a lot and javascript uses them a lot so it really just depends on what programming language you're using okay so the question is for this example from lecture where we had a function that returns a function and then we called it twice with this very bizarre syntax where we had two parentheses in a row what does this mean and how does it work well a normal call expression looks like f x right and that's actually what this looks like too except for we don't have the function named already we need to write an expression to build the function that we're going to call on 2 and then we call it on 2. so kind of the right way to think about this is that we're doing a bunch of work in order to figure out what function to call and then we're going to call it on 2. it turns out that figuring out what we're going to call it on is really simple it's just two but we have a compound expression in order to figure out what function to call so um i'll leave those parentheses in there they're not going to do any harm when you evaluate this whole call expression first you have to figure out what function you're going to call and in this case we don't just look it up by name we do some work we call makeadder on1 which creates a new adder function and returns it now where is this return value going this adder function is being returned as the function of this call expression so this return value is basically telling me here's the function you're going to call on to then we can call that onto so here we see a frame for adder which is this adder function that just got returned is now being called that's why it gets its frame and with its formal parameter y bound to 2 that 2 came from here so when you have a compound operator expression that's the thing before the parentheses in a call expression you have to evaluate it first before you can call whatever function and this better evaluate to a function otherwise it will crash if instead this evaluated to 12 it would say you can't call 12 but it evaluated to the adder function and so we were able to call that and what does that do that adds one to two and we're done so the other way to see this is if we had written f is equal to make adder of one and then on the next line call f of two that's exactly the same thing we've just done it in two steps to make it explicit that f is the function returned by make adder and then we apply f to two so that's just a shorthand for those two lines of code next the student wanted to clarify that make editor is returning a function and not a value such as a number that's right and you can see that because if you look at make adder what's the body of the function it's a function definition but that's not the important part the important part is the return adder it returns the name of a function that gets shoved in in this example to f f is now just a synonym for a function uh adder and then you can apply that downstream and a common mistake not that you would make this mistake but a common mistake is that people will try to call this because it looks unnatural just a name adder so you want to call it i don't know on maybe x or something like that but what this will do is it will compute a number and you can't call a number down here so this would eventually give us an error and it would sort of do the wrong thing so this would add 1 and 1 together to give us 2 return 2 and then you can't call 2 on 2 because this integer is not callable and you'd run into a problem so this adder is bare just a name not a call expression for a reason oh um what i see um what can you put into a lambda expression i think is the question can it only be an operand and a return statement is that right right um you can put whatever you want and oh actually in python it is quite restricted no that's right in pythia i think it's only origin you can't put like a loop or a conditional or anything right that's right it has to be just the return expression yeah pardon me for a moment yeah so it can only be a return statement um and that's because you notice there's no explicit return yeah so it's whatever shows up there so it's a pretty limited expression what you can put in there now i think you can this does not right exactly you can only write x plus one you can't even write return that's not allowed you just have to write what it's going to return so this only is a lot you're only allowed to use this for stuff that's very simple now you could say like oh i want to do f of x and f could be arbitrarily complicated like this could have a while statement in it so there's there's no limit to the kind of power of what a lambda function could do but in terms of its own code it has to be very simple i'm going to let john put it back up so i think we're asking if i just said make adder of one and nothing else um it would have it would have called make adder with one it would have returned the function um and that's all that would have happened so it would it would return something but just the function it just simply wouldn't have evaluated it if it depends what you want to do if i want to assign uh make editor of one to another function that's fine i can do that i don't have to evaluate it but if i want to actually go ahead and do the evaluation then yes i need that other parameter which is of course the y parameter ah so this is your ask the question is the difference between that sort of compact version of this and then the full-blown um i don't know if there's an easy answer to which one is more or less common i think part of that is stylistic i for example like the if else clauses i find them easier to read um but i think john may have a different opinion this may be a style issue is i think for really simple things you tend to use the simple predicate like just short you know bite-sized things but i wouldn't do it like if i had four lines in the in the conditional and three lines in the alps i wouldn't write it like this i find it confusing so things that are very compact i think you use this notation and things are a little more um complicated than i think you'd probably write john may have a different opinion about that though oh han is exactly right writing this in like a real program is exceedingly rare but i i showed it to you and i told you like you don't need to know this but i'll show it to you because you will see it in someone else's program one day you know writing programs is very collaborative and you end up reading other people's code so i figured i'd just let you know that it exists but um yeah but you know there are cases where it shows up oftentimes it's like in the body of a lambda where you're not allowed to write an if statement but you're allowed to write this and so you know people do use it every once in a while like it's in the language for a reason but exceedingly rare so it's almost always the case that people will use a normal if statement instead yeah i i think john's exactly right you should know that because when you see it you should know what it is it's also i i remember back in the day when we used to code and see a a similar concept is very popular also you would see it a lot in code to make the code very compact the next question was is lambda just a convenience or are there instances where you have to use lambda or it's more appropriate to use lambda instead of a deaf statement yeah that's a good question i'm going to give my answer we'll see if john has one one of the reasons i like the lambda is it cleans up the name space when you define a lot of functions your name space tends to get a little crowded so i like anonymous functions sometimes just to keep that clean um but maybe john has a better answer yeah so uh lambda expressions don't give you any more power than you already had it's not like you can now write a program that you couldn't write before and so you don't really need them at all uh you need to know what they are again so that if you see someone else use it you can figure out what their code is doing but it really is just a way to make things more compact most functions should have names because the name tells you what they do when it's really obvious what a function does maybe it doesn't need a name and then lambda expression is a reasonable candidate for the next question a student sent us a environment diagram for the section in the textbook about newton's method which is fine for you to read it is not required reading it is no longer part of the course that you need to understand this example but still a good example and so we talked about it for a minute but didn't really answer the question right thanks for this question um there's a section in this in the textbook about um an application of higher order functions called newton's method and it's i think quite a nice uh example i didn't come up with it it's borrowed from the textbook that this course was based on uh but we've taken it out of the course because it requires you to know something about calculus and also it's just quite involved so i left it in the textbook because you know i think it's it's worth working through if you really want to but you do not need to understand it it's intentionally been removed from the core cell that used to be part of the lecture series um so that uh you can kind of focus on more reasonable examples now the example really kind of takes a full lecture to explain so i guess i won't attempt to explain the entire thing now give you a little gist which is that um there's a very generic kind of iteration about searching for the right answer for something kind of like what we did earlier in this q a when we were searching for the square root except for this can do it more cleverly because you can pick any way to update you want so in our search we started with one two three four five six but maybe there's a better way of searching for a numeric value than just counting up the integers and that's exactly what uh newton's method which is like an application of differential of uh of calculus lets you do and um yeah so it's kind of like a a smarter version of searching for numerical answers that lets you not just compute square roots of the integers or sorry of perfect squares but it could let you uh compute the like numerical approximation to the square root of 2 or something like that how would you learn more about this well there is a whole video series i thought it was in the textbook if it's not maybe i'll link it there i i i i don't think it is john because i i it might be worth uh we can add a link to that okay if you have your timeline for newton's method this is a standard numerical method for finding zeros of a function it's a really lovely um algorithm you have to know a little bit of calculus you have to remember what a derivative is in a tangent and things like that um and so if you're interested in going off on that uh tangent that uh that's funny um you can do that um but it's it's i think john's right there this would take too long for us to walk through this whole example here okay the next question was about how multiple assignment works when you have two names on the left side of equals and two expressions on the right side separated by commas and in particular how that worked for the fibonacci example from lecture so the most important thing to remember when you have this kind of command is the right hand side is fully evaluated before you do the assignments right so it's not like you go left to right do the the left one assign it to the left variable and then do the right one assign it so the whole right hand side of the assignment operator gets evaluated you get values there and then you assign them to what's on the left hand side and in that regard there's no cross talk right so yeah john did a nice visualization here so we can see it yeah the stuff on the right is evaluated until you're left not with names but with numbers right so if we're about to do this one we look up kerr is three we look up pred plus curve is five now we have three and five the numbers and we then assign the new names pred and occur to three and five and therefore it doesn't kind of get mixed up right and by the way same thing if i just said x is equal to three plus seven i fully evaluate what's on the right hand side i break down that expression until i have a number or a string or a boolean or whatever it is and then i go and do the assignment yeah great question so if you create a lambda function by evaluating a lambda expression do you have to do something with the result immediately or risk losing track of it forever because it has no name and the answer is yes if i just write this on a line and then on the next line i want to call it somehow i can't call it with f because it doesn't have the name f it's effectively lost just like if i had written 12 here and i had not done anything with it that 12 would be lost unless i did something with it now what can you do with it you can assign it a name then you could refer to it later you could pass it in and then f could refer to it and then like if you're in the context of another function you could return it and then whoever called f could refer to it as the return value but if you just leave it there alone or i guess you could call it that's another thing you could do uh but if you just leave it alone then there's no way to access it later it's effectively gone great so to summarize all that lambdas are just anonymous functions they're just a shorthand way of writing a def statement um they're convenient when you're passing things as parameters or defining things within functions that's it and again i want to remind just emphasize particularly in the early days of looking at the lambdas read them in a very specific way you see lambda this is a function it has a parameter x and it returns whatever is to the right-hand side of the colon and remember again in python all you can do is a return so these are tend to be very simple and compact um thank you that yeah that's it right there i'm probably being distracting and so it's just it's conceptually it's not really new it's just a different way of writing it good question so the question is when you're defining a lambda could you put a function here and the answer is yes yeah if it's defined before if f was already something then i could have a function that takes an x ignores it and just returns f instead and i guess we'll call that g now this is kind of a funky thing this says take into ignore it and return f so now g of 2 is going to give us a function that adds 1 to things and if we want to add 1 to 7 and get 8 then we can do that you can also return a lambda right so the lambda function can return its own anonymous function right it can just be another lambda expression i think we've already seen an example of that in fact that's true so like what that would look like is if we didn't have f at all and instead we had uh return a function that adds one to things then here this doesn't refer to x so two is still ignored and it's just gonna compute eight again okay i might be admitting people into your nine o'clock meeting john i'm not really sure um but i think that's it for time uh thanks everyone for the great questions uh uh we'll edit this video and it'll be online you know in a day or so yes and so sorry about not explaining lambda before using them 