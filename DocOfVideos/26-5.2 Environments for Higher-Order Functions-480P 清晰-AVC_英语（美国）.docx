Let's talk more about higher-order functions,  and how they interact with these environments   we've been talking about and diagramming. So  a higher-order function is a function that   takes another function as an argument value  or returns a function as a return value or   both. Here's the good news. Our environment  diagrams actually already handled the case   of higher-order functions, meaning the rules I  taught you already work, even if we're passing   functions around instead of just numbers. So  now, you know the big secret. The whole reason   I told you about environments and environment  diagrams, is so that we could explain exactly   how higher-order functions work. Let's have a  demonstration. Let's have a demonstration. So   let's say I write a function called apply twice,  which takes a function and a single argument. And   what it's going to do is apply that function  twice, by calling f of f of x. Apply twice   is a higher-order function. Why? Because it's  going to take another function as an argument.   We better create such a function. How about our  friend square? Now we're going to run Python   starting with this file. So we can square things,  of course, but we can also apply twice the square   function on the number 3, and it will square  once to get nine, square it again to get 81.   Notice the syntax that I've used. I have applied  twice as a function that calls on two arguments,   one of which is the value of square, and the  other is the value of 3. Those are the two   arguments passed into the apply twice function,  which then squares and squares again. Let's look   at this environment diagram. So the first thing  I do is define apply twice. I've defined square.   Notice nothing has been squared yet. But now I'm  going to call apply twice on square and 2. Okay,   so apply twice gets called. Introducing a new  frame, the formal parameters f and x are bound to   the argument values, the square function and the  number 2, at which point the body is executed. And   the body is f of f of x. So in order to evaluate  f of f of x, I first have to evaluate both the   operator f and the operand expression, f of x. So  f of x requires a call to f, which is currently   bound to square. So I call the square function  on the number 2, which is what x is bound to.   By squaring 2, I end up with a return value of 4.  So this inner f of x right there evaluates to 4,   and then I'm going to call f on 4. And what's f  again? Well, that's the function that squares.   So I call square on 4 and that returns 16, which  is eventually bound to the name result. 16 is what   you get when you square 2 twice. Okay, let's look  a little bit deeper at what happened right there.   After executing the first two def statements, all  I have are names for some functions bound to those   functions. I haven't called either one yet. Now, I  apply twice square and two, which means I figured   out what apply is, I figure out what square is  and then actually apply that function to the two   arguments, the square function and the number 2.  So applying a user-defined function involves three   steps, creating a new frame, binding the formal  parameters, f and x, to the arguments, and then   executing the body, which in this case, has just  returned f of f of x. So when I actually apply   this function in the next step, I end up with this  environment diagram. I kept the old one around   just so you can see the difference. So when you  apply a user-defined function, we've created a new   frame, this one's called f1. It was created for  executing the body of the apply twice function.  And it has the formal parameters f and x  bound to the two arguments, the arguments   that were passed in, or the square function  and the number 2. There's the square function,   there's the number two. You can see the bindings  right there. At this point, we can execute f of   f of x. And how do we figure out what f even  means? Well, this is our current environment,   which is a local frame followed by the global  frame. And when we try to look up a name in the   current environment, we look in the first frame.  If it's not there, we look in the second frame,   etc., until we find it. But f is actually in the  first frame. It's right here. We see the name   f is a name given to the function that squares  things. That's how the squaring actually happens.
