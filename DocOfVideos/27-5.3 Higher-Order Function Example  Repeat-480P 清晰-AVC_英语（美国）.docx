Let's work through an example using a higher-order  function. I'm going to type in some code,   and you can try to figure out what it will do. I'm  going to define a function called repeat, which   takes in f and x. And while it's the case that f  of x does not equal x, that does not equal, I'll   rebind x to be the return value of calling f on  x. When that while statement completes execution,   I'll return x. Now we're using f as a function,  so we need some function to pass into repeat.   I'll define g of y to be a function that adds 5  to y and then divides by 3. Our division by 3 in   this case is using floor division, which throws  away any remainder. I'll save that file and load   it into Python. And now I'll repeat g on 5. Now is  a good time to pause and think about what's going   to happen. Work through it yourself because I'm  gonna move on in three, two, one. The answer is   2. And looking at an environment diagram will help  us understand why. So I've put the same code into   Python tutor. But I'll bind the result to a name  called result. So we can see it at the end. I'm   going to execute the code without displaying exit  functions. The idea here is that when we don't   need a frame anymore, the Python tutor will remove  it from the screen so that we don't have to keep   looking at it. Okay, we begin by executing the def  statement, which happens all in one step. And all   it does is create a new function with the name  repeat bound to that function. Next, we execute   the def statement for g. And finally, we're going  to evaluate this call expression repeat g 5. G is   currently bound to this function, 5 is the number  5. And so those are the two arguments that we pass   into repeat. So now we have a frame for repeat or  the formal parameters, f and x, there they are,   are bound to the arguments that we passed in,  which have this g function and the number 5.   Now we execute the body of repeat. The first thing  we do is evaluate the expression in the header of   the while statement to figure out whether it's a  true value or a false value. Now, as you can see,   in this expression here, there's a call expression  within it, f of x. So we're gonna have to call f   on x. Now, what's f? It's right here. So we call  f on x. And that means we introduced a new frame.   Now notice that we didn't call the frame f, but  g. And that's because it was the g function that   actually got called. It just happens to be that in  the previous environment, we had a different name   for that function. We called it f in this case,  but originally, it was called g. So now we're   making a call to this g function right here, whose  formal parameters y. We've passed in an argument   value. That was whatever x was when we called it  here. So now we've passed in 5, and we compute   5 plus 5 is 10, divided by 3 is 3. There was one  remaining, but we throw away the remainder. That's   what this double slash means. Okay, so now we have  a return value of 3, which means this expression   is 3, which is not equal to x is 5, which means  that we continue because this is a true value. 3   does not equal 5. We're going to execute the body  of the wild statement, which means calling f of x   again and binding its return value to x. Now x is  currently 5. We pass that into the g function. We   get back 3 just like we did before, and that's  bound to x. So now we returned to step one,   evaluate the header expression in the while  statement. But this time, something's changed.   Of course, we still have f bound to what it was  before, but the name x is now bound to 3 instead   of 5. So when we evaluate f of x, we'll be calling  f on a different argument. This time it's 3. 3   plus 5 is 8, divided by 3 is 2. So f of x is going  to evaluate to 2, x will evaluate to 3. And so   those two things are not equal and we will execute  the suite of the wild statement one more time.  Now we're going to call f on 3, get 2,  and we'll rebind x to be 2 instead of 3,   which is now done. And we return to step one.  Finally, we call f of x, where x is now 2,   introducing a frame for the g function with  its formal parameter y bound to the number   2. 2 plus 5 is 7, divided by three is two. So I  got the same value out as I put in, which means   that this whole expression right here will now be  false because two does equal two. So it's not the   case that two doesn't equal two, which means  we're finished executing the while statement.   We can move on to return x and x is bound to  two. And that's the result of our computation.
