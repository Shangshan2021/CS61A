Let's talk about environments for nested  definitions. Last time I showed you the following   example. I can create a make adder function, which  takes in formal parameter n. It creates another   function within it, make adder k, which returns  k plus n. Now, the make adder function returns   the adder function which was defined within its  body. So make adder, what it does is it creates   a new function and returns it. It doesn't actually  add things. If I load this function into Python,   what happens? Well, I can create new functions  on the fly. I can create a function add three by   calling make adder on 3. And now I have a function  that adds 3 to things. I could add 3 to 4, I could   add 3 to 5, I could add 3 to 6. And somehow part  of this function add three is the number 3 that   gets added in. How is it that we have a function  that has data within it? Well, let's look at the   environment diagram and we'll understand exactly  what's going on. So here's the example. I define   make adder, which doesn't execute its body, it  just defines a new function. Then I call make   adder on the argument three, which does introduce  a new frame with the formal parameter n bound to   the argument 3. Next, I define the adder function.  That's the first step in the body of make adder.   When I define the adder function, I create a  new function value. And then I bind the name of   the function adder to that value in the current  frame, which, notice, is not the global frame.   So the make adder frame and its environment have  access to this adder function. But so far, there's   no way to refer to it from the global frame. But  that all changes when we return. So what a return   statement does is it brings information  from a local frame back into the frame,   that was the current frame when we call this  function in the first place. So we return back to   a particular point. We were evaluating this call  expression. And so when we return, we're going   to go right back to the point where we evaluated  this, and we were about to bind it to the name,   add three. So what is the return value that we're  going to bind to the name add three? Well, here it   is. The return value for this function that we got  by figuring out what adder meant in the current   environment and returning that value. And that  value is this adder function. So in the next step,   I returned right back to where I was before,  which was in the global frame, having evaluated   make adder three. And the value of that was this  function adder, which I bind to the name add   three using regular assignment. Remember, we can  give multiple names to the same function. Okay,   now we have add three, which is a function that  adds 3 to things. How does it do that? Its body   is just k plus n. Well, let's call add three on 4  and find out. So we introduce a new frame, with 5   bound to 4. Its parent is actually f1, the frame  here. So even though we returned from make adder,   we still have access to its contents because we  have frames that we've created whose parent is the   make adder frame, which contains the name n. I'll  go through this in detail in a moment. But what   happens here is that we evaluate the expression  k plus n in an environment that starts with f2,   followed by f1, followed by the global frame.  We find k equals 4 right there, we find n equals   three right there. And that's how we get the  number 7, which is bound to result. And then   we're done. So this right here is the environment  diagram for the example I just showed you. Let's   talk about it for a moment. Here we have a nested  def statement. And we also have something we've   never seen before, a parent of a function that's  not the global frame. So what happens is that you   set the parent of a function to be whatever the  current frame is, when that function was created.   And how did this adder function get created in  the first place? Well, it's part of the body of   make adder. So make adder was the first frame of  the current environment when this adder function   was created. And that's why its parent is f1.
So when the parent is f1, then we call the   function adder, we copy the name down into the  new frame, we copy the formal parameters down   and bind them to the argument values. And we also  copy the parent of the function as the parent of   the frame. So here's an explanation for why we  have parents of functions in the first place.   It's so that when we call those functions, we can  write down the correct parent for the frame. Now,   why do we need parents for frames? Well, that  tells us how to find the current environment. So   the current environment, when we actually evaluate  k plus n, starts with the adder frame, and then is   followed by its parent, which is f1, followed  by its parent, which is the global frame. I've   abbreviated it as G just so I could fit everything  on the screen. It's fine if you evaluate it as   G as well. Okay, so now we have a three-frame  environment. If we look up the name k in that   environment, we look here first, that k is 4,  and we're done. If we look up n that environment,   we look first in the first frame of the current  environment, but there's no n there. So then we   have to look at the second frame, which is the  parent of the first frame. That's n is bound   to 3. And so we can get k plus n is 4 plus 3 is  seven. And we're done. Okay, so what are the key   points? Every user-defined function has a parent  frame. And all the other examples we've seen,   it's the global frame. But when you have a nested  def statement, it won't be. The inner def is going   to have the frame of the outer def's function  call. The parent of a function is the frame   in which it was defined or created. Every local  frame has a parent frame, as we've seen. And the   parent of a frame is the parent of the function  called. So that is supposed to explain what I did   here. When I created this adder frame, I copied  its name, I also copied its parent annotation,   and bound its formal parameter to its argument.  So all the information that you need in order   to create this frame correctly, adder parent  f1 k, is right here in the function value. So   if you know which function you're calling, you  know how to write down its frame correctly. So   here's a little guide to how to draw environment  diagrams, so that you can draw them on your own   without using Python tutor. And that's really  helpful because then you can understand even   complicated examples. When a function is defined,  you will always create a function value that looks   like this. Its parent is the current frame. So  that's why when we created the adder function,   we were in the make adder frame. And so we wrote  down that the parent was f1, which was the label   for this frame. Now we don't write down make adder  because there might be multiple different frames   called make adder. But each one will have a unique  label. So that's why we use those. We bind the   name to the function value in the current frame.  So that's when we had the name adder referring to   this function. When a function is called, we  create a new frame. So we add a local frame,   titled with the name of the function being called,  we copy the parent of the function to the local   frame, and then we bind the formal parameters  to the arguments in that local frame. Finally,   we can execute the body of the function in the  environment that starts with that local frame.   If we need to look up names in that environment,  we follow the parent to the parent of the parent   till we reach the global frame. And wherever we  find the name first, that's the value that we use.
