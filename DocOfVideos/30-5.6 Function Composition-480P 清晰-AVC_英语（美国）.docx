We'll conclude the day with a big example,  function composition. Okay. So what I'm going to   do is I'm going to define square. And I'm going to  define triple, which just returned 3 times x. So   here are some simple functions. But now I'm going  to define a higher-order function called compose1,   which takes in two different functions, each of  which takes one argument. And it defines a new   function h also over an argument, which returns  the result of calling f on the result of calling   g on x. So this is composing the functions f and  g into one new function h, which will return.  Okay, so how does this work? We can square 5,  we can triple 5. Now we're going to define a new   hybrid function called squiple, hich involves  composing square and triple together. Okay,   so squiple is a function, where when  I call it on 5, 5 first gets tripled,   and then that gets squared. 15 times 15 is  225. So compose1 is very general. it takes   any two functions and composes them together.  For instance, we can also make a tripare,  which we create by composing triple  with square. So if we tripare 5,   we get 75. Because we square five, that's  25. And then we tripled that, we get 75.  We can even squadder. What's squadder? Well,  that's a function that is created by composing   square with make adder of 2. So this gives us a  function that adds 2 to things, this squares. And   if I want a squadder, let's say, 3, then 3 plus  two is 5, and that squared is 25. By the way,   you can write one call expression that does all  of this together. Let's look at the environment   diagram for that one. Okay. We have square,  we have make adder, we have compose1. We call   compose1, which defines the adder function  and returns it. Now we've passed that into   compose. So compose has f bound to square and g  bound to adder. At which point it will define h   and return it. So I made everything smaller so  that it's going to fit. So what happens? Well,   h is going to call f of g of x, f is square,  first, we need to compute g of x, which involves   calling the adder function where k is bound to 3,  and n is 2. So that gives a return value of five,   which gets passed into square which returns 25.  The answer to h is 25. And therefore, that's what   you get for this whole expression. Let's take  a look at that image. This is the same thing   you just saw. But I'll annotate it a little bit.  So when we evaluated this whole call expression,   first we evaluated the operator. Compose1 is easy  to evaluate. Square is easy to evaluate. But this   is a call expression that involves some work.  So we called make adder on 2 and the result was   an adder function. Then we called compose1 on  square and make adder and the result was this   h function. And the return value of make adder,  the adder function, was passed as an argument   to compose. You can see that here. Compose  is here. It has one of its arguments, its g,   the adder function. Okay. So now we have h, now  we can call h. What happens when we call h? Well,   first we evaluate f of g of x, which involves  evaluating g of x in this environment. So   what's f? Here. What's g? It's there. What's x?  it's there. And in order to get g of x, well,   I have to call adder. And so k plus n, the body of  adder, gets evaluated in this environment, which   has three frames as well. What's k? It's there.  What's n? It's there. So there are two different   environments each of which has a length of 3 and  together, they help us compute the number 25.
