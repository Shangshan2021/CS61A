An interesting consequence of the way environments  work is that a function can refer to its own name   within its body. Let's look at a couple of  examples. If I write a function, print all,   that takes some argument and prints it, I can  have it return print all. This isn't surprising,   actually. When you define this function, all  that happens is that the body is squared away,   waiting for a call. By the time it's called, the  name print all already exists, and is already   bound to a function. So if I print all 1, it will  print 1. And then this expression will evaluate   to the print all function, which I could call  again. And that expression will evaluate to the   print all function so I could call it again.  Let's see what happens. Print all is defined.   By the time I call print all, notice that print  all is already bound in the global frame. I call   print all on the first argument 1. 1 gets printed  out. In this environment diagram, we also show the   print output. And then the function print all is  returned. Same function, we looked it up by name,   and we return it. Returning it means that it's  the value of print all one. So that's exactly   the function that gets called on the argument  3. When I call print all on 3, 3 gets printed.   Print all is returned. Now I'm going to call that  on 5, 5 gets printed, print all gets returned,   and execution is finished. So even though this  refers to itself, since it doesn't call itself,   it's not going to run forever. It's up to this  call expression to figure out exactly how many   times print all gets called. And we see the output  or the arguments of the separate calls. Here's a   slightly more involved example. Okay. I'm going to  write a function that sums all of the arguments so   far. We'll call it print sums instead. And  it's not going to return print all because   print all doesn't exist anymore. It will return a  function. It's going to return a function that I   define within the body of print sums. Call next  sum, which takes an argument y, and immediately   calls print sums on x plus y. That's exactly where  the summing is happening. So x is the sum so far,   y is the next number, and print sums just returns  next sum. Let's see how it works. First print sums   is defined and then called on the number 1. The  sum so far is 1. And so that's exactly what gets   printed out. Next, we define a new function and  return it. We return it as the value of this call   expression. So we'll call it on the number 3. So  next sum has just been called on the number 3. 3   is not a sum. It's just the argument here. Where  we get a sum is that we're going to add x, which   is here in the current environment, in the parent  frame of f2 to y, and get 4. Now what happens to   that 4 is it get passed into another call to print  sums. So there's another call to print sums. Here,   the argument is 4, which is the sum of 1 and 3.  And what does print sums do? Well, it just prints   out the sum that it receives. And then defines a  new function. That new function gets returned. And   where does it get returned to? Oh, it's the value  of print sums 1, 3. Notice that the function we're   returning, which has parent f3, knows the sum so  far, of four. And so if it wants to compute the   sum of the whole thing, 1 plus 3 plus 5, it needs  that 4, along with the 5 that I'm about to pass   in. So I've just called next sum for the second  time. Notice that now I'm passing in 5. The parent   is f3, which contains 4, which means I can compute  the total sum, 9. And what do I do with it? Well,   I compute it here, 4 plus 5. I pass it into  it and third call to print sums. And print   sums prints out 9, which is the sum of 1 and 3  and 5. So by having print sums define an inner   function and this inner function returning a call  to print sums, I'm able to use the arguments here   to memorize values that get computed along the  way. Those values are passed in as arguments.   They appear inside the frame, which is the  parent frame of the local frame for next sum.  Next some does the summing in this case, and print  sums just prints out whatever it gets. So here's   the same picture. And it's important to notice  what goes where. When you actually have the call   expression print sums 1, 3, 5, the first call  is to print sums, but the other two are to the   function that prints sums returns, which is the  next sum function. So the next sum function just   tells Python what to do next in the next call.  The next call first gets 3, the call after that   gets 5. So we see that in the print some frame,  we see sums 1, 4 and 9. In the next some frames,   we just see the individual arguments that  get passed in directly, which are 3 and 5.
