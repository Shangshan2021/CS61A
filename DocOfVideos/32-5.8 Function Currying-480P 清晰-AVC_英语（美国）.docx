Currying. Function currying is a  way of manipulating functions. So,   for the last two lectures, I've implemented  make adder for you. It's becoming a bit of   a tradition. So let's do it again. Def make  adder takes an argument n, returns a function   which takes an argument k and returns n plus k.  Notice that I have now used a lambda expression,   rather than defining a function called adder. But  the effect is the same. So once I have make adder,   I can write a call expression where the operator  is itself a call expression. Make adder 2 gives me   back a function that adds to 2 things. I pass  in 3 to that function and add 2 to it to get   5. So I call make adder this way. Two calls are  required to actually get a number out. And that's   by contrast, we have add, which is a function that  just takes two arguments and gives you back their   sum. Now the relationship between make adder and  add is a general one. It's between functions that   take one argument and give you back functions and  a function that takes multiple arguments and just   gives you back the eventual answer. So we can  express this general relationship in code. I'll   define a function called curry2. 2 means that the  function I pass in takes two arguments. And what   it does is it defines a function g, which takes  one argument that defines a function h, which   also takes one argument. a different argument.  What h actually does is it returns f, called on x   and y. G returns h and curry2 returns g. Now what  have I done? Well, I've created a function curry2   that turns two argument functions such as add  into higher-order functions, such as make adder.  There's the add function. If I want to create  an add, or if I want to create an equivalent   to make adder, all I have to do is curry the add  function. Okay. Now I have something that behaves   just as make adder behaves, which means I can  create add three by calling m on the number 3.   And now I have a function that adds 3 to things.  It is the case that I could express curry2 as   a nested lambda expression. It is a function  that takes f, returns a function that takes x,   which returns a function that takes y and  returns f of x y. Just as before, I can apply   my new curry2 to add and then add things with  it via a higher-order function. So that's the   general relationship. Currying is the act of  transforming a multi argument function into a   single argument higher-order function that returns  a function that takes the rest of the arguments.   Currying was discovered, not by Haskell Curry, but  by Moses Schönfinkel. And then it was rediscovered   and made more popular by Haskell Curry. So some  people think it should be called Schönfinkeling.
