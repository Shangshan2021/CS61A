here's a recording of the q a session for lecture number five as usual i've edited out the students and we've tried to repeat their questions sometimes you'll see me pop up in order to repeat a question that we forgot to repeat in the live session here we go so the question was about like uh what's going on with the environment diagram of print sums from lecture so here's the example i think i may have changed the name with the inner function a little bit but it does the same thing and yeah what happens when we start with just print sums of one well print sums even though it has a def within a def it all gets executed in one step we just create the print sums function the fact that it has inner stuff doesn't really come into play until after you call it and when we call it we print and then we create a new function so what's interesting here is that this new function we create has parent f1 which means it knows about n the parent frame is the same f1 as this f1 basically tells you that the body of f can refer to anything that's in this f1 frame so uh when we look at the body of f which prints sums n plus k we don't know what k is yet right that's what f will get when it gets called we do know what n is one and this returns this function called f of k when you write return f that looks up what value is bound to f turns out it's a function and that's the return value for this whole so what happens when we extend this well one way we could extend this is to capture that result in a name and then call that um three let's say and we can give that a different name and we could call that so this picture gets slightly more involved everything was the same up to the point where we returned when we return this return value is now bound to the name g in the global frame y in the global frame because this assignment statement j equals print sums of one was a global assignment statement it's not invented it's not part of the body of a function and so d gets found in the global frame but what it gets bound to is the function that was created in the local frame so it has this local parent now we have a name for it we call it on three what we're calling is this f function when we call it we have to construct its frame correctly that means giving it the correct name not so important giving it the correct parent really important giving it the correct names and values also really important so k is bound to this three that we passed in but it also knows about n equals one so when we execute its body which just says print return print sums and plus k we're gonna add these two numbers together one and three before we call print sums so we're gonna get the number four and then we're gonna call print sums where is print sums it's not in this frame it's not in this frame oh there it is in the global frame it's just this function okay so we call print sums we're calling it on 4 because we computed that before we called it and now it's going to print because that's the first thing that it does it will print the four and it will create a new f function same code different parent therefore different value of n and that's kind of the whole point of this example is that we're summing up things as we go by always keeping track of the sum so far in this name n in a print sums frame but every time we call this f we're making a new print sums frame with a new value for it so let me emphasize here one thing about the environment so prior to these examples we had basically the function frame in the global frame and it was pretty straightforward you look for things in the local frame if you end up binding in the global frame and you know you're done and it seemed like an over overly complex formalism for just that simple thing but now with your functions within functions you really see the importance of these environment frames to keep track of um what the variables are bound to yeah so and and one of the things that's interesting about environment diagrams is that every time you call print sums you get a different frame every time you execute the body of print sums you're executing this def statement ff again and so you're getting a new f function same code but different parent which means basically a different end each time okay so if we walk forward a little bit more we're going to return that and it will get bound where 2h in the global frame so now we have a way to refer to this f where it's n is four which is one plus three so if we want one plus three plus five well we already have one and three together it's right there it's n equals four and so we can add five to that by calling this function which was originally called f but in the global frame is called h so we call h on five introduces a new f frame whose parent is f3 f3 is the one that has the sum so far that's n equals four here we call print sums on four plus five is nine that's one plus three plus five is nine and that gets printed out and john maybe now you can go back to the original one where you wrote print sums of one three five and just we can explain why those are exactly the same yeah so if you look at this picture we have global names for g and h it turns out that we could avoid those instead of saying give this result a name and then call it by name we could just call it directly so this thing was briefly called g in our former example but now we're just calling it print sums one and likewise instead of calling this h we could and then calling h we could just call it directly and i believe this is the example that was in the lecture we're going to see the same behavior up here 149. we're actually going to see exactly the same thing down here all the names all the parents everything is identical nothing changes the only thing that changed when we switched to this version is that we don't have the global names g and h and w anymore because we're not giving these intermediate functions names instead we're just calling them right away so the question was why does this end up having a return value of f instead of a return value of print sums because it says print sums right here it's a good question the reason is that we're not just writing print sums we're writing a call expression that evaluates something whatever print sums returns is going to be the value of this whole call expression and that's what that's what will get returned from f so this says f returns whatever print sums returns which turns out to be another f function so in this sense it says f is going to return an f and that's what we see eventually in f2 this f call returns an f now it doesn't actually return the same function that was called to make this that was this one it returns a new f and what's different is the n value is different because the parent is different so if this example had been slightly different and we had written that then the first call to f would have returned print sums but since we called it we get uh another f that gets returned instead yeah this is a really important distinction is on line four right now you're not returning a function you're returning a value that is the result of evaluating a function in line five you're returning the function and let me just state the obvious but just to make sure um you're also that depth statement that starts on line three that function doesn't get evaluated you're just defining a function yeah so that return on line four that's just part of the body of that internal function and then of course you return that f that is what gets returned from the print sums the question was actually about our midterm question but i think we've narrowed down to the essence of what was going on and we'll try to answer a few questions along the way so kind of why does the environment diagram for this look the way it does here we're defining a function which actually depends on why even though y isn't defined yet that's okay because when you execute the daf statement you don't really do anything with the body yet you just kind of swirl it away in there it's part of this function but we haven't tried to execute it so the fact that we assign y later is fine when we call f of 2 x is bound to 2 and then it starts assigning things so me is bound to 1 we assign a g to some function if we change me now then uh it's changed in the f1 frame which means that if we were to call g at this point let's say on seven the value of me that it would use since there's no me here we look at the parent is actually two so this would return two instead of one even though me was one when this was created the fact that it got changed later does affect the behavior of g and so 2 is going to get printed out and then this can return x plus y where we look in here and we find the x we look in here for the y but it's not there so we look at the global phase so you do have to be conscious of the fact that assignment can change the binding between names and values in an existing frame and that affects all the functions that were created with that frame as the parent i think maybe one more question that was in here is what about the order of names within a frame and it really doesn't matter uh the order of frames does tell you something that tells you what was called first and what was called second um but the order of names within a frame you could think of it as just kind of a grab bag of names and uh so if you saw on some example that this was like x me g instead of xgb that's the same yeah that ordering i think that was your question right austin that ordering there is is is not the order evaluation but as john just said the order of the frames really matters but once you're in an environment you can only have every variable can only have one value and so it doesn't matter what order you put them in there's no precedence there that you have to worry about the next question was what is currying and what does it do so let me give a high level explanation of it and then john's going to bring up an example so what currying does is it takes a function that takes more than one parameter two three four five whatever and it converts it into a function a series of functions that each take only one parameter yeah so that's that's the sort of the high level description of it take a function with multiple parameters f of x y and turn it into a a series of functions that take g followed by an h followed by whatever okay so let's take a look at that now and then we'll make sure we understand it uh yeah so um here's a definition that only works for functions of two arguments you can imagine writing one that takes an arbitrary number of arguments but it requires a little bit more effort so we'll focus on this one for now and you know the point is to take a function that already exists and kind of change how you call it it doesn't change the behavior of the function like when i curry pow pow is that function that raises one number to the power of the other i don't actually have like some new mathematical ability but what i do have the ability to do is bundle together the function the pow with its first argument by for example calling curry pow on 2.
so now i have a function where whatever i call it it will raise 2 to that power so 2 to the power of 5 should be 32 and we'll make sure this works and then we'll talk about why it's useful yeah okay so x got to be 32.
sometimes when you have a function that takes two arguments and you're writing a long program you know the first argument early and you don't really know the second argument for a long time and so it's convenient to be able to give a name to the function with its first argument filled in already um you can do this explicitly every time like if you could i could have instead of calling curry 2 i could have written 2 to the y returns pow to y um currying just lets you write it in a more compact way you could just say i i want to curry 2 pow and then i want to fill in the first value as 2.
so so john said it really nicely there you can think about the power of currying as the ability to sort of almost like halfway evaluate right so like so the the function here two to the is very specific you don't have to pass multiple parameters and and again it's important to understand this gives you no real new mathematical powers right there's nothing that you can't do with the full function it's sometimes just convenient to only have to pass in a single parameter and specify the other parameter sort of in a fixed way and somebody asked in the chat is this similar to giving a default value in the def statement and the answer is sort of yeah yeah um it is we had defined how with uh with um with x being by default two then you could just call it with one parameter and that was the default the only difference it's slightly different in terms of functionality conceptually that is the same idea and in your hog project you see a lot of these examples where you know some things early and you don't know some things later so it shows up in the strategy functions where a strategy kind of takes in some facts about the strategy this is like a question 10 and 11 like what's my cutoff for um rolling zero instead of rolling five dice or whatever and uh like that's one input but then the rest of the inputs are what the actual scores are in the game and you don't know those until you're playing the game so you can fill in some of the values that you need to do the computation before you even start playing to kind of set up your strategy but then the rest of the values don't come until you're in the middle of the game you start rolling and somebody's asking about the name curry 2 in the chat and that's just an arbitrary name john just called it that because it's a curried function but he could have called that um z or my name um yeah so the reason i call it curry 2 is that curry is the like computer science name for this thing and uh the two was to say that f has two arguments yeah great question so the question is about this slide from lecture and why the make adder frame comes before the compose one frame when you look at the code it seems like compose one is getting called right away uh turns out it's not so here's the detailed rule for evaluating a call expression is that you evaluate the name compose one so you do know you're going to call compose one but you don't call it yet until you know what you're going to call it on so you need the function that you're going to call and its arguments before you can draw the frame so for this reason we know we're going to call compose one but until we've evaluated square and make adder two we don't actually make the call to compose one and this is just how python works but it's a pretty natural way for it to work um because you know it doesn't know whether calling makeout or two is going to take forever it might have an error in it who knows so it doesn't actually create the compose one frame and start executing the body of compose one until after the arguments are determined and to determine the arguments you have to evaluate square well that's quick that's a name lookup but this is a call expression and so that's why the string comes first got it so just to clarify for that specific line it needs to call the the arguments first square and make adder before it actually calls compose one i i would say you have to evaluate you have to know what the actual parameters are yeah so if i call a function with two and four then that function is ready to go i i know what the values of the parameters are but in this case that second first parameter is fine just the name of a function nothing to do notice there's no parens there i'm not calling the function i'm passing the function name as a parameter but the second one is a function call so i've got to go off and evaluate that i need to know when i'm passing in once i know what i'm passing in i can create the frame find the formal parameters and then start evaluating exactly and like yeah for anyone else who's still kind of wondering about this the simplest possible example would be if f adds x and y together you don't call f until you know what x and y are so if you have some other function that adds one of the things and you call f of two and g of three you don't actually call f until you know you're adding two and four together and for that reason you see the g frame first yeah great question so uh if you have i'm going to show you a simpler example of the same thing i think which is here we're gonna compute y equals f of f of f of three so what is this gonna do well f adds one of things so we're gonna add one to get four everyone to get five add one you get six when you visualize the execution you see f1 f2 and f3 all appearing unless you change the way this environment diagram is displayed to only show you what you need at which point uh well let me just do it from the beginning uh it will create the f1 frame when you return from this f1 frame you really don't need the frame anymore that's why we gray it out but in this version where you change that option it actually just disappears so that's why f1 and f2 and f3 aren't there is that you know sometimes when i run python tutor i don't display exited functions now i recommend just displaying them all the time because then you can really see everything that happens and uh yeah so when we talk about it in discussion or exams or whatever we just kind of show the whole thing but sometimes that's unreasonable you know like if you want to see what happens with something really big sometimes the the best way to visualize something like that is to not display it and then you can kind of see the progress of this going from four to five six to seven eight um there is a a a little issue kind of technical issue that i guess i'll make people aware of which is that if you just go to pythontutor.com and then you get a version where the default is to hide exited frames as opposed to showing them all whereas if you go to tutor.cs61a.org you go straight to a version that says yes show all the exit frames so that's what i try to use consistently but clearly in video 3 of today i forgot to do that and so that's why some of the frames disputed yeah so the question is if you have two inner functions so they have the same parent frame can they somehow refer to each other's formal parameters so could for example h which can refer to z and can refer to x could it somehow refer to y as well and the answer is no um and maybe for a good reason when you call h uh there really isn't a y like uh in order to get this far there must have been an x right because f has to be called for you to get here uh and there has to be a z we gave the z right there seven but there kind of isn't the value for y at this point so uh these names and these names can't really interact in any way and you can't look up one from the other so that's exactly right of course and by the way that's true whether those were embedded in a an f or just not embedded in all in the global frame same you'd have the same problem now let me ask a follow-up question if in g john i s i assigned uh the variable a to b1 can i can i can i have used that and we can go back to embedding that within the the def uh acts but is that accessible sorry i shouldn't have had you uh another local variable there now the question is can i related question is can i can i access that inside of h and the answer is no also the scope of that parameter is g h doesn't get access to it exactly the only way you could get access to a you'd use it directly or you could use it within a function that's in here uh you can talk about a but you can't do anything with it from the outside unless it's returned so the question is what's going on in this lab example this is from lab two question one where there's a function that takes f returns a function that takes x and then calls f on x now we have a function that takes x and squares it what would it be like to recall higher order lambda on 2 and then g so when you call higher order lambda on 2 you are calling a function that takes an f and you can kind of peek ahead and see what is it going to do with this f it's going to call it but passing in 2 for this is going to give you a problem eventually and that problem is you're going to try to call 2 so it would be as if you were saying something like f equals 2 and then i call f on 3 this will give you an error which says f is not something you could call because it's a number um yeah so uh what else happens here after we've created a function that's going to call 2 on something is we pass in the thing that it's going to call 21 which is g so g refers to a function that squares that will be our value for x so another way to look at this is to say x equals g that would be kind of like you know there's there's basically two ways to do assignment you can use assignment statements or you can pass values into functions so this would bind f to 2 and this call would bind x to g or i could just write it out explicitly like this and then if i call f of x i kind of run into trouble so let me just uh comment these out and show the behavior if we wrote this function i mean this set of lines and then we'll see that basically the same thing's happening in that example so here this creates a function of squares this creates a number uh so f is 2 x is this and we're just calling it the wrong way around so we're getting this int object is not callable if instead we had called the function on the number we would have got that before we kind of did it the wrong way around by the way i find that so offensive calling the function name x and the parameter f it's sort of like there's a part of my brain that is exploding looking at that right call x2 knock that off stop calling exactly exactly so this is why you know interpreters don't care but you have to write code yeah i know only hundred money cares anyone can understand exactly so uh if we look at this here we call this function which takes f it's bound after two it's done that thing that's so offensive uh using f as a name for a number and what we get back is the result of evaluating lambda x colon f of x that's why we get another lambda uh function even though this one says line one and this one says line one these are different functions this one returns lambda x f of x this one just returns f of x so when we call that uh we just called this one we bound x to what we passed in g and then it tries to do the work of calling the number two on the function of squares and that's zero yeah the lambdas can be especially those embedded lambdas can be a little hard to follow um again remember when you see lambda you're defining a function the next thing is this is the parameter that will be passed in and everything after the colon is a return statement that's all you can do in python in lambda expressions so whenever you see it say that to yourself it helps a little bit that's a function it takes this parameter and it returns this don't even translate it and make your life easier yeah and don't don't try to parse the lambda within the lambda just say it returns this okay what does it return it's a function that takes a parameter and returns this thing yeah so it's good to sort of tease those things apart a little bit and by the way what john is doing now is you can always rewrite them as deaths right the only difference between the lambdas and the deaths is that the lambdas are anonymous functions you're not explicitly giving it a name so a good exercise is to rewrite them with it with depths and sometimes those are a little bit easier to parse and understand yeah and then you give them explicit names so you can see them clearly in the in the um environment variable environment diagram well i slapped this up here and now we'd see the same uh same error same environment the question is uh in the land of video uh there was some discussion of intrinsic names and that being the only difference between a deaf statement and a lambda expression and what's an intrinsic name and really all it is is uh the name you see right there when you try to display a function and you get these uh carrots and like some mystery thing which you can ignore until 61c and uh but you do see your name even if we gave a new name to this it would still be the f function so that is the intrinsic name it's a very unimportant part of the function but it does exist so that's why i just mentioned that there is this slight difference if you had written um you know f equals lambda x x plus 1 and looked at f this wouldn't be f anymore it would be lamb the next question was again about currying is creating just a design decision is it helpful in any particular case and how does it get used in practice you want to give that a shout well i'll give my take on it uh and then and john may have a different opinion on this um which probably tells you well that's probably true of most things by the way um i think it's a little bit of a design issue um i think but i think also it it really is about um sort of whether you want to bundle up a fraction of a function call because you're going to be reusing it over and over and over again so again i just want to emphasize there's no you don't have to do it i don't know that there is an advantage computationally or even frankly organizationally i can imagine a scenario where it's nice to name like the way john did earlier with you know power of two it's nice to name that because just from the readability of the code you know instead of looking at the parameters and trying to figure out you're raising something to the power two it's sort of in the function name um i have to say i don't know that i've ever used currying functions in the many many decades i've been coding um but maybe john has a different perspective on it uh yeah i mean currying whether you write creating as a function or whether you write out the explicit syntax of uh you know like i have an f that takes two arguments and i want to make a new g that just takes the first argument and uh gives me back a way of calling f on that first argument and some second one that i don't know yet so you could write this or you could uh write curry uh f and you kind of get the same thing um they're both curry i mean one there's like a function for it and one you're you're sort of writing some code that does it but you're doing the same thing in both cases which is that you're splitting up uh when you get x and when you get y so you can get one and not have the other yet if you're just writing a whole program by yourself i don't think this comes up so often you know uh but there are lots of cases where you're using somebody else's code so somebody else has written a function that takes four arguments and you kind of want to set two of the arguments the first two arguments already and then you kind of use the result many times in your program and so you would want to like kind of build a new function of two arguments with the other two already filled in and uh that means that people can write very general libraries where they have functions that take tons of arguments and then you can specialize it sort of on the fly and this does show up uh fairly often so this concept of like bundling together a function and some of its arguments into a new function that takes fewer arguments which is really what creating is all about you know it's pretty useful technique for organizing programs yeah i can also imagine a situation i may have to bend over backwards to do this where you have to actually do some work with the first parameter computationally you have to do some calculation and if you're calling that full function over and over and over again with both parameters you're going to do that work over and over and over again and maybe you want to do that work once bundle it up and then send it off so i can imagine a computational uh benefit uh for bundling that up just by the way depending on the specifics of the function uh so here's an example that a student found on the resources tab and the question was for step four why didn't lambda get called like how come there's no lambda frame instead what we see is that there's a lambda function which is some value uh bound to grounds like why did it come out that way it came out that way because when you evaluate a lambda expression every time what happens is that you create a lambda function you don't call it unless you have parentheses after it so if you ever have like a lambda function and then you call it right away you'll see a lambda frame but if you just give it a name then you won't see a lambda frame until later when this function actually gets called and in this case instead of giving it a name by assignment we're giving it a name by passing it in as the argument to another function so we're creating a function that's what evaluating the lambda expression does and then passing that function in as the argument coffee coffee is getting called because coffee has parentheses after it so we create a coffee frame where this lambda function that we just made is the argument and what do you do with arguments well you just bind them to their names so now we have a local name grounds for this function if at some point we call grounds which we do down here we'll see the lambda frame but until we call grounds um really the only way to refer to this laminar function is by grounds and uh if it doesn't get called then we'll never see a land definitely so i can say that more succinctly yeah so let me let me yeah maybe let me let me just summarize try to summarize and we'll see if this answers the question is the parameter being sent to ground is not is an actual function definition i'm not evaluating that function and the only time i create a frame is when i evaluate a function if i'm just passing a parameter i simply bind the parameter and i send it off and that function has to do what it has to do yeah so let me show you one variant on this which is almost the same let's just define this function give it the name f good and then call coffee on f no parentheses here just f there this line creates the function and gives it a name and then we're still not calling f we're just referring to f by passing it in as an argument to the coffee function at which point really all that does is give another name to this function but it doesn't call it yet doesn't get called until we see a call expression with either f as the operator or ground says the operator [Music] yeah so really important when you see function names is to look afterwards if there are parentheses where you're passing a parameter or or even if they're empty parentheses you're calling the function if they're not you're simply referring to the name of the function either to assign it to a variable to pass it as a parameter and it's really important you know code is super particular and so that just that difference of the parentheses makes a huge difference right whether you're evaluating the function or assigning it or passing it as a parameter so you have to read very carefully and you'll get in the habit when you see functions of always looking for those parens to tell you whether it's being called or not well great questions today folks good all right everybody it's ten o'clock uh we have a long weekend i hope everybody gets a little bit of rest a little bit of um uh time off and we'll pick it up again i guess we don't have this on monday is that right uh john that's right no election for monday so no q a on monday uh but we'll be back on wednesday the everybody wednesday uh have a great weekend everybody thank 