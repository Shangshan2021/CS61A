Students often ask, what's the point of  higher-order functions? Make adder is cute,   but why don't we just add x and y directly  instead of building a higher-order function?   So I've constructed a slightly longer example  that tries to illustrate why you might want   to define a bunch of functions and work in  the space of functions until the very end of   the program. And the example is generating  sounds. So what we're going to do is write   down a wav file. That's a standard format for  encoding sounds. It's not used much these days,   because it takes a lot of space. It's a  really simple format that doesn't involve   any compression at all. But it's really simple  to generate a wav file. So that's why we'll use   it. All the wav file does is encode samples of  a sound wave directly. Sound comes in waves,   the wave has amplitudes at any moment. And what  sampling does is allow us to digitize this wave   by just recording the height or amplitude of the  wave at particular moments. So that's what these   dots are. Thanks, Wikipedia, for this cool  picture. So the wave itself looks like this.   We take lots of samples at particular moments  in time. And we're going to take, for example,   11,000 different samples every minute, in order to  get as close to an approximation to this structure   of this wave as we need so that it sounds cool  to the human ear. And usually, these waves are   created by recording sounds in the real world. But  you can also generate waves from scratch according   to mathematical functions. And there are several  standard simple waves, one of which is called the   triangle wave. So there's a sine wave that you  can generate mathematically, or a square wave,   or triangle, or a sawtooth wave. All of these  are used in various forms of electronic music.   I think the triangle wave sounds better than the  other three. So that's why we're going to use it   in this demo. Since this example is a little  longer than usual, I'm not going to type out   every line. But I'll show you what I've done. I've  used some of the built-in modules in Python in   order to construct the wav file. There's a whole  module about waves, you can read about it. There   is a module about encoding integers in the format  that wav files require, that's called struct. And   then we'll need the floor function, which takes  a number and rounds it to the greatest integer   that's less than that value. Now we pick a frame  rate, that's the sampling rate, how many times per   second do we want to have some value that tells  us how high or low is the waveform of the sound.  And here's the part that I don't think you should  read, you're welcome to, here's how you encode a   value according to what the wav file requires.  You can read about how this works on the Python   docs. But just trust me that this is one way to  get the value you need. And here's the function   that actually writes the wav file. So we picked  some name for the file, the standard way to write   this is some name.wav. We pick the length of the  sound that we're generating. And then we have a   function that's going to describe the waveform for  the song that we're trying to generate. And this   is the function that we're going to write later.  Whatever this function is, it's a function of t,   the time into the song that has elapsed so far.  So we start out at the beginning of the song,   and then we go through all of the t's that are  the number of seconds in the song times the frame   rate. So we're going to do 22,000 times, call our  waveform sampler on t, and then we'll write that   out to the file in order to generate the wav  file that our computer will actually be able   to play. So sampler is some function that we're  going to need to generate, that gives us numbers   between -1 and 1 and describes the samples of the  wave. So if we were trying to generate this sound,   then that sampler would have to give us zero, and  then half, and then one, then three quarters, and   then it's about a half again, and then two-thirds  or whatever these values are at each sampling   point. Now how do you come up with the samples  for a triangle wave? Well, you have to know the   frequency of the wave that determines the pitch,  and the amplitude that determines the volume. And   then there's this fairly straightforward equation,  which is that you figure out how many times steps   are required before the triangle wave repeats  in order to draw one triangle shape like that.   Once you have the period, then you can write  down a function that takes in the value t,   builds a saw wave computes the absolute value  of the sound wave multiplies by the amplitude,   and then you have a triangle wave. And one more  line I'll add here is that the frequency for the   note c is 261.63. That's just a fact about how  instruments are tuned in the modern world. Okay,   let's see what happens when I create a triangle  wave at the frequency of c. Let's set t equal to   0, while it's the case that t is less than 100.  I'm going to print out what I get when I call c   on t. And then I'm going to increase t by 1. And  we'll see the shape of the triangle wave. Okay,   so it starts out at -0.3 because that's my  amplitude, works its way up to 0, and then all the   way up to a positive 0.3, and works its way down  to -0.3, and works its way up the positive 0.3.  That's our triangle wave. If we play c,  what I've done now is right to file. I'm   going to open it up using my upbraiding system.  Here's the file, song.wav. And if I play it,  I heard a triangle wave for c. Okay, so things are  getting interesting. Now I can play a sound. And   the sound just sounds like a flat tune. But that's  something I can work with. I can take a function   like what comes out from tri and combine it with  other functions in order to make music. So next,   let's write down the frequencies for three  different notes c, e, and g together. And what   would it mean to play two at the same time? Well,  I need a function that plays both some f and some   g, which are both functions. And that's a function  of t, that just returns f of t plus g of t. Now,   I think I can construct a two-note chord, just by  playing both a triangle wave at c's frequency and   a triangle wave at e's frequency. Don't forget to  return a function. And then we'll run our code and   hear what we got. Ah, a c and an e together. Let's  add some rhythm. I'm going to define a function   that takes in some particular sound, f, and only  plays it from start to end, where start and end   are measured in seconds. To do that, I need to  create a new function, a sampler function that   first expresses t in seconds. That's t divided by  the frame rate. Then checks to see whether those   seconds are between start and end. If seconds  are less than start, return zero. If seconds   are greater than end, return zero. Otherwise,  just play the sound. And the sound in this case   is a function, or we just call that function on  t in order to get it to play. So let's create c   and e as triangle waves at c frequency and e  frequency. Now we can play a note. The c note   from the beginning. And let's make it a quarter  note. Alright, mostly silence with a little beep   at the beginning. And what if we want two beeps?  Well, then we play both. The c, which is a quarter   note at the beginning. And an e which starts after  a half a second and lasts for a half a second.  I run my code again and listen to the  song. Now we're getting somewhere. But   notice that sounded a little harsh at  the beginning and end of each note.  Almost a little scratchy. I don't know if  that comes through in the video. But it's   an important part of making music that you make  each note sound right. The way we'll fix that   is just to add a little fade at the beginning and  the end. Just for a 100th of a second. We'll have   the amplitude increase and then decrease. So if  it's the case that seconds is less than start   plus the fade in time, then what we're going to  do is compute the difference between seconds and   the start. So that's how far into the sound we're  in. And we'll divide by the fade length to get a   percentage of the fade. And we'll multiply that  by f of t. If it's time to fade out, that's when   seconds is greater than n minus the fade. We can  figure out how much is left and minus seconds.   Divide that by the fade time and multiply by  the amplitude. So that means we'll fade in,   then we'll fade back out. In order to hear  the effect, maybe we'll make our fade length   a little bit longer. How about 0.1 seconds. But  to make it sound as natural as possible, we'll   do a really short fade. So it's like the note is  starting up right away but we don't get any weird   artifacts in the sound. Two nice, clean beeps.  Let's add some more. I'm going to keep track of   how far we are into the song. Starting with zero.  My first note will be starting right there at c,   I'll play an e. And I'll play it for just an 8th  of a second. Okay, now I'll move forward in time   by an 8th of a second. And then I'll keep the  song that I have already and add another note.   How about another e starting where I am now?  This time, it's an 8th note. But after it, I'm   not going to play another note for a quarter of a  second. That means I have an 8th note followed by   an 8th rest. I'll do that again. And then have  an eighth note that has no rest after it. And   now I think it's time for another note. And let's  make this one a c followed by an e. How much time   have we used up in total? There's three quarters  and two more 8th's makes a whole second. We have   two seconds according to the length of the song  that we defined in the beginning. So let's add   a couple more notes. How about a g for a quarter  and have a little bit of rest after that, and then   another g. But this time, let's pick a low g.  The way you reach a low g is just to define the   frequency in half. So I'll make a triangle wave  for g's frequency and then a triangle wave for   g's frequency divided by 2. And instead of playing  these two notes, we're gonna play our whole song.   Alright, so we have the beginning of the Mario  theme, just as one note at a time. But remember,   we could play chords. Here's a way to make chords.  I'm going to put all of this into a function,   the Mario function needs to know which c, e,  g, and low g it's going to use. And then it   will return the song list generated. Instead of  committing to a particular c, e, g, and low g,   we'll play Mario at a particular octave. And  the way you set the octave is just to multiply   the octave by the frequency. So if the octave  says, go one octave above, all right, that is 2,   which multiplies all the frequencies by 2. Or if  we want to drop an octave, and we'll just divide   by 2 or multiply by 1/2. So how do we make a song?  Well, we have a local named c, e, g, and low g,   we'll call Mario on those, which might be  different depending on what octave was passed in.   And now we could play Mario at different octaves.  Mario at 1 is what we heard before. Mario at 1/2   plays it an octave down. And of course, since  we're representing these as functions, and we   can combine functions in any way we want, we could  play both Mario at 1 and Mario at 1/2 together.  And that's how you make music using a  computer. All by defining functions,   building some elaborate function built out  of both and tri combined together in lots   of interesting ways. And then we pass that  function into play. And it just calls that   function on every value of t and writes out the  results to a file. And that's how we have a song.
