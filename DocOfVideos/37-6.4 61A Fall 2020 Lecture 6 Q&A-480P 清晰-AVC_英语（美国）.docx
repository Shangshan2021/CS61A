this is the lecture 6 q a and there's a new feature in the description of this video there are time stamps and brief descriptions of each question that was asked so that if you want you can jump around yeah so the question was about lecture uh we we thought about what's actually important for some square to know about square in order to use it correctly we decided that its behavior was important the number of arguments that it took was important how it was implemented was not important and uh there was this one detail about its intrinsic name i said that's not important the question was what is an intrinsic name anyway and uh why doesn't some squares care some squares really does care how it can refer to the square function and it's going to refer to it using the name square but it turns out that this function that squares things wasn't originally called square in this example it was called f now we also gave it the name square and so we can refer to it as square out here or within the body of some squares so we call sum squares some squares knows that square squares things and therefore it will compute the sum of the squares of 3 and 4 which is 25.
um the intrinsic name of this function which is called square is actually f f is the intrinsic name because it's part of how the value is displayed and it's just the name that the function had when it was created that's what an intrinsic name is it's really like an unimportant detail it does exist in the python interpreter so we mention it once in a while but it's not something that ever matters for the execution of code it's just like it affects the output a little bit yeah so the distinction here is of course it needs to know the function name it's going to call the function but it doesn't need to know what's happening behind the scenes it doesn't need to know whether it's the built-in python function or you've redefined it as f or anything else that's completely irrelevant to it i just need to know how do i refer to this function to call it and the fact that there's this name underneath the cover who cares yeah exactly not only just python not care you don't well you definitely don't care about that it's not a very important concept so this is a question about floating point error if you can call it that so this is a pesky thing about representing numbers in a in a computer with finite memory yeah is that you when you do floating point calculations that is when you divide uh one non-integer by another integer and you don't use the integer division the double slash you don't convert to an integer you can get you know these tiny tiny tiny little values at the very end and where they come to bite you is where you ask things like if the result of this calculation is equal to 50 then do this right where your expectation of for example you know the division of two values should give you the integer and then there's this dot zero zero zero zero zero zero three and the conditional doesn't work so as a general rule you should not do tests for equality against floating point numbers and exactly for this reasoning and and the reason is not it's not a bug in your code it's the way floating point numbers are represented and managed in a computer with finite memory and so the right way to do that is either you do integer division and so you're guaranteed to get an injured back you explicitly cast your result to an integer using the int operator um or you do a an inequality you say if it's you know less than 50 for example or less than or equal to 50.
um although it depends on the logic of your code whether that won't work or not so i don't know if i answered the question maybe john i think john maybe wanted to to chime in too i thought that was a great answer so like a computer can't represent pi because as like a numerical expansion because it goes on forever and so you're stuck approximating that it turns out you're stuck approximating a lot of other things if you want your code to run fast so even rational numbers that you can imagine representing exactly is like a fraction often times are represented based on like an approximate numerical expansion kind of like this and um there's you know the question is like could you make this go away and the answer is no it's baked into the programming language it's baked into in fact all programming languages the way in which a fraction is converted into an approximate decimal expansion isn't something that's particular to python it's a standard that's used across basically all programming languages called the floating point standard and invented by a berkeley professor in fact well i guess it was a collaboration but he got the he got the turning word for it so i think that it's just something that like with experience you can learn how to manage this um there are lots of solutions but you know the basic idea is don't trust the last few digits of any large numerical computation uh if you're like manipulating a few numbers together then usually you see errors only in the last digit or the last two but if you do some massive computation that involves like multiplying and exponentiating tons of numbers and then combining them together then you can lose quite a bit of precision and it turns out that even though uh python or some other programming language will show you these 15 significant digits some of them just won't be right mathematically and that's that's a compromise we make for having computers be really fast and able to carry out these massive um so if you want things to be exact work with the integers just like honey said if you're not working with integers if you're working with these approximations then just accept that like equality checks often aren't the right thing yeah so this is really where it comes i mean can we come to bite you in a couple places but equality checks is really where you have to be very careful so as i said one way to do it is if you're dealing with integers do energy division or cast explicitly do an integer now you may say well look i want like the first two decimal points but not the 20th decimal point yeah because john said you don't trust all the way those really really tiny numbers so one way to deal with that is you can multiply your number by say a thousand round the result and then divide by a thousand so what happens there if i multiply by a thousand i moved i get the first three decimal points that were first three values that were to the right of the decimal point are now to the left yeah and then when i round i get rid of all the small numbers and when i divide by a thousand i push them back into where the decimal is so that way i can decide here's how many values i want it turns out round i'll do this for you too if uh so yeah i mean but but it is it it is definitely frustrating to see like how come this isn't true it's so obviously true but the reason it isn't true is that it does go through the same procedure all the time of like evaluate the left evaluate the right and you get different values because this rounding error if instead you had rounded these like honey set to three decimal points then you get the same answer there as you do there and so these two are in fact equal good approach yeah good question yeah so so i i guess the follow-up is like what happens if uh you're not controlling the equality but instead like okay pi is running this and so if you return like 50.003 and it expects 50.0 and it tells you you're wrong what are you supposed to be able to do about that and um yeah i mean that is kind of like a core specific annoyance uh but it also shows up in in real programs where you do have to think about like is the implementation that i'm gonna come up with going to give like the right integer output or is it going to give a rounded version and this is not really a topic for this course so i think it's more of just like a course annoyance in this case than it is like something that you should really worry about sorry that happened to you but um eventually especially in 61c you really do have to start planning for the kinds of uh approximation and rounding errors that pop up in real programs and kind of be defensive about them so um yeah so like you don't want to subtract one number that's really close from to one from another number that's really close to one because it tends to gives you uh like bad approximation errors so yeah eventually you got to worry about this i wish you didn't have to worry about it like in the first three weeks of 61a uh but sometimes it pops up just because the software isn't perfect yeah yeah and i'll add one last thing is in numerical methods this is a real issue dealing with and john had exactly the right word as defense is that you have to think about are my numbers going to be really small am i going to be really big am i going to reach instabilities and so when you're doing these complex calculations you do have to worry about these things i agree in this particular instance it's just something stupid that happened and we just need to fix it so i wouldn't worry too much about it right now yeah okay so the question is uh on an exam for example if someone gives you an environment diagram and says what code generated this how could you answer such a question because going the other way is straightforward you just apply all the rules and you get the environment diagram but going backwards um it seems like there's there's no way to determine what the code is just by looking at the environment diagram and so what are you supposed to do i think that's true that there isn't like a clear procedure anymore um for this reason if you take an old question on an exam with like a complicated environment diagram and you cover up the code and you try to write that code it's basically extremely difficult or impossible to do especially under time control so all the kind of old examples that you see of environment diagrams are probably just like more complex than you would ever see in a reverse environment diagram problem meaning one where you start with the diagram and you try to write the code and there's almost certainly ambiguities i mean there's almost certainly certain environments where that you could have gotten there many many different ways in which case we certainly can't say well that's not what we were thinking about that would be weird yeah so but if you think of simple examples you see something like uh i guess i can't draw it without showing you the code but like you see something like uh oh i can do this what goes here and the diagram is john is now hacking the html code for the python tutor so you can create an environment yeah so if you have like this and you're like what happened um or then like it seems like well x had to change so you can kind of look and see like oh if i had run this without this line then x would have been 2 but x is not 2 so why is that so it must be that x was changing here and in fact there's like enough information here that if we blank this out you could still sort of work it out oh it's going to get mad but you couldn't do it um unambiguously like x could have changed to four in an infinite number of different ways the only thing you can say is x has been reassigned at that point right we can't we can't hold you two what what what expression were we thinking about that changes x to four right so if you did anything yeah it would be fine to write x equals four or x equals uh one plus one plus one plus one or whatever and in cases where like it's unreasonable that you would kind of figure it out entirely you might see multiple choices and then you'd have to consider like which one of these does the right thing so um yeah so i'd say it's it's a different slightly different skill to kind of reason backwards um probably not my first choice of how i'd ask these questions except for that we live in this pandemic world where we have to kind of come up with the best substitute we can come up with um and uh yeah so so the right way to approach it is to apply the rules you know to the code that's there and then kind of hypothesize what could go in the blank that would make the environment diagram actually match the code so basically like what needs to change about the code in order to have it appear as the diagram and we'll try to keep the example simple enough that we can test that you know the rules without uh making you like try a thousand different things and figure out which one will work by the way is it just me or does the world look like it's coming to the end here in berkeley it is it is quite plausibly the very last q a we will ever do i mean that's not a it's like 9 8 30 in the morning that's not a virtual background that's what the outside looks like right now yeah it's crazy jesus i've been waiting for it to get normal and it hasn't so anyway i think bigger problems than environment diagrams is all i'm saying yes the real environment is the bigger problem the real environment okay sorry let's get back on track okay so the question was what's going on with the environment diagram for this which says that f is a function that takes x returns a function which takes y which returns a function that takes z and finally does some work it calls g on x plus y plus c okay so what's g g is not f but instead the result of calling f so that means that x already has a value which is three but y and z do not so in order to make progress we would have to take this result g and call it but that's actually not what we do in this environment diagram instead we ignore g completely so g just kind of hangs out there and we call f every time you call f you're going to get a new f frame where x is bound to something else so here x is going to be bound to four and return a function so let me just go back here this is going to give you back a function that takes y and does some work this is going to give you back a function that takes z and doesn't work and this is going to give you back a number the result of calling g on x plus y plus z well we do eventually call g that's good okay uh and what does g give you back well we'll find in a moment that it is going to give you back a function that we never bothered to call should we have it like finally resolved let's add a little bit to this it'd be so nice yeah let's uh z equals we'll call g oh we need to give this a name h and then we'll finally call h on something 7. okay so let's dive in f as a function notice that this was just one step we evaluated this lambda expression which made a lambda function but since we've never called it everything after the colon doesn't really matter yet but it does have a name because we used an assignment statement now we do call it so we get a lambda frame the way we create this frame is to copy over the name of the function copy over the parent copy over the formal parameter and then what's the argument well whatever we passed it which in this case is three and what does it do well this is a function that takes x which we've done and returns a function that takes y so you're going to see a return value a function that takes y now we're done with that we now know what the expression f of 3 is equal to it's equal to this function and now we have to do the assignment so g equals this is a global assignment statement it's not part of the body of any function and so g is a sign of the global frame okay now for the part where we call f again when we call f on well when you have this like nested expression you really have to figure out what you're calling and so in order to figure out what you're calling you have to evaluate f45 but to do that you have to figure out what you're calling for that sub expression which is f4 figure out what we're calling there it's f that part's easy but calling f of 4 gives us the function that we will call on 5. and that will give us the function that we call on six so first we have to call f on four now what is f f is this lambda function which we've just called we've bound his formal parameter x to its argument four and now we return a function just like we did before except for this function is different it's got the same code except it's got a different parent and therefore a different x value this has an x value of 4.
so where does this get returned this is the function that we're going to call on 5. so this function that we just returned is going to be called on 5 this function takes y and so we see we've taken y we've bound it to 5 and what does it return it returns a function that takes z and does some work so we're going to see a return value of a function the function that takes z and its parent is the f3 frame which is where this lambda function was created what do we do with this well now we figured out what f of 4 5 is and we have to call that on six so we're gonna take this function right here bind z to six in a new frame there it is and then we look at what this does well this calls g on x plus y plus z so before we can call g we have to figure what x plus y plus z is and here things get a little bit interesting so we look up x it's not here so we look in the parent which is the f3 frame there's no x there so we look in its parent which is the f2 frame and there finally we found an x so x is 4.
now we have to figure out what y is we look here there's no y so we look at its parent there's y is 5 and we look for z z is right here in the local frame so we add 4 5 and 6 together to get 15 but we don't return 15. we assign y to 15 in a new frame because we have called g on x plus y plus z which was 15. so we computed all that 15 back when we were like here right in order to figure out what g of x plus y plus z was we computed the 15 we looked up the g there was no g here no g here energy here and we found the g but then what we do with the 15 is we pass it in as an argument to the function which is this lambda called g introduce a new lambda frame whose formal parameter is y y is bound to the 15 that we computed already and now we figure out what to do well it's this function so what we do is everything after the colon we evaluate lambda z g x plus y plus c oh this is never going to end that's annoying uh yeah so maybe we'll forget line five and just kind of finish with this this is a nasty environment diagram isn't it yeah uh we're almost done though so um we've called g and what does g do it returns a new function so there's a new function that we return and we return it to here we needed a return value for f4 we never got that it just returns whatever g returns because it says return whatever g returns and so this function will be the same return value for f4 as it was for f5 and will eventually be bound to h in the global frame and let's forget this line okay so we did draw this uh now we can comment about how atrocious it is yeah so a couple of things about this you should never ever write code that looks like this this is absurd the only reason you do this is for pedagogical reasons to make sure you can you know do sort of the back flips to do this but this is an absurd example nobody would ever write code that's this obfuscated or complex it just it would serve no purpose at all so it's a fine exercise for being able to step through these environments but it's yeah i don't think if you wrote this kind of code you would your manager would yell at you yeah exactly um writing the environment diagram it does tell you exactly what's going on following the parents does tell you exactly what x and y and z are equal to if you are actually trying to analyze this code i'm not sure that drawing an environment diagram is the first step i think the first step is to try to read it and understand what it might do and then the environment diagrams could help you verify that so what this might do is take x and y and z in sequence in like a call expression like this and then return the result of adding all those together and calling g whatever g is okay so what makes this example particularly diabolical is that g is just like some other function that returns a function and it never does anything useful um pretty sure i didn't write this problem but anyway uh the the story there is like uh once you know that this is going to take three arguments and add them together then you can kind of check to make sure that things went right in your environment diagram by seeing like oh here was this moment where i took these three things and i added them together and i got 15. so that's good that means that like i haven't kind of screwed up my steps the next question was how to solve an environment diagram problem from the summer 2019 midterm question number two all right let's take a look at this really quickly so it says define view which is done for us define review which is done for us assign ice in the global frame now we're going to assign read in the global frame but we can't really do that until we figure out what view returns so um before we can call it we have to figure out what um argument it's going to take evaluating this lambda expression just creates a new function of pr whose parent is global okay so now that that's created we could try to call view view is a global function sorry i've never really tried to use these zoom annotators before but it seems like it's working okay uh vue takes an argument called re and what is that argument it's uh oh maybe i can draw an arrow bingo uh it's this function and then we have to do a little bit of work to bind ice to four and then we define a new function called k okay is a function sorry there's a lot of clicking involved whose parent is the f1 frame that's where we are right now uh put another arrow and what do we do with this do we call it no we just return it so since we return it that means that's the value of view called and therefore we're assigning that to re finally we call review on one so that means we need to introduce a review frame review has a formal parameter pr bound to one it can't return for a while because we have to figure out what the result is of calling re on pr times two okay so first step is to look up which are e and the answer is you look here since there's no re you look in the parent you call this one okay so we're calling the k-means function what are we calling it on pr times two well that's easy pr is one so we're going to call it on two okay and close folks k is uh this new frame has name k it's got parent f1 i just read that off of the function that i'm calling and it's got a formal parameter named means oh close enough which is bound to 2 that's the pr times 2 that we already calculated so what happens when we do this well we have to return the result of calling r e on means means is two that parts is easy what's r e well we look here there isn't one so we look at its parent and it is this lambda function finally getting to your question i think okay so uh we call that lambda function by writing down its name and its parent binding its formal parameter to its argument so what did we call it on we called it on means which was two and then we have to finally execute its body which is pr times ice so we look for pr it's here we look for ice we look here there's no ice so we look in the parent g ice is three and we add two or we multiply two times three together to get six so since the value of this is six that means the value of this is six which means that's the value of this is six and we made it so the reason even though there were two ices and this one was kind of closer than this one that we use the one out here is that this lambda function was created in the global frame because we evaluated this lambda expression before we ever called b and you know john was saying earlier the the environment diagram is a really good way of just very formally going through that but if you just look at the code you can sort of see that right you can see that in the global frame ice is set to uh three so when you call view with that lambda expression right there that ice is going to be set to three you can see that it's going to have to use that global value as well exactly so in any line of code that's not indented that's just part of the global environment or executed in the global environment you're basically just saying like oh i'm making a function that multiplies things by three if ice changed later then it would be more complicated but ice is not changing so this is just like a function that multiplies by 3. so whatever happens want to make sure that you multiply by 3 at some point and we finally did and so that's kind of like a nice check that we did something right again you know nobody would write code like this this is a pedagogical thing you know so don't don't think that this is what the world of coding is going to look like for you this is pretty cryptic um but it's a good exercise to make sure you can sort of follow the logic of these things okay so great question the question is like how do you know what's allowed and what's not allowed like what's gonna work and what's not going to work and in particular the reference was to the example from today's lecture where we passed mario at into both and mario at was this like very complicated thing that uh played the mario theme song at a particular octave and what was the mario theme song well that was defined by an even more complicated thing that was like or whatever so uh there's no restrictions on what functions you can pass in as an argument to anything in python and other programming languages tend to work like this too if it's the case that in your programming language you can pass functions around then typically you can pass any function as an argument now your code is only going to work if you're passing the right kind of argument into a particular function and what kind of argument works really depends on how the function is implemented what the function does so the kind of the part of this example that does all the work is this play function which like does something we i didn't even really describe very well like creates this uh wav file using a bunch of like built-in encodings or whatever but it takes a function and this is the one that we built the function that plays a song it can't be just any function it has to be a function that takes in times and gives you back wave heights otherwise something's going to break so every time a function takes another function as an argument you have to know something about that function what kinds of arguments does this one take and what's it going to return then you can start doing interesting stuff if you just say like if you just pass the absolute value function in here i guess surprisingly that would work but if you um yeah if you have a make adder in here then like you'd run into all kinds of trouble so you know python's not going to complain if you pass in some any old function but your code's not going to run unless you pass in the right kind of function that has the right kind of behavior so this has to be a function that takes in positive integers and gives you back the um the like um sampled uh wave amplitude at that time okay so johnson something important i just want to emphasize this again too is that there's there's sort of two types of problems you can run into in coding one is you go to run it and python says something's wrong you pass the wrong parameter something happened and it sort of catches the mistake for you when you pass a function in and you tell the user look this function must take as input a single parameter time and re return the samples python's not going to check that for you that's on you so it may it'll run and then you'll have a problem downstream um so there's so that in in that regard as long even by the way you won't even know if you're if you're passing in a number until it goes to try to evaluate it so there's no way of knowing until you actually run the code and that's on you the programmer to make sure you're passing the right thing and python won't check for you yeah exactly that's not true of all languages some languages are a little bit smarter about these things yeah sometimes you have to kind of say what you want in advance and then it will check it for you in different ways you'll do a lot of that in 61b actually so uh so the design of the rest of this program was just about making sure that you're building functions that behave in this way that like take in one argument and return one number and uh we did that when we were just creating like a basic waveform a triangle wave uh we did that when we created both which was basically like oh if a number comes in and i have two other functions that i can pass this number to and i get two different um wave heights then i could just add them together and then i get kind of both waves happening at the same time and that means i could pass that kind of thing into play um same story with note as we made sure that the function we returned was the right kind of function to pass into play and we even did this for mario so it turns out that mario was a function that returns a function which was the same kind of thing that note was uh or the result of both was because it was just built out of a bunch of boths and notes in the first place and so we got was a function that we could pass into play and um mariott kind of did the same thing it returned the result of mario which was the result of both which was the result of note and what's note anyway well note is one of these functions where you take in like how far into the song you are and it returns uh what uh what the height of the sound wave is at that time oh wait i many many years ago when i was first taught how to program i had a professor who insisted that you call functions with more information than just a name so it'd be like um this is an integer and you put the word int in the variable name or if it was a function that takes one parameter returns a parameter there's a notation for that so that in the function name or variable name there's all this information about the type i'm not recommend necessarily recommending that but when you just have some generic name you don't know unless you go look at the code see what it does and then make sure so there are mechanisms you can do in just the naming convention to sort of help protect yourself downstream and i think the most obvious example of where this can go wrong is if you have some don't have is a function that calls f on the result of calling f on x and uh here's just an example from some lecture recently i think uh or maybe it's from fridays like so i don't know but i think we did this already okay so uh and what happens when you square you just square it um so if i make g is twice square i've done all this complicated stuff but i have kind of followed the contract which is that twice takes in a function that you call on just one argument and i've taken a function that you call in just one argument and passed it in so if i square 3 to get 9 and then square that to get 81 everything works and nothing crashed but if i tried to twice pow since pow is a function that takes two arguments i'm going to run into trouble and it won't tell me i ran into trouble when i call twice it'll only tell me i ran into trouble when i actually try to do some work by calling h so what h does is h is this function which was supposed to take one argument um and we gave it one argument and then it was supposed to call pow on that one argument but it turns out that pow which is the function that you know raises one number to the power of the other requires two arguments it can't do anything with just one if you call pow on three then it gives you the same error so one of the standard contracts that you have to kind of obey is that when you're passing in a function and you're going to call that function then you better pass in the function that takes the right number of art and there are lots of programming languages that force you to annotate this or you could try to put it in the name somehow um or you could just like uh you could just know i mean when the code is this simple then it's kind of obvious but in more complicated examples you'd want to put it in the documentation somewhere the next question was what happens in an environment diagram when you have an outer function return an inner function and the inner function returns the outer function how does that work if i were to call f on 2 i would get back a g function which takes y so i could call that on 3 which would give me back the same old f function that i had before which i could call it should give me back the g another g function which i could call that so what's going to happen here is that we'll get just one f but two different g's the first g is created the first time that f was called and what's special about it is that its x if it used x anywhere will be bound to two so maybe to make this slightly more interesting we should use x somehow z equals x or how about negative x so we can see the difference okay so we called uh f which created a g function which we haven't called yet but we will eventually because we're going to return that so that's the value of f of 2 and we're going to call it on 3.
so when we call g on 3 we get its formal parameter y bound to its argument 3 and then we actually execute its body which in this case is to look up what x is we look here there's no x but there it is and we get z is bound to negative two the assignment is always local it's always in the current frame and then we return f so what does it mean to return f well you look here there's no f see look here there's no f see look here oh there's an f so we're just returning a reference to this function meaning that's what we're going to call on for as we're going to call the same old f that we had before when you call f twice you create two different g's and that's important because each g is going to behave differently even though it has the same code it's going to have a different x and that's represented by the parent so the next g when we call it on 5 we're going to bind y to 5. so that's one thing that's different is that it was called on a different argument but the other thing that's different which has nothing to do with y is that its x is in the f3 frame instead of the f1 frame and so its x is bound to negative is is bound to four so when we say z equals negative x then we get z is bound to negative four and what does it actually do well it doesn't do anything with z it just returns f yet again so you know outer functions you just execute the def once there's just one f function even if you return it many times there's still only one f function inner functions are different every time you execute f you're going to get a new g with a new parent and so in this case we're returning a different g every time we call f we call it f twice we got two different the other way to think about this is forget about an inner depth every time if that if i just have a function f and i declare a local variable in there z is equal to whatever then every time i call that function i get a new little local variable so every time you call that function frame gets created everything gets evaluated within that frame whether it's a function definition a variable definition it doesn't matter the next question didn't actually get asked in the q a session but someone did ask me in office hours yesterday and so i thought i'd answer it here and the question was what's going on with hog question 7 implementing announce highest how are we supposed to know how to start and how is this going to work and there's a very nice walkthrough video about this already that's linked from the hog project so maybe just watch that but here's my take is it announced highest is just like a function that's provided to you announce lead changes so let me talk a little bit about how this works and then you can imagine altering it to implement announce highest this is a higher order function that returns a say function if you've gotten this far on the project you know a save function is a function that's called on the scores after every turn it might print something out about what's going on in the game and then it also returns a new save function now the funny thing about this example is that this doesn't say return say it says return announced lead changes leader but announced lead changes does return say so this complicated expression is very similar to just writing return say but there is a difference instead of returning this say that just got called it returns a new say with the same code so the same behavior but a different parent frame one that was created with a different last leader so what this announced lead changes function does is it creates a save function here we've created it by calling it that knows who was winning before it gets in new scores and figures out whether who's winning now is different from who was winning before before no one was winning at the beginning of the game now player 0 is winning and so it prints that out but it also creates a new function that knows who was winning now now player 0 is winning so when i call f1 if player 0 is still winning there's nothing to report but here player 1 is winning has a higher score than player 0. so it prints something out and returns a save function where player 1 is winning call this on the new scores player 1 still winning nothing to print so in this version player 1 is still winning call that player 1 still winning nothing to report and in this one player 1 is still winning we call that and since this function knows player 1 was winning but now we observe that player 0 is winning it's time to print something out and then this function which would be called on a subsequent turn would know that player 0 was winning just before so what's interesting here is that we have the behavior which is print out when somebody new is winning and also some information who was winning already before the new set of scores came in so the new set of scores come in here but who was winning before is stored here and all three of these names are available in the body of say this default value is just indicating that at the beginning of the game nobody's winning but every time announced lead changes is called in the future we will pass in either zero one or none to indicate who was winning at the end of the last turn and that's what all this logic is about it's looking at the two scores to figure out who's winning now then it does a check if it turns out that somebody's winning and it's different from who is leading before then print out that the lead changed and finally return say but not the same say a new say with a new last leader every time you call a function you're assigning its formal parameter to some argument so we've computed the new leader based on the latest scores and we pass that in as the last leader in order to get a say function that when it gets even newer scores it knows who was winning last turn what's nice about this design is that this function can keep track of exactly what it needs to keep track of and nothing else and it doesn't need to know anything about the rules of hog it just knows that scores change and sometimes it's time to print out when something interesting happened so if we scroll down to announce highest this keeps track of more stuff because announcing when somebody got the highest score they've ever gotten in the whole game requires a little bit more information you need to know who you're talking about in this version of announce highest who always stays the same you say i only care about player one and then that never changes and then you keep track of what score did player one have the previous turn because you want to figure out how much they gained you only get their total score so you have to subtract and you also need to know what was the highest score they ever got in any turn before this is a fact about the whole game that needs to be tracked over time when you call announce highest on player one then this function knows it's about player one whose last score was zero and has never scored more than zero points now when player zero gets twelve points player one hasn't gotten any points still nothing really changes but now player one gets some points nine minus zero is nine points so that gets printed out that's the most that player one's ever gotten and a new function is created that knows once upon a time player one got nine points and also last turn they had nine so next time around they have nine still they've gained zero points that's not exciting but the next turn after that they've gotten 30 points total that means the points they must have gotten over the last turn is 30 minus 9 is 21 and 21 is bigger than 9 which is the most that we've ever seen before and so something gets printed out which means that f4 remembers three things we're talking about player one the last score they had was 30 and their running high was 21 that's the most they've ever seen we call that on some new scores and see that player 1 just got 17 points which is not as much as 21 so we don't print then player 0 gets to go then player 1 gets to go again and here they got 30.77 minus 47 is 30. so this function had to know that the last turn they had 47 so that they can compute 77-47 it also needs to remember that the biggest turn score ever seen for player 1 was 21.
we have enough names to track all that stuff and so we can write a function with exactly the same structure as an ounce lead changes define say a function of score 0 and score that computes interesting stuff about the current score this interesting stuff will have to be different in an ounce highest than it was in announced lead changes because we don't care about the leader what we care about is how many points player 1 or player 0 got then we'll have some if statement to figure out whether it's time to print and then we'll call announce highest with new values who stays the same the total score at the end of the last turn will change and the running high the highest score that this player's ever gotten in a single turn might change too if they just reach the highest score ever on this turn otherwise it'll stay the same i hope that's a helpful orientation 