one thing you might be asked to do on an exam is describe a function based on its implementation so let's look at an example and try to do that and figure out some strategies for approaching these kinds of questions so let's imagine that there is a function likes which takes in a non-negative integer n and returns whether george boole likes that number we don't have the implementation and it would be quite hard to reconstruct it but we have to imagine that it exists and a question on an exam might say what does mystery one do now we can't just run it since it calls likes and we don't know how to run likes so we'll have to think and often times the descriptions will have some kind of template like mystery one prints something less than n something and maybe it will give you some multiple choice alternatives or maybe you'll have to fill it in one approach to this kind of problem is to read the code then read the description options so that you know what you're choosing amongst and then focus on an example in order to figure out what the right answer is and step three might not be necessary but it's still a good idea because it lets you check your work so read the code mystery one takes in n sets k equal to one while k is less than n if like zen print k then add two to k so k starts out at 1 while k is less than n this doesn't change k or n so we're adding 2 k will be 3 and then 5 and then 7 so this will print odd numbers but it's not going to print all the odd numbers because there's this if statement so now maybe we look at the options but let's imagine that there's one like mystery one prints all odd numbers less than n that george likes well that looks promising but don't forget step three consider an example so what would that mean well that would mean picking some behavior for likes like let's pretend that george boole likes prime numbers and picking some value for n like eight and then tracing through and figuring out what will happen so if we call mystery one on eight then n will be bound to eight k will be bound to one one is less than eight if likes and is actually if likes eight and if likes is is prime well it turns out george doesn't like eight and so we will not print but since this is not indented as part of the if statement this will get executed anyway so we'll go to k equals 3 and go through again if likes 8 don't print again oh this will actually never print in this example which means that this description is wrong we're not printing all the odd numbers less than n that george likes otherwise we'd be printing prime numbers like three but when we worked through an example we found that this doesn't print three it doesn't print anything because n never changes and george didn't like n so a correct description would be that mystery one prints all odd numbers less than n but only if george likes n because we have likes n here this would have been the correct description if this had said if likes k but it doesn't so you can't solve these problems just by following your intuition or thinking about what's reasonable the point of the problem is to make sure that you understand how the code works and so you're going to have to think about every line and how it behaves okay that was a warm up now we'll do a bigger one mystery two that's a lot maybe we should just give up no let's follow our approach read the code read the description consider an example it sets i j and k to 0 none and none while i is less than n if george likes i then wow we do something complicated that changes k and j and then no matter whether george likes i or not we add 1 to i oh and that's the condition of the while statement so just by reading the code i've seen one thing which is that i will start at zero it will work its way up to n and it will always increment always add one so if n is eight it'll go zero one two three four five six seven and we'll check whether george likes each one of those and then we'll do something in here that i'm not quite sure i understand yet so maybe reading the description would help here's the description mystery 2 returns something or returns none if something else okay it only actually returns in one place so k starts out as none but then gets reassigned all right so this part has to be something about if k equals never gets assigned and otherwise if k does get assigned to something that's not none then we're going to describe that behavior here but i still don't know how this works because there's some big mess in the middle maybe i should consider an example and this one seems complicated enough that i could just go ahead and use python tutor in order to do it so let's go ahead and paste in this code and decide what we're going to call it on how about 8 again that seems reasonable but we also need a definition for likes that we can actually implement so let's pick something really simple george likes even numbers let's say we might have to change this later because we're just experimenting but at least we can let python do some of the work of telling us what's going on and then we start evaluating so we define these functions we call mystery on eight so n is eight and eight is never going to change but i j and k are going to change and as expected i is just gonna go from zero one two three four five six seven okay and then it'll be done but what's going on with j well let's find when j changed oh there it changed it changed because as we were going through all the i's we found one that george liked george like zero and so j got assigned to that nothing happened to k yet it seems like you can only change k after you have a value for j okay so let's go a little bit longer and see when's the first time that we actually get to this long line that's hard to understand well here we have j still bound to zero and i bound to two why is that well we're going through all the eyes counting upwards we found one that george likes and j was bound to the last one that george liked so when we get to this key line line eight i is bound to some number that george likes and j is bound to the last number that george likes and what happens we bind k to 2 which is the difference between this number that george likes and the last number that george likes now that we have that example it might be easier to interpret this so once we know the last number that george likes we're going to update k to be the difference between the current and the last if k is none so if we've never seen such a difference before or if i minus j is less than k if the current number that george likes minus the last number that george likes is smaller than the gap between the two that we saw before or the difference that we saw before oh then we assign it to the difference now this is a pattern that will make k eventually bound to the smallest difference between i and j because we rebind it every time we find one that's smaller than anything we've seen before so we could trace through the rest of the code step by step but i think we already know where this is headed it should be the case that mystery 2 8 is the smallest difference between any two numbers that george likes and if george likes even numbers then that smallest difference should be 2 and that's what we got if we wanted to be really sure i think we could try with different likes functions and see what happens but i think we know enough to try to answer the question now mystery 2 returns the smallest difference between two positive integers below n that george likes oh but we forgot about this part or returns none when's it gonna return none well if k never gets assigned which means this whole expression is always false and as soon as you have a j and k is none you're gonna assign k and as soon as you have an i you're gonna have a j so if george doesn't like any numbers then we'll never go in here k will never get a sign and it'll be none if george likes one number then we won't assign k yet but we will assign j but still k will never get a sign and we'll return none but if it's ever the case that there are two different numbers below n that george likes we're going to end up assigning k to something the difference between those two so the way i would complete this is to say that there is no two such integers or a longer description would be there are no two integers below n that george likes mathematicians use this word such to refer to conditions that have already been stated but it's okay to just write them out again too so i think we could have studied this code longer and maybe probably gotten the answer but i found it easier to get to the answer just by considering an example so i hope that gives you a flavor for the process that would help you describe what a 