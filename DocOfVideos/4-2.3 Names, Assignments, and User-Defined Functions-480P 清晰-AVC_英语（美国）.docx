today we're going to talk about names and how they  work. so let me show you a quick demonstration to   get us started. I'll start up Python. if I ever  press ctrl L it clears the screen but I'm still   in the same Python session. now I showed you last  time that Python can be used as a calculator that   means it should know about important constants  like pi. Oh name PI is not defined. well it's not   that Python has no idea what pi is it's just that  most names aren't available unless you import them   'from math import pi' is a statement that says make  the name PI available and now it is. I can use it   in combination with other values however I want.  an import statement can also be used in order to   get access to other functions such as the sine  function. so sine is a built-in function that   takes the sine of an angle. so if I take the sine  of PI over 2 I get 1. well it works! now these are   built-in functions and built-in names. i didn't say  what pi was, i just looked it up. but i can define   my own names using an assignment statement. an  assignment statement has a name on the left-hand   side; it can be any name that you invent. on the  right-hand side you put any expression that you   want and python will evaluate that expression and  bind it to the name. so now radius is bound to the   value 10. 2 times radius is 20. I can use that  name when I bind other names to other values   and in fact it's possible to bind multiple names  to values in one single statement. so if I say the   area and circumference of a circle are pi times  the radius times the radius and 2 times pi times   the radius respectively now I've defined the area  and the circumference of a circle with radius 10   now what happens is that these names are bound to  these values. they don't actually remember where   those values came from so if I change radius to  20 and I check the area the area is still 314   10 times 10 times pi. so these things are out  of sync and that's how assignment works. we are   evaluating this expression to get a single value  314 and that's what gets bound to area. it doesn't   remember that area was once defined in terms of a  radius. assignment statements can also be used to   give names to functions remember the max function  it's built in. well if I say f equals max now f is   the built in max function. what's exactly going on  here? f is a name. max is also a name and there's   this thing called a function which actually does  stuff it takes a max of different arguments and   that now has two names. f and max are both names  for the same function which means I can write   f 1 2 3 in order to apply this idea of maxing to  the arguments 1 2 and 3. I can also change what the   name max means. Max is now 7. I haven't broken the  original max function which is currently named   F. I've just made max mean something different so  if I take the f of 1 2 and Max I'll get 7 because   max is just the number 7. now I haven't actually  gotten into too much trouble. if I want max to go   back to being the max function fortunately I have  a name for that, f. and so evaluating f gave me the   built in max function which is now rebound to  max and I can take max of 1 2 & 3 and get the   right answer again. last time I told you that  there are function names for common in fix   operators such as plus and the times sign and  they live in the operator module. so if I write   this now I have access to the names add and mul. so  we know that one way to bind names to values   is with an import statement but they have to be  names that are built in. a second way is with an   assignment statement that lets us give a value to  a new name or to change the value bound to a name   well there's a third way to bind names to values  and that's with a def statement. a def statement   lets us create our own functions. now if I say  def square X, indent the next line, and then write   return the result of multiplying X and X together  I've now defined a new function called square and   the square function takes in some number and  squares it by multiplying it by itself. I can   square the result of adding together 3 and 4. I  can even square the result of squaring 3 so I   can use this function which I created exactly as  I would a built-in function. I can even define a   new function sum squares which sums the squares  of x and y by writing a return statement where   I actually use the square function that I just  defined. now I could have put a plus sign here or   I could use the add function; they both do the same  thing. if I write sum squares 3 & 4 it will sum 9   and 16 together to get 25. now remember when we had  radius which was 20 and area which was not the area   of a circle with radius 20 because these are out  of sync. how might we keep them in sync? well the   function can do that for us. if instead of defining  area like this instead I say area is a function which always returns pi times radius times radius  well then area is a function which I can call by   putting it in a call expression. this is the call  expression that just doesn't have any operands   now area here when called is 1256. what's that? well  that's 20 times 20 times pi. if I change radius   back to 10 and I call area again area is updated.  it's now 314. if I change radius to 1 then what's   area now? well it's just pi. so a function differs  from just a name in that its return expression   here gets reevaluated every time it's called,  meaning every time that it appears in the call   expression. so let's switch back to slides and just  review what we've seen so far. we're interested in   expressions and how they evaluate to values  the primitive expressions we've seen so far   are the number or numeral, a name, and a string.  strings I showed you last time. they represent   texts. we'll talk about them later in the course.  call expressions look like this: they have an   operator, some parentheses, and then separated  by commas, some operands. we just saw that you   can have no operands at all and still have a  valid call expression. you can also have nested   call expressions. an operand can also be a call  expression. we're really interested now in how   names work, so let's go through a tricky case and  see if you can figure out what happens. what is the   value of the final expression in the following  sequence: f = min, f = max, g, h   = min, max. then max = g then I  compute the max of f of two g of h of 1 and 5   g is also applied to 3 and max is also applied  to 4. think about it for a while. the answer is   either 1 2 3 4 or 5. you should pause the video  now and try to work out what the real answer is.
