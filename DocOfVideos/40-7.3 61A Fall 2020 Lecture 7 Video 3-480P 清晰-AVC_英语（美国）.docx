another thing you might be asked to do on an exam is look at an environment diagram and fill in the code that generated it this is a different process from looking at the code that's already complete and writing down the environment diagram but what you need to know is the same just how you solve it is different and when you're given access to the python tutor that draws environment diagrams it doesn't really make sense to ask you to draw one because the computer will do that for you but it can make sense to ask you to work backwards and figure out what code generated a diagram so let's look at an example a day at the beach we have some code about flip-flops we've got an environment diagram about flip-flops and both of them are long there's a lot on the page what do we do well one approach that i would suggest is to read the code in order to get a sense of what should appear in the diagram then read the diagram in detail marking all of the interesting features that you want to account for when you fill in the code and then go back and fill in the parts of the code that you can and mark off what features you've accounted for so this defines a flip flop function that defines a flop flip function or does something who knows and then it calls flip and calls the result all right there's no way i can fill this in without reading the diagram so let's do that in the global frame we have flip and flop which are bound to the functions flip and flop oh something's funny here flip is bound to flop and flop is bound to flip mark that some line of code is going to have to make that happen we're going to call the flip function you do need to know that this call to flip is a call to this function even though it's called flop it's the intrinsic name that appears in the environment diagram and the intrinsic name never changes so it's this function that gets called first and what does it get called on that's always important to note it gets called on the number one you know that because this is the formal parameter and so that's going to be the first name binding that you see another interesting feature is that flip is bound to the same thing that gets returned so we'll need an assignment statement to the name flip that equals something and then we'll need to return flip and glancing over here we see exactly that what kind of thing is flip it's a function a lambda function means that we're going to need a lambda expression here that lambda function gets called notice in this environment diagram the line number has been hidden sometimes that happens but that doesn't worry me because i know it's going to be on this line i've figured that out already just by looking at the diagram so this lambda function gets called and it gets called on the number two i don't see any number twos over here we're gonna have to write that in somewhere and it returns three that's important too and flop gets called that's this function and it returns flip but it says it returns flop all right the name flop is actually bound to the flip function so that part seems like it will work itself out as long as i can account for this flip-flop at the beginning but it is important that we call it on the number three we see a number three here maybe that's it there's also a return value of number three here maybe that's it we'll worry about that later finally flip gets called again it's gotta be this flip function that was the only flip that was defined but in this case it's getting called on the number three and it's returning none which is pretty different than the first time it was called same code different behavior means there must be an if statement oh and there is all right i think we found all the interesting features of the environment diagram so let's see what parts of the code we can fill it let's first think about this flip flop that requires assignment giving new names to the existing functions and can be achieved through the following multiple assignment statement we've accounted for that feature next we need to figure out how to call flipped on the number one i don't see a place to put it except for right here now we have to think carefully about how we'll achieve this we don't call flip we call flop because flop is the global name for the flip function which we want to call we call it on the number 1 because we see in the environment diagram that it will take the argument 1.
we've accounted for that now we need to make sure that flip gets bound to a lambda function and that lambda function gets returned we have the lines of code to do that here so i think we kind of want to avoid this entirely so when flop is equal to 1 we don't really want to deal with whatever this is instead we want to assign flip to some lambda we know it's a lambda that takes flip because we see that in the signature and also in the formal parameter name here we see that it should return three so why not just write the number three in there or you could write a flop plus two i think that would probably work just as well and then we return flip okay so we've actually accounted for that that and that just with one line of code but we haven't accounted for the fact that this lambda function needs to get called where did it go it got returned it got returned from the call flop 1.
so do we really want to call flip on that result no otherwise we'd see that flop's argument was this function instead we need to call the lambda function we evaluated flop 1 and it gave us the lambda function back how do we call it using a call expression i figured out to put the number 2 here because i see here in the environment diagram that the lambda is called onto so i've accounted for that it returns the number three okay so flop one two gives me the number three flip is the flop function we do need to call the flop function on the number three and that's exactly what we have so we've actually accounted for this as well when we call flop it returns what's named flop we look here there's no flop there's the flop which is the flip function which is what gets returned so there we're doing great this whole expression flip flop one two return value is the flip function so how does flip get called on three well this whole expression gives us the flip function which gets called on three so we have accounted for that the only thing left is to make sure this returns none we already figured something out about this if line but now we have something new when flop is three we need this to be true so we can return none so we just have to write some expression in here that's not true for flop equals one it's true for flop equals three something like flop greater than two or flop equals three would work there's lots of options here and then we have to explicitly say either return or return none in order to make sure that it doesn't keep going and return a new lambda i don't think this process is simple and easy but i do think it's something you can achieve if you know all the rules of environment diagrams so learn how to draw them first and then you'll already have learned most of what 