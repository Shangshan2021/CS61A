My exams often ask you to implement a function. So  let's talk about some strategies for implementing   functions. These are good strategies, even if  you have a computer and can test out your work,   but also apply to solving exam problems on  paper. Here's an example that's similar to an old   midterm. Removed from n some digit, which returns  all digits of non-negative N that are not DIGIT,   for some non-negative DIGIT less than 10. And  what does it mean to return the digits? Well,   this question originally had a longer text  description, which said that you should return   an integer that's got all the digits of n, but  without the 3's. So 231 becomes 21 and 243132, you   get rid of the 2's and you're left with only 4313  in the order that they appeared in it. And then it   says kept, digits equals 0, 0 while something if  something returned something else. You're welcome   to pause now and try to solve this problem.  It's good practice. But I'm going to move on and   talk about how to approach a problem like this.
First, read the description, and try to understand   what you're supposed to be implementing. And then  look at these examples, you should ask yourself,   what should remove 231, 3 return? And I  think it should return 21. And it does,   so that's good. But often, you might realize you  think it should do something else. And that's   why you're verifying the examples to check your  understanding of the description that was given.   Because understanding technical descriptions is  hard, a lot of things can go wrong. We've tried   to make them unambiguous. But at the same time,  these examples are supposed to help make sure   that you're implementing the function we want you  to implement. And do that for all the examples or   at least several to check your understanding,  then pick a simple example that you're going to   focus on when you go to implement the function.
Now, it's not a bad idea to read the template.   This says we're going to initialize kept and  digits. And the goal is to keep some digits   and get rid of some other digits. So maybe kept  is involved in that. We're going to go through   all of the digits. Here's a familiar pattern.  Every time I pick a pass to the wild statement,   I assign last to the last digit event. And then  I get rid of the last digit event. So last will   be assigned to 1, then 3, then 2, if something  kept in digits, and returned something else. Now,   when you read a template like this, you'll either  discover one of two things. The template is kind   of helpful. It seems like a reasonable approach,  so you should use it. Or the template is just   confusing, at which point, I would recommend just  trying to write your implementation on your own,   and then worry about the template later. Because  if you have a working implementation that doesn't   match the template, you can almost always  change it around a little bit so that it   does match the template once you figure out  how to implement the function. I find this   template pretty helpful. So I'm going to try to  use it. Before writing any code, I will often   annotate the names with some values of a chosen  example. So I'll say, okay, in order to figure   out how to remove this 3 from 231, I'll have n  be 231, and digit be 3, and I need to return 21.  Once you do that annotation, then you can start  working through the problem. Write the code,   try to compute the result, make sure you actually  return to the right thing, and check your solution   with some other examples. But focus on one at  first. So if we pick this one, then we're going   to just label this as 231. And this is three and  then kept and digits are 0 and 0. While I haven't   gone through all the digits of n yet. I need to  go through the digits and keep the ones that are   different from digit. That's my general strategy.  But it's always good to keep track of where we're   going, that we're going to try to return the  number 21 at the end. So I'd say we should keep   going as long as there are more digits of n. And  I should check and see if the last digit event,   which is the one I'm looking at right now, is  different from the digit that I'm supposed to   be removing. Different from because I want to keep  the ones that aren't 1. So 1 is last and 1 is not   3. So I somehow want to keep 1 and then I'll keep  all the digits that aren't 3 and then I'll return   that. That seems like a reasonable strategy.  So how do I set kept to be all the digits that   aren't 3? Well, I have to handle one digit at  a time. Maybe I'll add it to kept. That seems   reasonable. Let's see what happens. So 231, and 3  come in. Now n is bound to 23. Last is bound to 1,   1 is not 3. So now kept isn't 0 anymore, it's  1. And then I go through again, skip the 3,   go through again. And the 2, which is bound  to last is added to the 1 which is bound to   kept. And I'm supposed to get 21, but I didn't.  I added two and one together, and I got 3. Okay,   so this is wrong. Something's wrong because I need  to take the 2 and the 1 and make 21 instead of 3.   So what if I multiply kept by 10? Well, go through  the example to see if it's right. In this example,   kept was 0, last was 1, so we'd get kept  equals 1. Then in the next iteration, 3,   we skip. The next iteration, kept is still 1, last  is 2. This would compute 12. 12 is not 21. That's   backwards. So this is not right. But working  through an example, let you try. What if I   multiply last by 10? Well, let's see if it works.  The first time through, kept is 0, last is 1,   so kept is now 10. And then we go through again,  we skip the 3, last is now 2, kept is 10. And this   gives us 10 plus 20 is 30. That's not 21. I gotta  try something else. What I really want is to add   20 and one to get 21. So when last equals 1, I  want to multiply by 1. And when last equals 2,   I want to multiply by 10 to get 20. How might I  do that? And then you have to invent a strategy.   So one way to do that is to raise 10 to the power  of how many digits are already in kept. So that   means you would keep track of how many digits  are in kept. And you would multiply last by 10   to the digits. This works for this case. The  first time through, last is 1, digits is zero,   kept is now 1. That's good. The next time through  is 3, we skip it. The next time through, kept is   1, last is 2, digits is 1. This term is 20. So we  add 20 and 1 together to get 21. It works! Next,   check on a slightly more complicated example.  What if digit were 4? Then we'd want 231.   We'd want it by getting 1 plus 30 plus 200. But  we're not skipping the 3 anymore. Does it do it?  Well, sure. First comes in 1 times 1, and then 3  times 10. And then 2 times 100 gives me 231. Now,   there was a moment of creation that got us to  this point. We had to think about a strategy for   building up a sequence of digits by multiplying  in some powers of 10. And all of these problems   have some element of invention in them. But  if you start with a reasonable structure,   then you're just playing around with a couple  of lines that do all the work. And that,   you can just think through examples in order  to solve it. Now once you solve it, make sure   you're returning the right kind of thing. Kept  really is 20 or 231. And make sure that the other   examples work too. So it would be worth tracing  through step by step with this longer example to   verify that you didn't miss an important case. And  that's one strategy for implementing a function.  Now, you might come up with a totally different  solution, and that's okay. If you were here, and   you didn't know what to do next, but you thought,  well, instead of 21, I could get 2.1 just by   dividing what I have so far by 10 each time. Then  at the end, I have to figure out how to change 2.1   back into 21. And you could do that by multiplying  by 10. That only works for the simplest example.   In general, you have to multiply by 10 raised  to the power of digits minus 1 in order to shift   the decimal place in the right place. And then you  have a float value. So you have to round that. And   this would solve the problem as well. So it's not  the case that there's always only one solution to   a problem. And there's always going to be a hard  moment where you have to invent a strategy for   doing the work. But at least you have a structure  here to make sure that your thinking time is   productive thinking time because you're working  on the right problem, you're focused on an example   that's simple enough to keep your head around  and you're checking your work. I hope that helps.
