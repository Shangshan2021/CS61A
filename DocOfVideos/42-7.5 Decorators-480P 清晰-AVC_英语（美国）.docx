Decorators are a feature of Python that utilizes  higher-order functions. Here's the idea. Let's   start out with some just regular functions.  Let's just square and sum_squares_up_to(n).   And that starts with k at 1, and total at 0,  while k is less than or equal to n. It adds   to total and changes k. So we're gonna square  the current k, and then bind k to k plus 1. And   then we'll return the total. So we can square  12. And we can sum squares up to 5 to get 55.  Okay. I told you about this trace decorator.  And a decorator is a name for this thing that   looks like @ and then a name. And when I use that,  and I square something, then I see something gets   printed before the value returns. So the first  line gets printed when it gets called and other   line gets printed when it returns.
Let's actually implement trace or a simpler   version. So we're going to implement a function  called trace1, which takes another function. And   what it does is it returns a version of fn, a  function, that first prints before is called.   And fn is a function of one argument, which is  why we call this trace1. Okay. So what's gonna   happen? Well, I'll define a traced version of  the function, which will first print calling   this function on argument, and then the argument.  And then it will actually return the value of   calling fn on x. And then we'll return that traced  function. So traced is just like fn, except for   it also prints. Now I can annotate square with  the trace1 function that I just wrote. We're   not using the one that's built it anymore, which  means that when I square 12, it will say calling   the square function on argument 12. Moreover,  I can trace multiple different functions. And   then when I sum squares up to 5, I can see all the  work that happened. We called sum_squares_up_to on   the argument 5, which involves calling square  on 1, and then 2, and then 3, then 4, then 5,   and then returning 55. Neat. So trace is the same  thing. Recreating a function with trace is exactly   the same thing. As if I had written down here,  square is the result of calling trace1 on square.   I'll get the same behavior. So if you want a  shortcut for transforming a function into another   function, you can just put an annotation, which  is called a decorator. So if I trace a function,   that's called the decorator, what you get back is  a decorated function, and it's bound to the name   of the function that's given. So this is identical  to first defining the function and then rebinding   the name of the function to a traced version of  that function. Why not just use that? Well, it's   a little bit extra to type. And it's nice to know  upfront what decorations you apply to a function.   It's just a more natural place to put them. But  probably most of all, it's like that because not   all Python programmers understand higher-order  functions. But it's easy for everybody to   understand the magic of a decorator. So for you,  it's not magic, but for other people, it may be.
