here's the lecture seven q a since the lecture was mostly about exam review almost all of this q a is going over old exam problems we will have another q a on monday at 9 am in case students have more questions about old exam problems or want to ask about the practice exam which will be released today at the end of this video there is a description of everything that's happening over the next four days so if you're wondering whether you're missing out on anything you could watch that and make sure that you're not okay so thanks the question is how do you go about solving questions six 6a from the fall 2018 midterm one which here it is on my screen and we'll have to read it and then we'll have to think a little bit and then maybe we'll figure it out john can i interrupt just one second uh a question on the chat just so we don't uh i don't forget about it somebody's asking if there is a limit on the font size on their two-page notes yeah there is it's uh written in there that like a six point or larger would be nice i think so it should be legible by a human being all right legible and and and by not just somebody with you know 20 20 vision so but yes you can make it very small that's fine okay a repeatable integer function takes an integer argument returns a repeatable integer function implement repeat which is a reputable integer function that detects repeated arguments as a side effect of repeated calls it prints each argument that has been used before in a sequence of repeated calls therefore if an argument appears n times it is printed n minus one times in total each time other than the first the detector function is part of the implementation of repeat and we have to figure out how it is used and we can't use things that we haven't covered in the course yet so we have to somehow do this using just higher order functions so we got an if statement that'll probably be helpful and um detector is a function that takes something and probably will print it out so yeah i wonder if it's worth just trying to do this in tutor so you can see what's going on i have not looked at this question in some time but how about we'll work out all right i think that's how we start um first of all just look at the example it's always a good way to go we call it on one nothing gets printed calling on seven nothing is printed there's the second seven so the seven gets printed then three and four come for the first time two and five as well then we see another one so that gets printed because there was a one long ago six is the first six but this is actually the second five and so that one gets printed and this one gets printed so i i would strongly recommend it whenever you're trying to work on a problem and you think you understand what is asking that you look through an example and make sure that it behaves like you'd expect because it's often the case that you try to solve a different problem than we'd like you to solve and checking the examples can help with that quite a bit i'd also say this is like one of those particularly difficult questions where most students skip it and that's fine because you could still get an a in this class skipping the hardest problem on every exam but if you want to try it that's also great so let's work on it together so rather than diving into repeat which i think is just going to like call detector and set it up right the the real work is to figure out how this is going to go so um it does seem like uh we have the following available to us we have i is typically a number f is typically a function so let's assume it's going to work out that way and we can change our plan later we have this g function which i think could be the result of this is we get back a g function which is ready to take another number so let's say i might be seven and we need to figure out whether i is something we've seen before or we haven't seen before um we don't actually have a list of all the things we've seen before or uh like some way to appear into the past all we really have is some function so um in that case let's hypothesize that this function tells us whether we've seen i before and work with that for a while and then we can try to engineer it so that it does exactly that so if f is a function that tells us whether we've seen i before then we just call it to figure out whether we've seen i before and if it returns a true value then it's time to print i how would we set it up such that this is a function that tells us whether we've seen something before well um since g gets called on seven and gives us back a function that we can call on something it does seem like we need to uh return a function here uh that's that common pattern with repeatable functions uh is that a function can return another function and uh i'm not going to return g because uh i want to somehow remember that i've seen i in the past so that kind of limits me to returning a new function a function that we can define uh using a lambda expression because i don't see where else we could put this so this lambda expression means that we're going to get in some new value later what are we going to do with this function well i think what we're going to do is build a function that detects whether we've seen i oh this is interesting because here's a function that tells us whether we've seen i before if we just passed that in as a new value for f then the next g would be able to detect whether it saw i before i think this gets us part of the way there um this isn't the full solution but it's something so i think maybe we'll run this try to understand how it's working and then figure out uh how to fix it but first we have to figure out how to repeat so i think when you repeat probably you start out with a detector that's never seen anything before any j you pass into it it says nope i've never seen that before and then we'll call that on the number one and find out that we've never seen it before but that will kind of get the process going oh we need to actually call it so let's call this on repeat 1 7 7 and we'll worry about the rest of the example later so when we call repeat on one we call uh detector on a function that says i've never seen anything before and that uh builds a new function g which is the printer right if you look at the body of g it says it's going to print things now this expression up here doesn't just call detector it also calls the result of calling detector on k so that would be the g function so the reason that we see a g frame here is because of the parentheses that contain k and k was bound to one in the repeat frame and therefore one is the number that's getting passed in here we've never seen anything before so we don't print but here we do build a detector that has seen i before so what happens to this detector that we build well it gets returned as the value of repeat one so here we see g getting called on the next argument so at least we've built like a repeatable function structure where basically every time there's a parenthesis with a number in it here we're getting another call to g with that new number now we see a seven seven we've never seen before so we return yet another g while this is getting long maybe doing this in python twitter wasn't a good idea but i think we'll see something printed pretty soon so here's the third g from the third call sorry that's not on the screen at the same time and this time since we saw seven before we're going to see seven printed oh there it is so it detected that the same number was twice in a row so let me pause there i'm guessing people have questions about this specific code if you have a question about something else then wait on it but if you have some question about like exactly what i wrote here i know this is not a complete solution we'll finish it off in a minute but we have been able to detect when there's the same number twice in a row and that's interesting um but how we did it is obviously kind of convoluted so let's talk about what's here and then we'll uh solve the problem oh good question so the question is uh where did this lambda j false come from i had like when you see a functional argument you have to ask yourself what is it doing and that's really the key to unlocking one of these problems and making progress what this is doing is it's telling us whether for some new i we've seen it before that's what f is doing so every time i call detector i should call it with a function that tells me what i've seen before at the very beginning repeat just gets called at the very beginning and we never call repeat again at the very beginning we've seen nothing before so that's why we come up with a function that takes in any number and says nope i've never seen it before so that no matter what the next uh number is which will really be the first number we don't print it out because we've never seen it before yeah i so the way to think about it is look what detector takes as input so if you look on line 10 that's the initial call which is basically i haven't seen anything and then look at line 16 every time you call detector you're calling it with a function that tests the equality yeah so on line 16 that's testing j and i which isn't again quite the full solution yet but it'll get there so you got to sort of bootstrap this process and that's what that first call is doing and then it sort of takes over and keeps repeating and repeating and repeating on itself eventually doing the check and it wouldn't be crazy to make a note if you're solving this that this needs a better name like have have c9 before would be like a reasonable name for this function a follow-up question was what is the j in the lambda j on line 16 going to be that's going to be the parameter to the function right so you're returning a function you're not evaluating it yeah that's not a function call notice there's no parentheses after that lambda so you're passing to detector a function that function takes as a parameter j and returns whether j is equal to i where i is instantiated based on the environment that that lambda is defined in exactly like a good way to think about these names that come right after lambda or inside here is these are numbers you don't know yet but you will know them sometime in the future in this case j is going to be the next thing that gets passed in i can't tell that just by looking at this line of code i have to look at all the code and see what will happen to it but in principle you even just by looking at this code here you know j is something that you'll know later and you don't know it now so you're like creating this placeholder for something you'll know later ah so caitlyn's asking in the chat why the k on line 10 so i think the question if i'm um uh understanding so the the whole this whole thing starts off by calling repeat with some value yeah and then so look at the line 19 so let's parse that we're calling repeat of one that must return a function yeah because it's then gonna be called on seven which must have returned a function because that's going to be called on seven yeah does that make sense well okay i'm talking to the chat room now john um so i think that's a good explanation i mean another explanation is that if instead of writing repeat we could have just written detector that tells you it's never seen anything before oh sorry and then start giving it inputs that would have been another way to achieve the same thing so if you want to um kind of bundle this up into a name we could have just like given it a name but instead we've created a function that takes an argument and that means the definition of repeat is going to have to cover all this stuff and do uh that piece yeah so notice one is not the parameter j and that lambda expression yeah that lambda expression goes into detector it's a function detector returns a function to us and then that gets applied to one which returns okay we got an okay in the chat room i can stop talking now all right so let's figure out what's wrong with this solution which is that it only looks for adjacent things so if i wrote seven one seven i think we would run into trouble so uh in the description of repeat this is supposed to print but if we just crank for a while we'll see oh it did a lot of work and it never printed anything and that's because the function that we're passing in as the new have i seen it before just tells you whether you just saw it whether it was the previous eye and you really want to know whether you've ever seen it so j is something i've seen if it's the same as the thing that i just saw or if it's something that i saw before that fortunately we have a function to tell us whether we saw j before that this time it prints the seven or if we try this long example hopefully it will print seven one five one or we'll crash one of the two oh it crashed all right let's do a little shorter example uh let's make sure we get at least the seven and the one how about that that worked all right so here we go crank crank crank you got the seven crank crank crank some more and we got the one so i think this aside from the fact that we changed the name is a solution to this problem where the story is forget about this for a while build a function that tells you what you've seen before and returns a function that takes in something new and if you've seen it before print it then build a new function just like g except for the f that tells you what you've seen before shouldn't just be the old f it should be a new f that takes in j and checks not only against everything that's been seen earlier but also the thing you just saw by the way notice the brilliance of what john did earlier when he changed the name of f to have seen i look at how much easier it is to understand the code when you understand that what f is actually doing is acting have i seen i before as opposed to something like you know generic f so when john first wrote this he said well okay we want to know if j is equal to i but we also want to know if we've seen this before and once that's the power abstraction once you once you decide what the function does just do it trust that that actually works and there's something very clever about using that's why it's sort of good to use clever or meaningful function names because it helps you think through the logic when it's particularly convoluted like this so there's no doubt this is kind of pushing the limit of what we've learned in this course so far and i would say i would say more than that john i think you have pushed the limit and uh so yeah i mean there is often kind of a question that's there to sort of figure out who's really mastered every single way that you could possibly put this together most of the exam doesn't look like this so don't spend all your time just focused on examples like this much better to spend your time making sure you're going to get the more like uh straightforward questions correct and ignore this question completely rather than just kind of drill yourself on this kind of thing but it is interesting to see that it is possible to do this uh using the pieces that we have yeah somebody asked the question earlier about how these lambda expressions um retain state yeah and that's basically what we're doing here john said earlier that look if i had a list with a bunch of numbers in it this would have been trivial yeah go to the beginning work your way through and look for the number and so by virtue of building up these lambda expressions on line 16 where the variables are being instantiated you are building up this notion of a state and that is sort of tricky and hard to see yeah yeah you know every time you build a new function it's got a little bit of old function in it yeah and some other stuff and that is uh that kind of construction we're going to see a lot more in the course in the future um and you'll see you know throughout your studies of computer science that oftentimes you sort of build things up incrementally and that means that like every time we call this we've got a more interesting function than we had before because at the beginning it was really simple it just didn't know about anything and then it knows about one and then it knows about one and seven and then it knows about one and seven and seven oh seven is the same but you know you get the idea one and seven then seven and three and that's kind of how it's accumulating a more and more elaborate function you could write this directly you could write like oh i wanna lambda j that tells you whether i've ever seen see how i'm gonna do this uh the first version have seen zero looks like i've never seen anything and have seen one looks like uh i've only seen one or whatever have seen zero as done and then the next one has scene seven or whatever have seen one has done this is essentially what we're doing in building up our have scenes is that we're chaining together functions in order to build up something more interesting this one's going to return uh true if you pass in seven or one whereas this one would only return true on one and this one would always return false uh two quick things and then we're gonna move on to some questions uh one person somebody's asking uh let me find the question um in line 16 how is it that two functions are passed as a parameter um there are not two functions there um you are returning the result of calling detector on a function that takes a single parameter yeah it will be equivalent to write that and um so this says return one thing whatever detector returns and what detector returns is just g so this says g is gonna return g it's just not the same g it's the code is the same but the have seen function is different it's seeing more stuff it's getting older right so uh this basically is very similar to def g of i return g except for we're getting a slightly different version of g each time the result of calling detector again which returns g but with a new half c all right let's make sure we don't have to read any of this i don't think there's any sims or alarms or anything mentioned here okay so it's really just down to this much code and what happens when you call pumbaa on timon and five let's take a look pumbaa is a function that takes another function then takes an argument and calls f twice on x so it says now we're going to reassign pumbaa to something else so let's just pause for a moment and first understand that if we didn't have this assignment statement life would be a little bit simpler we would take timon call it on five take that result call timon on that and we'd be done but this actually says take pumbaa and call it on itself what does that mean that means create a version of pumbaa where this is already filled in we filled it in with pumbaa which takes functions and calls them twice so that means since we have already filled in the f we are going to take one more argument x and that needs to be a function that uh we can then apply twice so this says effectively uh apply twice the function that applies things twice so when you actually pass an argument into that it's going to be applied twice twice or applied four times okay rafiki is set to one timon is fortunately less insane it just says a function that adds rafiki to y whatever its argument is now it is true that between when you define this function and you call this function if you change rafiki that change will be reflected in the behavior of timon why is that well this expression is going to be evaluated whenever this function gets called and when you evaluate it it uses the current values and we didn't call it here we just defined it so rafiki negative one is the thing that we're going to use okay so now let's try to read this this says apply twice twice or apply four times the t-mone function to the number five and what does the timon function do well it actually doesn't add one but subtracts one because of this change so we're going to subtract one four times to the number five so five subtract one gives you four subtract one gives you three subtract one gives you two subtract one gives you one i think it'll come out of one and raymond let me suggest one other strategy i mean this is you sort of have to learn sort of how i'm going to do this but what makes this problem more difficult is that second line the pumba equals pumbaa right that so if you just cross that out um it's a pretty approachable problem and that's what i would have done i'd be like all right that's clearly the line that's going to make my life miserable i'm going to delete that for a minute make sure i understand how pumbaa is working make sure the rafiki where it gets instantiated work through all of that and be like okay i now understand what this is happening and then add that other level of complexity so you breaking down the problems john did this earlier where he sort of solved the slightly wrong problem and then went back and fixed it um somebody's asking why are we using negative one um for uh rafiki and the reason is is that on that line timon equals lambda you're not calling the function you are defining the function which means that the parameters in the body are not instantiated until you call it at the time you call it which is after rafiki has been reset to negative one then that is the value and you john's about to show us right now yeah exactly sorry if i was distracted i was just trying to illustrate what you were saying which is that eventually you're going to evaluate y plus rafiki but not until you start calling and at that time rafiki's negative one the process is always when it's time to evaluate y plus rafiki you look for y you look for rafiki and you add those together you get and okay and somebody's asking is drawing the environment diagrams for these problems too much time or is it recommended um john what do you think you have more experience with these exams than i do you know it wouldn't help you here uh environment diagrams are a great way to precisely describe everything that happens inside of a program but when a lot is happening inside of a program they become complicated enough that you know you're more likely to make a mistake than you are to understand what's going on so you'd be better served in this case just describing what pumbaa does and then asking yourself okay what would boom boom do if you apply something twice and you apply that twice what does what does that mean that means apply it four times um you know that that was a lot faster reasoning than drawing an environment diagram which i suspect would be um substantial for this but yeah i think so too somebody's asking if wwpd questions are going to show up on the exam uh i i won't just ask you what the python will do because we're giving you a python interpreter so you would hopefully be able to answer such a question uh though we are going to try to test the same skill usually we do it um like i described in the lecture videos for today that will just ask you to describe a function like you know what does this do so i might give you this example or and you know if i gave you these two lines and i said which of these descriptions is correct for pumbaa it takes a function and an argument and applies the function four times to the argument or two times or it ignores the argument or whatever you should be able to answer that uh descriptive first great um i'm sure you all are have good test taking strategies but let me just emphasize one thing there's going to be some problems that um you can whiz through and some you can't don't get bogged down on on the ones you get stuck on don't don't blow 15-20 minutes on some little two-pointer like you go through go through the exam get get done what you can um and then go back and deal with the hard ones and there's always going to be one like you know killer question don't don't get go don't go crazy on those they're fun you can do them later but don't don't sacrifice the rest of the exam for it yeah it's probably better to check your work on the stuff that you're more comfortable on than it is to think deeply about pumbaa pumbaa or something like that because uh you know most of the points is up here um i think i know the answer is but let me verify somebody's asking if we're allowed to go back to questions on the exam is the exam going to be one john you and i talked yesterday but i can't remember what we decided yeah this is right so you just get the whole thing and you can spend your time however you want i i would say that we've now given a few exams where students have an interpreter available and i don't think it's helped students very much i think that there's a big risk that if you just try to like run your code over and over until like some test case passes you'll lose a lot of time you know these exams are most are best solved by like reading and thinking as opposed to uh trying to get like your environment all set up and running the code or something like that so if you're thinking about how to spend your time i would recommend working through the exam without using code.cs61a.org or tutor much at all and kind of save that for when you're gonna go back and address the ones that you couldn't do the first time but if you can just like work your way through you know a lot about python and how it works you know a lot about how to solve problems do the stuff you can that doesn't involve like running anything and that's probably a much better time management strategy than like uh trying to get all the tests to run and stuff like that john since there are no other questions somebody's asking in the chat if we can explain uh pumbaa pumbaa one more time do you want to just walk through that really quick yeah let's see if i can try it again when you have a function that says give me something what i'm going to apply it to and apply it twice this gives you something it doesn't tell you what you're going to apply it to that comes later but it says uh the thing that we're going to apply to timon is to uh apply a function that makes it happen twice so [Music] maybe we could look at it this way at the end of the day at the end of the day if you have [Music] right i could have just written this the way you evaluate this is you figure out what you're gonna call on five figure out what you're going to call you have to figure out what this is okay so first we have to figure out what we're going to call this is uh apply four times because that's what it means to apply something twice timon to five so here you're basically building a timon timon timon to own function i like this explanation the best and then you finally call it on five yeah so you when you have a variable equal to something being assigned to something you can just take that thing and shove it where you're using it and that sort of deals with this sort of almost like recursive light definition yeah so i like that the best john there's a number of questions in the chat about the time for everything like the preps and the can you just go through that one more time so i think there's a little bit of confusion about the timing for everything okay so here's what happens in the next four days uh the first event is at 1pm today there'll be some announcements for a practice midterm which is totally optional but i recommend trying it if that fits into your schedule the password to unlock that uh will be released at 1 10 and you'll have until two o'clock to work on it so you'll have 50 minutes it's a shorter length uh version of the midterm similar kinds of problems but just not as many of them at 2 o'clock today well it'll start at 2 10.
we'll have an agree exam prep section which is just like a big zoom webinar you can find a link on um that'll probably run until 3 or 3 30 sometimes they run over and um that's independent but we'll you know cover more exam problems and strategies from a ta's point of view uh derrick who's running it has t had this class like six times or something ridiculous so he's quite good um then we'll rerun the practice exam at 7 pm it will be identical to the 1 pm it's just that alternate time um then nothing happens till monday actually there's some student-run sessions over the weekend if you want to go to you all study over the weekend that's what happens yeah you could study you'd get some sleep that's a good idea um monday morning we'll have a q a session uh nothing happens 2 p.m monday uh 7 p.m monday will run the exam and so the announcements will start the exam will be available and uh you know between 7 and 7 10 it's mostly like announcements and stuff like that you know get there at seven but we'll release the password to unlock the exam meaning you can actually start working on it at 7 10 and then you'll have until nine o'clock to finish the exam and how are the passwords gonna be released john posted on piazza okay so i'm piazza to the person who asked in the chat room yeah and and if you feel like this description was short on details well maybe it was but like every possible detail is in this piazza post here the next question was does it really make sense to try to come up with your own implementation for an exam question that doesn't match the template this strategy was suggested in the lecture videos but it might take too much time um so i'll give you my answer and then we'll hear what john says you know my answer is if you're completely stuck you just look at the problem you look at the framework and you're you just don't know where to go then i think writing it on your own is probably the right path because otherwise where do you go from there um if you're not completely stuck you sort of basically see what it is then i would say muscling through getting it to work is probably the right approach yeah you know the way we score these things is that you don't really get points for effort uh you get points for doing things correctly and you don't have to solve you don't have to fill in every blank correctly in order to get the points uh but you do have to have things that are consistent with the right answer and so um it's better to like actually solve the problem than it is to think like oh you know what could i write that might get some points typically uh and in that sense like you know it takes much less time to read the exam than it does to take the exam uh people who have been taking a lot of these exams can often finish them quite quickly relative to the time limit that we have so there is time to think and uh try stuff out and to backtrack a little bit in the design of the test and there's time to go through the whole process of you know looking through the examples making sure you understand what you're trying to solve and i think that there's maybe not for all the questions but for the ones that require it there's time for you to kind of think about how would i write it independently of the template that's been given because that can give you insights of like oh i i see in my version that i'm comparing i to zero i need to do that somewhere in the template and then you can ask yourself like where in the template could i do that and you fill that in and then like you'll at least get credit for that part that like piece of the logic which is that you're like comparing something to zero i know i'm just talking in the abstract i'm not talking about an actual problem but you know sometimes that's the right thing to do this is much more effective than saying like oh you know in lots of past exams i saw people comparing stuff to zero so why don't i just put that on every line um the chance that you'll kind of guess the right logic is slower than if you actually know oh here's like a piece of the logic that i know i need i'm gonna figure out where to put it so i i do think it is effective to figure out how to solve the problem even if you don't do it in our way um in midterm one there aren't like that many ways to solve these problems so i wouldn't expect that you'll come up with like a perfectly good answer that is completely different from what the template looks like good luck folks have fun studying rest up thanks everybody see you on monday have a good weekend try not to be the air 