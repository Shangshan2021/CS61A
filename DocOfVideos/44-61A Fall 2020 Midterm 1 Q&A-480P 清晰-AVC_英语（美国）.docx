we had an instructor q a session about exam questions mostly just going over past exam questions but also answering some of the logistical questions about the exam and here's the recording uh yeah good question the question is in this particular example which is spring 2020 midterm one question two why is it that this return statement on line five returns a function instead of a value like taking the absolute value of unit which would give you two and uh the answer is that that is what a lambda expression always evaluates to so whenever there's a lambda expression it is creating a function now the lambda expression starts with the word lambda includes the colon and then has some expression after the colon that all together is a lambda expression what you see in the line above is actually more than just a lambda expression here there's a lambda expression lambda t park but then it is part of a larger call expression and that's uh that's what those uh extra set of parentheses with s in it are is that saying not just create this lambda function but call it whereas in the following line line five it creates the lambda function but doesn't call it so you have to kind of look around at the rest of the line to figure out what happens to it and the answer is that the result this function is returned so that's why you would write it as the return value of the people frame is a function a lambda function um this is its body and the other important thing to remember is that this was created while we were in the people frame so uh that means that the parent of this lambda function will be the people frame in which it was created which i think in this case would be f1 by the way notice too that this lambda does not have a parameter so usually we've been seeing lambda x lambda t lambda y so that is the function that takes a parameter and then after the colon is that's what it returns this function just doesn't take any input so it's fine it simply returns the absolute value of unit unit is bound to what you see people because of what john was just saying about the frame hey john there's a question on the chat room about the uh the id for for the uh showing id for the exam can you just say something briefly about that because i know there's been a lot of back and forth on that yeah sure so uh any photo idea we'll do we're going to ask you in the announcements period between 7 and 7 10 to just show your id to the camera if you don't have a camera running because you were excused from that or your camera's not working or whatever then you could skip this part but if your camera's working and you have an id then just show it to the camera and we'll give you explicit directions about what to do and i'll tell you what the directions are now it's hold up your id in front of the camera for eight seconds um now uh any id is fine if it's got your photo and it's got your name you can cover up other stuff that would let us confirm that it's really you taking the exam all right let's take a look at this together so the question was about um this is fall 2016 midterm one question five and uh yeah this was probably the trickiest one on this exam so like i always say don't focus all your time on the tricky ones but uh let's take a look together and uh we'll try to focus on when to return a function versus something else so an order one numeric function is a function that takes a number and returns a number okay in order two numeric functions functions it takes a number and returns an order one numeric function and likewise an order numeric function is a function that takes a number and returns an order n minus one numeric function okay so if it's order and then we're going to call it uh repeatedly n times and eventually we'll get a number uh the argument sequence of a nested call expression is the sequence of arguments in all sub-expressions in the order that they appear so f here is called repeatedly on three four five six seven okay multi-adder it takes a positive integer n and returns an order and numeric function that sums an argument sequence of length n okay so i guess this will sometimes return a function that returns a number and it will sometimes return a function that returns a function that returns a number for example if n is two but it will never return number because it's forcing n to be greater than zero and so we have to pass it at least one thing to sum up um okay so looks like there's not going to be a ton of code if something is true then we'll return uh some function otherwise we'll return some other function i think in either case we need to return a function because well here's an example if multi-adder is called on one then we return a function that when called on five just returns five so i think we could actually just handle this example on the first line and then see if we can work from there if n is one then now it's very important to know how to say return a function that takes five and returns 5 the way you would write that is lambda and then you have to pick some name you could pick any name you want although it will be a little awkward to pick n it would actually work in this case but let's avoid n because it's already used and pick something else so we kind of have handled this simple case where if we're just adding one number together then we just return it the sum of one number is just one number the more complicated case i guess is this one where if n is 2 then we need a return a function that takes some number and that returns a function which takes some other number here i've built something that that kind of does what we want it says uh when this is 2 then we want to take in two arguments and in fact if this is 4 then we want to take in at least two arguments so that's how we got to this structure is just to say like i need to be able to look at two things at once in order to add them and i know i if n is not one i'm gonna have to take in at least two arguments in sequence so that's how i got the lambda k lambda j structure if we were just passing in uh five comma six then we would have written that and life would have been a little simpler but we didn't write that so now we have to think about what to do um it's all about the behavior this is supposed to be a function which takes in k and j and in the case that n equals 2 we really just want to add k and j together and i think if we didn't have to worry about n greater than two we would be done we just write add k and j together and we're finished the problem is with n equals three now all of a sudden we have to handle more stuff later so we have to figure out how to do that um one way to do that is to say that adding five and six and seven together is the same as adding 11 and 7 together that was kind of the the insight in this problem that you'd have to discover in order to solve it so you could make this 11 but then you'd still have to add all the other stuff now what might that look like well if we want to create a function that takes more arguments then i think we would need to call multi-adder instead of taking 5 and 6 and 7 now we want to take 11 and 7. so the first thing that you pass the multi-adder is not the number that you want to add together it is the number of arguments that the result will eventually take and here since we're moving from five six seven to eleven seven i guess we need to take uh fewer arguments yeah we might be done with this question so now we'll just check and see what happens so if we pass in n equals three a originally then we end up in this case we return a function that takes k and j which would be 5 and 6.
those will eventually get passed in so this will be 5 and 6 and what will return is a multi-adder that takes a sequence of two arguments where the first one is eleven which means it still needs to take one more argument that one more argument would be seven so when we pass in 11 and 7 as the kind of next version of k and j then that will add 11 and 7 together to give us 18 which will be passed in as the argument multi-adder one multi-adder one will return a function that takes in 18 and returns 18 and so we'd end up with e so you know this isn't so much about programming mechanics as it is about understanding what these different components do um and yeah yeah this is came up in the chat room john as a number of people are asking isn't this recursion and the answer is it's a version of recursion because you're calling yourself from within the body um yeah i mean technically recursion is a function that calls itself and here multi-adder doesn't call itself it just returns a function so uh technically this isn't recruiting but it certainly has a kind of recursive idea behind it version like everything we've talked about here is something that we've uh learned in this course but at the same time it it it is difficult to think about uh how you would express the return value for multi-adder in terms of multi-editor it's it's uh it's yeah it's one of the more complicated versions of what we've seen so far in terms of self-reference and to those not asking on the chat recursion is not part of this midterm so you will not we don't expect you to we won't be talking about recursion for this exam that's the next topic yeah so but when we say that like people get confused about what recursion is and that can be a problem so uh you won't actually see that where f calls itself we'll talk about that later in the week but you might see that now the reason why we're not going to talk about this until later in the week is that crazy things can happen when you call f here for this version let me call these different things so that we're not so confused when you call f here f then calls f which calls f which calls f you can get some like massive chain of computation just from one call it's it's exciting but it's not something we've really talked about much uh here life's pretty simple like if you call g on two you really just get g back and uh it's not like gonna run forever or do something complicated or you know create some tree of computation that's really hard to understand so notice the difference here by the way is the first one is recursive because you are calling the function the second one is not recursive because you are not calling the function you are simply returning the function right so there's none of that looping that john was just mentioning so the second one of course is fair game you can return the name of your function it's fine just returning some value john and so popping back to this like multi-adder only does work every time you call it so you kind of know that since there's one two three four calls here there's going to be four steps in the process so in that sense it doesn't have that recursive behavior of calling f which calls f which calls f and you have to kind of trace all of that but at the same time it is uh it is it is kind of expressing multi-adder in terms of itself which um that kind of thing does show up in self-reference once in a while but this is a diabolical case john somebody's asking in the chat about using uh python idle python tutor versus cs61 tutor for the exam can you maybe uh elucidate that a little bit uh you know you're not meant to be using idle but because we'd like you to stay in the browser just like makes things simpler on our end but anything you want to do you could just do in tutor so if you want to run examples this is what i would recommend just run them in this site which is in scope and you get there as tutor.cs61a.org or by going to cs61a.org and clicking on the tutor button so if you want to test things out there's really no good reason why you wouldn't do it here there's a separate interface which is almost the same called code.cs618 some people like it more but it does the same thing as tutor so just use the tutor and then you don't have to worry about it but you are not allowed to use external applications like idle or an ide or something like that you do have to write code yourself two questions about accessing prior exams during the exam you can read prior exams during the exam you can read anything that's linked from cs61a.org and they are all linked from right here in the resources tab the next question was can a student print out the pdf of the exam and then work on that on paper and then input their answers into the site at the end yes and in fact whether you print the pdf is up to you but i think the right way to approach this exam is to use the exam site and paper and uh if you've printed out your notes that's great um if you really want to know what python is going to do and you can't remember then it might make sense to open up tutor and check but most of this exam is just like use some paper uh read the questions on the website enter your answers on the website that's the right way to take the exam that's how it's designed and all this other stuff that people are asking about actually isn't really going to help you at all and so i would just uh ignore it and yes you're welcome to print out anything including the pdf for the exam anything you find on the website if you want to print it in advance you can you don't need to go nuts and like print everything that's on the course website i think that if you want to look it up during the exam you could just look it up but if you think that there are things that you definitely are going to reference then go ahead and print them out and yeah i hope that answers your question let's take a look at this example which is from spring 2020 midterm one question number two in order to answer your question i think we'll just have to go through and do some of this okay so people got defined for us we define unit we define t those are 1 three respectively and we define park which is a function and it was defined in the global frame so its parent is global and then we call people on park people's global function so it gets defined in the global frame people's formal parameter is s and s gets bound to the argument that was passed in when you have an assignment statement like unit equals two it always affects the current frame so we wouldn't be changing unit in the global frame um here we're assigning park to the result of calling s on unit t and plus one so before we ever call uh s we have to figure out what it is okay it's the function park and before we call it on anything we have to look at up what we're going to call it so we'll call it on unit which is two and t which is three so those are going to be the arguments to park park is a function in the global frame that has formal parameters t and park and was called on we did this work already two and three and then we see what it does it returns unit minus two so we look in here where's the unit well there's no unit here so we look in the global frame because that's the parent so we return 1 minus 2 is negative 1. a follow-up question was about the value for unit that was passed into the park function yeah so one way to check your work is just to say this expression is in the body of people therefore all of the names in this expression are going to be evaluated in a environment that starts with a people frame another follow-up question was whether the parent of park was relevant to the frame for park what parts were relevant and what parts didn't it matter yeah good question so the question is doesn't this park parent g matter somehow it doesn't matter for setting unit and t's values those are both evaluated before this frame is ever created and before the environment changes where this global parent does matter is when we look up the name unit which is part of the park function that unit will be evaluated in an environment that starts with a park frame this park frame in fact and its parent being global really does matter so when we look up unit here we look first here we don't find it so we look in global as opposed to in f1 so to summarize the parent mattered for this return value it did not matter for the argument values the argument values are always set before the function is ever called john i'm looking at your battery and it's really low which is making me nervous well that is exciting isn't it exciting yeah um it's it's a good question so there's some kind of general pattern for problems that involve memorizing things that have happened before and we really only have two mechanisms for keeping track of stuff we have assignment and we have function calls both of them assign names to values so if you want to keep track of stuff that's happened before like you know you want to sum things or whatever and let's say i want to sum three things well i could sum things uh three and four and then save that in a name using an assignment statement and then i could sum things a and five and i will have really summed three four and five all together so assignment does this calling a function is very similar to assignment so uh i'm sort of making this up as i go but well okay uh we could have done everything with make adder because adder is exactly the kind of function which has a memory any function that's defined within another function has its code but also has access to all the values for its parent function and therefore any value of adder will remember the x and be waiting for only the y so in this sense we can make adder on three when we call it on four we've now added three and four together but i could get ready to add that to something else and then when i call b on five i've added three and four and five all together so i'd say like let's make sure this actually works uh some things should return 3 plus 4 plus 5 is 12.
and this big make adder expression i would expect to eventually return us 12 as well there's the 12.
so i've kind of given you two ways to keep track of what's going on you could use an assignment statement or you could pass the result of some computation in as an argument to a function which returns another function therefore this inner function has as its memory or its context or in fact in its environment the thing you wanted to store the x if you would like to use two one-sided sheets of paper instead of one two-sided sheet of paper that is fine and you don't need to show it to us okay so the question is is there an example of currying that we could go over um this pattern of take two arguments and then do something but instead of taking them all at once you take them in sequence so that the real work is the same but the structure is different because this one takes one and then the other and this one takes them both at the same time is a general pattern this could be about anything not just adding but subtracting or multiplying or something more complicated so the whole idea of currying is just to say i don't want to say what this is in advance i want to leave it blank and how do you leave it blank well you give it a name like f and then when it time comes time to do the work you call it f now it doesn't really make sense to call this adder anymore because we don't know that f is about adding anymore it could be anything so maybe we'll call it doer and this you know does something i don't know you call it anything you want a follow-up question was what's the point of korean that's a good question um so functionally there's no difference right these things are all going to compute the same thing it's just the mechanism for it is a little bit different so the the benefit of currying is you're essentially in some ways partially evaluating the function yeah so your every part of the curved function takes one parameter so you're sort of building up this expression and there's a time for example let's say i have a function of multiple parameter maybe i want to evaluate the first three parameters and then only change the fourth one so the benefit then is i can create a function that is in the first three parameters and then apply to a variety of different fourth parameters without evaluating the whole thing over and over and over again so it's really not a a functionality issue right they all do the same thing it's just the mechanism to get there yeah exactly right and like let's say you've already written a bunch of functions that all take two arguments and they do all the work that you want to do you don't want to have to go through and rewrite them all as make adders and make subs and whatever you just want to call curry on each one and then you're done so it's basically just like breaking apart the two different pieces of make adder one is that it adds and the other is that it takes two arguments curry two just says here's the part about taking two arguments in sequence and uh let f worry about what is actually going to happen at the end of the day well this looks an awful lot like uh the multi-adder problem but let's uh work on it together so the question is about spring 2020 midterm one um question number four which how does it work you pick a number of functions they're gonna compose together like three then you say what all those functions are like i wanna abs the result of adding one to the result of adding one to something and that makes a function which does these three things in sequence so it takes in an argument it adds one to it it adds one to it and then it takes the absolute value so the reason we got two here is that we had negative four added one to negative three added one to negative two to the absolute value we got two that's what this does um let's look at the case where we're only composing one function together if that's the case then i think we want to return that function so compose one abs i think is equivalent to just abs so we're gonna get in some new function and we'll just return that so if we passed in one for n and then we passed in abs for f we'd get a function that takes the absolute value of things if we pass in negative 4 to that then we get the absolute value of negative 4 is 4.
okay let's take a look at this what happens when n is not 1 well then we're gonna take in some f and we're going to take in some g and we're going to uh at some point call f of g on something but i'm not sure we know in advance what we're calling f of g on so let's give it a name that's certainly part of it let's not worry about that um the template for now and just think about what happens so now we have a function that um so our goal here if we for example uh had n equal 2 would be to return a function that calls uh g on x and then f on x and we'd be done if compose was called on three things and now we've taken in abs as f and add 1 as g we still need to take this function and compose it with whatever comes next so we started with three functions now we've kind of taken the first two and put them together we still need room for the other one which i think we could get by calling compose on n minus one here we can now uh take in two functions and it seems like the first one should probably be that and then what would come next is like whatever this gets called on later so i think to fit this into the template we could get rid of the parentheses that are already provided to us except apparently it's impossible to edit something you've already written uh in zoom but you kind of get the idea so let me just leave it at that is that you'd not have to write these parentheses but instead you could just uh have them already appear there i mean notice this looks a lot like the previous example with the adder yeah it is basically the same question yeah anytime you see a function that takes n and n is a number you better make sure that if you're calling it later you call it on a number and you should think hard about what this returns this returns a function that takes a function in this case so you better call that on a function so it's i wouldn't generalize and say like oh you're always going to call this on n minus one or you're always going to call it on a function you're always going to return a function or something like that really the trick is to focus on given the pieces that are already provided to you which in this case are compose and call and on make sure that if you use those you use them on the appropriate arguments and that you use the return values of those in an appropriate way right there's still some confusion about recursion versus returning a function so let me just clarify recursion is when you call yourself from within the function which is different than returning the name of the function yeah so recursion is not on the exam we'll be doing that i guess this weekend next week but returning as you've seen in these two examples um is fair game i want to emphasize something john also said is don't don't get bogged down in the hardest problems uh the ones we've been answering today i think probably john maybe agree with you are some of the harder ones you should obviously want to do those as well as you can but don't don't get too bogged down on those when you're doing the exam do the ones you can do and then worry about these later yeah the students who tend to get a's in this course and the ones who skip multi-adder and uh just make sure they get the rest of it right so uh that's that's my general advice if you really want an a plus i guess you gotta learn how to solve that one too all right uh one logistic question about uploading the the recording uh no it doesn't have to be recorded before the time the exam is up that would be unreasonable uh so just when the exam is over just go ahead and upload it yeah and if it takes a long time to process you can go to bed and upload it in the morning that's fine i'm afraid we'll be done for the day but it was a pleasure talking to you all and good luck and you know take it easy work on the stuff that you know well uh make sure that you answer those questions right and if you see something you don't know it's okay uh you'll still do fine on the exam 