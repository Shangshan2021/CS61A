Let's talk about recursion in environment  diagrams. The nice thing is that environment   diagrams are useful for understanding recursive  functions. So we're going to look at a new   example, the factorial function, which computes  the factorial of n, or n times n minus 1 times n   minus 2 times n minus 3, all the way down until  you get to 1. We'll start out by looking at the   Python Tutor itself. So here is an implementation.  Define the factorial of n to be, well, if n is 0,   we return 1. That’s part of the definition of  factorial that 0 factorial is 1. Otherwise,   return n times the factorial of n minus 1.  There's our recursive call. And finally,   we're going to call factorial on 3,  which should give us 3 times 2 times 1,   and will be that. Okay, so first, I define the  function and then I call it on the argument 3.  3 is not 0. So I evaluate n times factorial of  n minus 1. So we need to figure out what are   these two things we're multiplying  together, which involves computing   factorial of n minus 1 where n minus 1 is  2. So I make another call to factorial,   this time with n being bound to 2, because  that's the argument that I pass it. And I   execute the body again, this time in a  new environment, where n is bound to 2.
2 is not 0. And so we evaluate n times factorial  of n minus 1 again. But in this environment,   n minus 1 is the number 1, which means our  next call to factorial will have a different   number bound to n. So now we have 1, 2, 3 calls to  factorial. Might we get another? Well, let's see,   that involves executing the body of factorial,  or fact, one more time. Okay, so we execute fact,   we see if 1 equals 0. It doesn't. So we have  to execute this return statement one more time,   which means evaluating fact(n-1). What's n-1  at this point? Well, that's 0. And so we call   fact on 0. One more time, we execute the body  of this function and see if 0 equals 0. Aha,   it does. And so we return the number 1. And now  finally, we have a return value. Now, what happens   when we return? Well, we return back to the line  that we were evaluating when we made this function   call in the first place, which was this factorial  n minus 1, back when f3 was the first frame of the   current environment. And what we found out is that  fact n minus 1 in that frame had a return value of   1. Okay. Now we find that there's a return value  of 1 for this frame as well, because n is 1,   and this evaluated to 1, and 1 times 1 is 1. So  we return that to wherever we were, when we called   this function in the first place, which by the  way, was in the middle of executing the return   statement in the f2 frame, which was again inside  the same body. And it was again, evaluating this   expression that I have highlighted, which now  has a return value of 1. We multiplied n equals   2 times the return value of fact(n-1), which was  1, and 2 times 1 is 2. So that's our return value.   So we return 2 exactly to the same place but in  a different frame, back when we were executing   the return statement of the original call to  fact. In that case, we're multiplying 3 times   whatever we got here, which was this return  value, and 3 times 2 is 6. And so we get 6   for the entire return value of fact(3), which is  actually the right answer, 3 times 2 times 1 is   6. So somewhere in the middle of execution,  our environment diagram looked like this.  At this point, we're returning from the last call  to fact, but we haven't returned from these yet.   Let's just analyze some properties of what happens  when you call a recursive function. Well, the same   function is called multiple times, as we can see.  One call is from here, several different calls   came from here. So this one was from here. But all  of these f2, f3, and f4 frames came from calling   fact from within fact. Different frames are there  in order to keep track of the different arguments   in each call. So this is why we're able to call a  function multiple times, with multiple different   arguments, even one within the other. And the  computer doesn't get confused, because it has   this model of evaluation, where we have different  frames, holding the different argument values that   were passed in. What n evaluates to depends upon  which is the current environment. So there are   all these different n’s, each corresponding to a  different call to fact function. And that means   that every expression that has an n in it might  evaluate to a different thing, depending on which   environment I'm in. And each call to fact solves  a simpler problem than the last. In this case,   because n keeps decreasing. Now, once n gets  to 0, then we have a really simple computation,   we just return 1. So there's less work to do when  we have n is 0, than there is when we have n is 1,   and that's less work than when n is  2, that's less work than when n is 3.
Now we can compare what happens when you have  iteration versus recursion. So iteration is a   special case of recursion. And here's our  factorial function. Here's what it does.   And here's another implementation, using a while  statement instead of recursion. So I could say,   I can compute the factorial of n by keeping  track of the total factorial, and what number   I'm about to multiply in. And as long as k is  less than or equal to n, I change total to be   total times the next number that I multiply in.  And I change k to be one more than it was before.   And when I'm finished with this while statement,  then total will be bound to n factorial. So k   was 1 and then 2, and then 3, and then 4, and  we multiplied all those in. Using recursion,   we say something a little bit simpler. We say  the factorial of n is 1 if n is 0, otherwise,   it's n times factorial n minus 1. Now, it  not only took me less time to explain that,   but it was easier to write in terms of the number  of characters. And perhaps the logic is easier   to follow if somebody else comes along and reads  the function. So there are certainly cases where   recursion just simplifies things. And I think this  is one of them. Now, the mathematical formula that   corresponds to each of these implementations is  a bit different. So the iterative version says,   I start with k as 1 and then I go up to n, and  I multiply in the number k each time. That's how   I get n factorial. That exclamation mark means  factorial. The recursive definition corresponds   to a mathematical expression that looks like n  factorial is 1 if n is 0, or n times n minus 1   factorial, otherwise, which is also a correct  definition of factorial, just looks a little   bit different than that. So this one corresponds  exactly to that. This one corresponds to this as   well. But there's a little bit of extra machinery  in here to keep track of the total, and make sure   that we're multiplying in each piece correctly,  and then returning the right thing at the end.   Now, we can see the extra complexity, in fact_iter  versus our original definition using recursion,   just by looking at all the names that are  involved. So we have the name n, the name total,   the name k, and the name fact_iter. Whereas in  recursion, we only have two names. And it's up   to the frames and the environment diagram to  keep track of where we are in the computation.   Whereas on the left, we have to do that by  keeping track of total and keeping track of k.
