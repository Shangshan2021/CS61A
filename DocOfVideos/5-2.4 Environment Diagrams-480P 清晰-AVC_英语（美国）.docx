next we'll talk about environment diagrams.  so environment diagrams are a way for us to   keep track of what's going on within the Python  interpreter when it executes a program that we   typed. and environments are real things: they're  the way in which an interpreter for a programming   language keeps track of what names meet. so it's  sort of memory that keeps track of the bindings   between names and values. so we're going to draw  pictures of what they look like and this will   help you become a better computer scientist. lots  of what computer scientists do is draw pictures   that involve boxes and arrows pointing to other  boxes. it's just a huge part of the discipline so   you might as well start now. okay so an environment  diagram is there to visualize the interpreters   process so that we can really understand how  programs get executed. and they look like this.  so you have some code on the left and then you  have some frames on the right. and the code is just   regular Python code with some arrows to indicate  where we are in the process of execution and the   frames keep track of the bindings between names  and values. so the codes on the left, the   frames are on the right. within the code there are  statements and expressions. so we see an import   statement and an assignment statement here. the  arrows indicate the evaluation order. so the gray   one says, this was just executed, and the red one  says, this is next to execute, it hasn't happened yet  frames on the right show bindings between  names, pi is a name, and values. there's a name, there   is a value. within a frame - this is hugely important, this is part of the Python process - within a frame   a name cannot be repeated. it has to be bound to  at most one value. we saw the consequences of this   when we rebounded the name max to a new number  instead of the original function. the old binding   was lost. okay so those are code on the left, frames on the right: an environment diagram. these   are going to get more complicated but also more  necessary because when there are lots of names   repeated in various ways we'll need to be able to  keep track of what they really mean. these things   get drawn for you automatically. so here's the  web interface to what's called the online Python   tutor. so here's the code that we type in: from  math import pi. I can edit this and then you click   visualize execution and you get your code on your  left and your frames on the right and as you walk   through each line of code by pressing forward you  see the consequences of executing. first this import   statement bound the name pi to its value and the  next thing that happened is that the assignment   statement found the name tau to 2 times pi. and  here's the result at the end of the thing. so when   you're confused about what a program does, paste  it in to the online Python tutor and it will show   you exactly what happens throughout the course of  execution. that's the whole point. okay so that's   what an environment diagram looks like. now how we  can talk about exactly what assignment statements   do. they change the bindings between names and  values in frames. so here is an environment   diagram for three lines of code. just executed  was b = 2, next to execute is this larger   assignment statement that has two names on the  left and two expressions on the right. now there is   an execution rule for assignment statements that  you need to understand because python always does   the same thing over and over again and here's what  it does for assignment statements. it evaluates all   of the expressions to the right of equals from  left to right. then after evaluating all those   expressions it binds all the names to the left  of equals to the resulting values. so in this   case here are all the expressions to the right  of = we get a + b which evaluates to 1   plus 2 is 3. so this evaluates to 3. b evaluates to  2 and then second step find all names to the left   of = to the resulting values. so b will be  bound to 3 and a will be bound to 2, the value of   that expression. ok so if we hit forward in the  environment diagram generator the just executed   arrow will now be on line 3, and the global frame  will have a bound to 2 and be bound to 3. okay so   now we can do the complicated case that I asked  you to solve by ourselves. let's just do it live   in the Python tutor. so here was the question: what happens if I say f = min then f =   max then g, h = min max and max = g then  this large nested call expression? well let's watch   and see what happens. so the first thing that  happens that f is bound to min this is the min   function representation in the environment diagram  that's similar to the angled bracket thing that   you saw when Python printed it up. then we bind  f to max. now remember the rule, that a name can be   bound to at most one value in a frame, so since we  rebound f to max we've lost the binding between f and min. that's just gone. now we say g and  h are bound to min and max, so we evaluate min   as the min function, we evaluate max as the  max function, and we bind g and h to min and max.   notice there's only one min function, there's only  one max function, but the max function now has two   names, f and h. the min function has the name g now.  there's also the name max for the max function   and then a min for the min function. those are  built in and they're part of the global frame   but we don't write them down because if we had to  write down all the built in names then that would   take up too much space. so we only write them down  when they change which is about to be what happens.   so next, say max = g. using the execution  rule for assignment statements we first evaluate g. g evaluates to the min function. then we bind  the name max to that value so now max means min.
jeepers that is complicated isn't it! so then  we say max of f of 2 of g of H of 1 and 5, 3, and 4 and   that involves evaluating all of these different  operand expressions in turn before I hit forward.   let's just watch how that goes. so we can draw  an expression tree that evaluates the operator   and operands of the call expressions and the  operand sub expressions within them. so remember   the rule for evaluating a call expression. first  you evaluate the operator which in this case is   max the name refers to the function which  minimizes. then we evaluate the operands. the   first operand looks like that and we have to  apply our rule for evaluating call expressions   again. evaluate the operator, evaluate the operands,  this operand is complex so we evaluated, g refers   to the min, we see that here in the environment  diagram. h(1, 5) is another call expression we   evaluate that by first evaluating the operator. h is the max function, 1 and 5 are 1 and 5, and   so the max of 1 and 5 is 5. now we take the  min of 5 and 3 and we get 3. now we're going   to take the max of 2 and 3 and we'll get 3. and  then we'll take the min of 3 and 4 and we'll   get 3, which is the value of the whole  thing. congratulations if you picked 3! 