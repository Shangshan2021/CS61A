Now we'll talk about the relationship between  recursion and iteration. So there are cases when   you want to convert a recursive function into an  iterative implementation. And that can be tricky   because iteration is a special case of recursion.  But for many functions, there is a straightforward   conversion into iteration. And the example we  looked at before is one of those. So the idea   is that you have to figure out what state needs  to be maintained by the iterative function across   each pass through the while statements. And so  if we look at the sum_digits function that we   implemented earlier, we can look at what gets  passed into sum digits and each recursive call   and what gets returned. And those are clues as  to what we might need to give names to when we   write an iterative version. So it gets passed  in is what's left to sum, which we call n, here,   as a formal parameter. And what gets returned  is a partial sum, the sum of the digits so far.  So let's try to write an iterative  version. Sum_digits_iter of n. Well,   we're going to store the partial sums so  far. And then while n is greater than 0,   meaning there are digits left of sum, we will  rebind n and the last to the split-up version   of n. So n will become smaller than it was  before, it will contain all but the last   digit of what n was, and last will contain  the last digit. Then we can update digit_sum   to be whatever it was before, plus last,  and we'll eventually return digits_sum.
So we can still sum_digits. And we can now  sum_digits_iter and get the same answer.   So by inspection, we figured out how to  do that. It turns out that converting an   iterative implementation using a while statement  to recursion is quite a bit more straightforward.   Precisely because iteration is a special case  of recursion. So here's the story. When you look   at an iterative implementation, you look for  the state that is maintained across different   iterations. And you just pass those in as  arguments. So here's our iterative implementation   of sum_digits. And the state that's maintained  across each pass for the while suite here is n,   which changes to be all but the last digit  of n, and the digit_sum, which contains the   partial sum of digits so far. So when we write a  recursive version of the same thing, we pass n,   exactly that n, and the digit_sum so far.  Instead of a while statement that says while   n is greater than 0, we now have a base case  that is exactly the opposite when n equals 0,   then we just return the digit_sum. Otherwise,  we execute the same thing as the suite of the   while statement, except that we pass in the  new values of n and the updated digit_sum   as arguments through a recursive call. So we  make the recursive call sum_digits_rec on n,   which is bound to all but the last  digit of what was passed in. And   then digit_sum plus last is the sum so far.
So updates via assignment become arguments   to a recursive call. And this can be done quite  generally for every intuitive implementation.
