this is the q a session for lecture number eight and the first question was about the cascade function which appears in the textbook in the recursion chapter that i asked you to read but i think we actually discuss it in friday's lecture i think it looks like that now this is the recursive case we still need a base case i need a base uh otherwise this would just keep going um so if n equals zero then or i guess i think in the textbook it was if n is less than pen then we'll just print in otherwise we'll print in and then cascade and then print that again this is wrong okay so then we've got the oh you can't even see we've got to do a smaller one so you can see the whole thing that's kind of all you need to see what's going on so the output looks like this there is a print before you cascade and a print after you cascade i think this is an example that you were asking about or at least similar yeah so let's talk about this one um the story with making a recursive call is actually the same story as making any function call which is that you have to do whatever the body of cascade is on the value and divided by 10.
so if n was originally 321 this would just be 32.
and then you have to finish executing the body of cascade the original time so if n is 321 it's not less than 10 we skip that part but we print 321 we then do whatever cascade and divided by 10 is whether this is a recursive call to cascade or if it's something else we would do the same thing which is just like run it to its completion we don't do anything with the return value of this it's going to end up returning none so i guess that's fine that we just ignore it but then after we call cascade we're printing n again and n is still 3 21. now in other calls to cascade n will have a different value and that's what you see in the environment diagram but um in the first call n was 321 for this print line and it's still 321 for this print line because we never assigned to n in between so think of it this way too on the first call to cascade with three two one you hit the else clause and let's agree you have to evaluate three lines of code so the first print is easy print three two one there's a recursive call okay you're gonna go do something do something do something and eventually there's there is a promise to come back and evaluate that last print what is the n for that last print well it's three two one so for example if john had written print um if we have a slightly different print statement there so we can distinguish between them so let's put like a maybe do like a yeah before and after right so we can now distinguish between the prints right so think about what you expect to see yeah so there's going to be all those before prints and then there's the three from the if statement uh the base case rather and then there's all the afters those were the promises and notice they're in reverse order because before i can finish the call on cascade 321 i've got to do the cascade on 3 2 and so on and so forth and at the very end there is that la that first promise from the very beginning to print three two one the next question was how does londsum work and what is mutual recursion in general sure let me pull it up so while john is doing that let me just to make sure everybody knows what mutual recursion here so recursion is where you call yourself within the function yeah we just saw an example of that where within the body of the function we are making an explicit call and let's distinguish that by the way from what we saw on monday where we were returning a function that contained a function call to ourselves so here we are actually now making that function call calling ourselves in a loop and of course the base case is what eventually gets us out of that mutual recursion is where you have two functions this um this credit card sum is is a nice example of it where one function calls another function and that function calls this one so it's sort of it's almost like they're doing this there are these two functions that are calling each other that's what we mean by mutual recursion and i think this is the example you know is this what you were asking uh delenia oh yeah that's one yeah so um here's the latin some example and it is mutually recursive because lonsum doesn't actually call lun sum anywhere instead it calls on some double and lon sum double doesn't call unsung double anywhere instead it calls lunsum but every time you call lunsum you're gonna end up calling one some so it is recursive uh now there are base cases that prevent that from happening occasionally but the fact that a call to lunsum could eventually result in a call to london um before you're kind of done evaluating the first call to london means that this is a recursive function so it's mutually recursive because it's not so obviously so it's got this level of indirection some other function that it has to call um okay so this is really kind of like a helper function for lonson so this is return though alone so and lundsam has this it's just like a mathematical operation that you can perform on a number that has this uh funny characteristic where you go through every digit and you double every other one but then sometimes when you double a digit you get a two digit number and that's a problem so uh that's why there's like a sum digit step in here as well which i guess we need in order to have this run stick it all up there so let's talk a little bit about how this works and then we'll run it and then maybe questions will be answered when you take in an n for lun sum like one three eight seven four three you don't actually double the three before adding the digits together you double only the four and the eight and the one so we kind of need a way to keep track of whether we're on a odd digit or an even digit and that's why we have mutual recursion here is that lun sum is the one that just adds in the last digit which we have written out in the code here whereas lun sum double doubles the last digit and then it adds it so it's called lun digit here it's the result of doubling the last digit and then if it turns out that doubling it like doubling a 8 gives you 16 then you add the 1 and the 6 together to get 7. so eventually you get down to 1 digit but there's kind of an involved process to do it so um so what so lunsum called on this is going to result in a call of lun sum double on one three eight seven four which is going to as it's being processed call lonsum on 1 3 8 7 etc so we can see that since lonsum doesn't double its last digit it's not going to double the 3 it's also not going to double the 7 when it eventually gets there but since lun sum double does double the last digit it will double the four because that's its last digit which was originally the second to last digit and you can imagine that the next call on lonsum double 138 is going to double the 8. so that's the mechanics by which this expression ends up doubling every other digit and we'll just watch it run so we define a bunch of functions and then we finally call lon sum on one three eight seven four three uh we'll talk about this actually on monday but this is just like how python keeps track of returning two different values from split so don't worry about it too much um you can see what happened to these values they just got bound to names so lonsum double gets called on 13874 and then one sum gets called on uh one three eight seven so you know they're just alternating but shaving off a digit each time and when you do that you end up doubling every other digit by the way i think you could have written this without two functions you could have done this strictly recursively it's a little tricky to keep track of the digits you have to keep track of every other digit um but i think there is a way of doing this it's a good exercise so if you if you want to try to do this john did i do you see it do you think i'm right that you could do this yeah you're totally right yeah so that could be a good that's a good exercise by the way um try to write this recursively by the way write it first write it iteratively just write figure out how to do this iteratively yeah and then try to do it um strictly recursively there's a way to do it you have to keep track of the digit which is a little tricky but there's a way to do it i think that's a great suggestion okay sorry a couple questions in the chat let me just get to that so luis is asking how are we checking if doubling is greater than nine so where uh ah right line 30 uh right there yeah line 34. you see it so um when you um when you multiply it by two we're summing the digits and that is defined to be the last yeah digit and like it happens to be that if you sum the digits of a one digit number you just get that number back so we're kind of taking advantage of the fact that some digits will deal with the case where it's bigger than nine but it will also deal with the case where it's less than nine so we just call it we're done and sandra is asking in the chat thank you luis um is is is it that whenever we have a recursive call we always go down the frames in the environment and then go back up and i think the answer there is yes um you know basically what you're doing is you're making a recall you're making a call another call and eventually you have to sort of go back and finish all the calls so it's we call it a stack like you you put a bunch it's like a stack of plates you make a bunch of calls and then you take everything off and then you go so it's up and then down or in this case down and then up yes yeah good question so what's the difference between recursion and self-referencing uh recursion involves making a call to f within the body of f and this is complicated because when i call f on something i might get many many calls to f as a result even though i've only like called it on one thing it can kick off a whole chain of computation the ones we saw in this lecture are all things that you could have done with a while statement they're like the the chain of computation sort of goes sequentially in a bunch of steps and so um that's not so crazy the stuff that we'll do on friday where it turns out that you could actually make multiple recursive calls within the body of a function can lead to very interesting computational structures where you end up doing like a whole lot of work just from one call so that's what recruiting really is is when calling a function would result in calling that same function self-reference is using the name of the function that you're defining somewhere within its body this will not kick off some long chain of computation kind of you're only going to get one call for f for each time that you call it so i know like i'm going to get three calls to f here because i called it three times i'm not going to get any more than that in the self-reference case so we tried to teach you self-reference to say like oh it's okay to refer to f from within f without having to deal with the complexity of what happens when you actually call f within f which is that it kicks off a long chain of computation from one call by talking about self-reference before we talked about recursion but um yes but recursion is really two things it's like self-reference plus um every call results in another call which results in another call which results in another call that critical point there is that you are calling the function right is it in in a very iterative sense right you're doing an actual evaluation or an execution yeah a follow-up question was what about self-reference where the self-reference is within a function within a function okay so there are these cases in self-reference where uh f returns g which calls f something like that it turns out that when you call f you don't call f you just return a function and it turns out that when you call g you don't call g you just return a function so in this more involved case of self-reference you're still not going to get a long chain of calls by just calling one of f or g you're really just going to have one thing happen if you call f you return g if you call g you return g by calling f uh but at the but you never get something that would be like uh recursive evaluation would require you to have f called g and g calls f which means f calls g which means g calls f which means f calls g which means g equals f and this would go and go and go the next question was whether it's better to use an if else construction in a recursive function or just if base case and then write the recursive case outside of hills that's a good question um i don't know that one is better than the other i i think this may be a style issue i i often like the else i like to make it explicit i find that it just sort of helps me read code as opposed to having to infer it but i don't know maybe john people has a different opinion yeah i mean it's a great question like if you've got some recursive thing where there's a base case here and you know in your base case you're going to return then do you really need this else before you do the rest of the work or can you just leave it out because you know if you hit the if then you're going to return anyway and so you're always you're you know you're never going to get here um i uh tend to prefer in like actual code that i write that i don't need to maintain to keep the else because if one day i decide i go this shouldn't return anymore i want to change this so it prints or something instead then i'm still going to have the behavior that i'll either do the base case or the recursive case but not both whereas if i had written it this way kind of depending on the return here to avoid doing this work and then i change this return to something else then all of a sudden this is actually going to get run like if you have the code if something print this then otherwise do this it's not otherwise like it could be the case that you would print this and do this and that is something that probably in the design of your recursive function you never want to have happen and a good way to enforce that is just to make sure it's in an else case but it does work either way yeah it works either way of course and and i think john and i agree on this i don't like relying on sort of a side effect of my code because code is not static right it's always changing and it's also a readability issue i like my code to be explicit not somebody has to really look to understand because that exact statement if it wasn't a return would have a different behavior than if it was a return so from a readability perspective to you know i like to sort of be explicit about it yeah but both of obviously would work once you have a return there because you're booted out of the function you have to worry when should you return the result of a recursive call and when do you not need to do that yeah that's a great question um so in the example that john just gave um he was just calling the function because all it was doing was printing yeah so there was no need to return but if we were building up an expression like in the fibonacci sequence so we are saying n factorial is n times n minus 1 factorial there's the recursion then that function has to return something to put into the expression that we're building up so that needs a return it has to be n times well something well what is that well it's whatever the recursive call returns yeah so there you absolutely need the return on the other hand if i just wanted to print out the value of a recursive call as i count down to make the recursive call i don't really care so it has to do with sort of what are you building up yeah and you'll see examples of both you'll see examples where we do return something because we're building up an expression because we're computing something like summing up the elements in the list or summing up the digits you'll see other examples i don't know if we're going to do the towers of hanoi example but you'll see one where we solve a game and it just you just have to you know just call these things to just evaluate something i mean the whole point of returning is so that whatever called this function can do something else with the return value and that's very common in recursion as well that like the goal of the recursive call was to get a value that you're then going to do something else with like multiply it by n or whatever and in all those cases you have to return if you just print something out you can't do anything else with it so only by returning it can you allow the caller to manipulate it further the next question is under what circumstances would you decide to write mutually recursive functions so what which so as i said you could have written that with just a single recursive call but what's the trick here you have to keep track of the digit yeah so if we are when we were for example summing up all the digits in a number every digit was treated the same and so you just you just need a single recursive call you can sort of see how you do it so here um every other digit is being treated differently so you have to keep track of the digit um and so that i don't know that there's there's obviously not a right answer you could have done it as we did here with mutual purging or you could have done it with a single recursive call just keeping track of the digit so i don't know if there's a good answer here it has to do more with the logic of like what information do you need to lug around yes yeah yeah i think that's exactly right so like having mutual recursion just gives you another way of tracking something instead of tracking it by assigning it to a name you're tracking it by figuring out which function you're in right now yeah i mean it's essentially a way of keeping state we've talked about keeping track of state i mean basically by calling a different function every other time we have a sense of state without explicitly holding on to a variable to do that for example the next question was what would lund sum look like using an iterative implementation well if i was doing this iteratively i would i wouldn't have another function what i would say is i'd have a single loop i'd have a conditional that says if i'm on an odd digit add it and if i'm on an even digit double it and add it and i don't i wouldn't create a second function for this because iteratively i can keep state very easily because i know in my counter which digit i'm on so i don't know if i had to write this iterably i don't think i would have created another function but yeah so i would so in this that this is a good exercise is write this in fact for a lot of the recursive things and by the way as john said in the lecture recursion can be hard to get your head around so it's often good practice to just write these things iteratively first of all it's just a good exercise to write these things literally using wild and for loops um but yes so what you're going to have is i think john is about to write it here for us is you're going to have a variable that keeps track of which digit you're on and you have a little conditional inside the loop that says if i'm on an odd digit add the digit if i'm on an even digit double it and add it yeah so uh maybe instead of doing the whole thing for you we'll leave you something to do but you really do need to introduce more names if you're not using functions to keep track of what's going on so we introduced this name in order to keep track of whether we were in london some or lonesome double we introduced this name to keep track of the total result because you know recursion kind of does that for you it builds up results by keeping them in the return values of the different frames whereas in an iterative version you have to keep track of that yourself and then eventually you could return this yeah that's a good scaffolding to think about and then so the state that we were talking about is the variable double and if it's false then you just add and if it's true you double and add and then of course you have to change the state depending on where you are yeah so that's the scaffolding right there for how to do this iteratively within a single function next question was are there cases where you use elif statements in the middle of a recursive function absolutely i can certainly imagine a recursive call where i don't have just one base case but i have multiple base cases so i can certainly have a base case if n is equal to zero do something if n is equal to one do something and then even in the recursive case i can have another conditional that says you know depending on the state of something do something or not so you can you can right now where you're seeing very simple you know base case recursive case but those can get more involved and you can even have like multiple recursive calls so i can call the same function twice um in the body of the recursion i think we'll probably see some examples of that eventually yeah friday in fact excellent so like um i think you'll do this in discussion today if you're trying to do um the hailstone sequence recursively which we did at the very beginning of the course iteratively basically there's like something you're supposed to do when you have an even number and something you're supposed to do when you have an odd number and so uh it would make sense to say l if this is even do this else do that and you'll make your recursive call in either case but you're gonna make a different recursive call uh somebody's asking um in the question what do you mean by preserving state um so when we refer to state we sort of mean uh so for example in the example we were just looking at is are we on an even digit or an odd digit yeah we want to sort of know something about where are we in the computation and when we're doing things italy and we have variables it's relatively straightforward to keep track of that you assign the initial state every time you make a change you update the state if you need to so i'm on an even digit i'm on an odd digit um i'm on an even number i'm in an odd number when you're making recursive calls that can be a little trickier because you're not necessarily doing things by assigning variables and so in the previous example we did that by having this mutual recursion so state is just sort of you know where are you in the computation or what is a current value in the computation and it's one of these funny words that computer science uses a lot and uh it's not state like california it's state like the state of matter like you need to know whether your water is liquid or frozen or whatever and that might change it's because we're not really scientists and we want to pretend that we're scientists so we use terms from physics the next question was how difficult or complicated are recursion problems going to get so here's here's what you should know about recursion is that while it is really beautiful and elegant it is sometimes can be computationally very demanding depending on how you write the recursion um because of this sort of you have to have this memory of going back and undoing somebody asked the question earlier so there's something called tree recursion which will contend with some of those computational demands um i don't know how complicated things are going to get maybe john isn't a better um answer that they never get complicated really in the way that you describe you know you you can have higher order recursive functions but the goal is not to just like build something so crazy that you can't possibly understand it though recursion gives students a lot of trouble even in really simple four line nothing is nested versions because it's um as you'll see in friday's lecture there are really tricky problems that you can solve succinctly by letting the computer do the work but then it becomes like the computer's doing so much work that it's hard to trace what's going on so your old strategy if you have it of just like thinking through step by step how is this going to compute the result that i want doesn't really work anymore you could solve things like among all the possible ways of selecting some digits out of a number which one you know has the digits increasing and is the biggest or something like that and you know how would you do that well you'd have to consider all possibilities recursion lets you do that but the human effort required to do it is just so immense that you can't like step through it in an environment diagram um so you have to learn how to use functional abstraction to confirm that it works instead of just like stepping through the code so it's it's a different skill than what you've done so far in the course yeah that's exactly right so the question is how do you verify the correctness of mutually recursive functions you assume that they both do what they're supposed to do and then you can check each one individually so if you want to check lonsom you assume that london double does what it's supposed to do and verify that one sum therefore does what it's supposed to do and likewise with lonsum double you assume that lon sum does what it's supposed to do and check that london double does what it's supposed to do and then you verify the whole thing yeah and by the way this is what's sort of tricky about recursion is there's like this leap of faith john said it really nicely with the beautiful photo in the lecture is you sort of have to write the function assuming that the function works right and so a lot of it is this sort of this weird way to conceptualize things is to think about it well i'm writing a function that does x i'm going to trust that i'm writing that function and then i'm going to use that function to write the function and that's that nature of recursion and it seems really odd right now but it'll it'll get more comfortable i will say and i don't say this enough in this course that we focus on recursion because it's powerful but also because it really pushes you to just trust that a function is going to do what it's going to do because there's kind of no other way to deal with recursion but this idea this functional abstraction idea of just like oh i have this function it's going to do what it's going to do is extremely useful outside of writing recursive functions just whenever you're writing a large program you can just not worry about how some function does its thing you just call it and you assume that you'll get the right result because you understand conceptually what its behavior is and that's how you build large programs is that you kind of trust that each piece is going to do what it's supposed to do you have to verify each piece and and then you compose them not by tracing through the whole program but instead by uh validating each piece assuming the rest works the next question was what is peel recursion and are we going to learn about that in this course we are going to talk about tail recursion um and i don't know if we want to do that now john that's up to you if you want to wait until i think it's coming up this week or next week actually it's coming up many weeks from now i think like week 10 or week 11 we'll talk about tail recursion um it's a it's something that's um about programs i'll give you a little preview it's about programs but it doesn't actually matter for python because python the way the interpreter is implemented whether something's tail recursive or not has no implications about how it runs and so it's kind of not relevant for us at the moment um later on we'll study another programming language scheme where it does matter a lot and you know the story is pretty simple but learning all the details takes a little while and you're exactly right that it's about whether there's more work to do after you make a recursive call or not um and uh in order to understand why it's important i think it's helpful to understand more about how interpreters work like how is it that python runs the code that you type in and that's what we study in the last unit of the course that's why we talk about tail recursion the next question was what is teal recursion and are we going to learn about that in this course uh good question so what about mid-term questions that are about recursion by far the most common type is that we give you a description of what your function is supposed to do and you have to figure out how to implement it and these are usually quite short in terms of the number of lines of code and yet tend to be the most difficult folders to get right because you have to uh kind of discover how it is that you're going to get the result that you want using just a couple of recursive calls and this is never obvious we'll look at an example of why it's not obvious on friday's lecture when we come up with the there's a function called count partitions it's like one of the biggest parts of the lecture and and so you'll get a sense then of why solving a recursive problem isn't always just like thinking about the few steps that you want to do to get it done sometimes you have to figure out like which recursive call to make in order to make more progress on the problem without solving it all in one step and that is not an easy thing it doesn't come easy to most anybody but with practice you can learn how to do it and one of the goals uh and one of the reasons i like doing all this environment diagram before recursion is i think of it as sort of an enabling technology now that you understand environments and how calling sort of stacks up the recursion is a little bit easier to conceptualize um so now you have to really start thinking about how do i write recursive code which is more important and then the environment diagrams there are really just sort of an enabling so you understand sort of the calling of functions and the fact that you know these things call on top of each other yeah all right everybody uh i hope everybody has a restful rest of the day uh here in the bay area the um air quality is down almost a single digits so uh we can breathe again thankfully so we're all very grateful for that um have a good day i think we're having another office hour uh friday at the usual time and then john and i will have an ama at two o'clock pacific time on friday if you're interested in coming to talk to us about some other things thanks so much for the great questions 