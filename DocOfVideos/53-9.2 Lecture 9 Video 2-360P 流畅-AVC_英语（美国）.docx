welcome back at this point in the course we've believe it or not covered the core computational machinery that you need to know to be a python programmer there's lots to learn there's a lot of data structures and algorithms but in terms of functions variables looping constructs violin four conditional statements if alif else statements that forms the core of the programming language that you need to know to be a general purpose python programmer and again lots more to learn refining honing those skills writing good efficient well-documented smart code will come with with experience but that's the core of it now um we're gonna just before we get into some more of the data structures and algorithms um and what is called object-oriented programming i want to just take a little breath and talk about something called recursion and recursion in my opinion is this very beautiful computational construct and it's particularly beautiful because it deviates from everything we have seen up until now and the way you think about the nature of computation so again everything we've been thinking about and everything we've been doing up until now has been functions variables looping and conditionals and recursion brings in this very nice and elegant and beautiful way of thinking about the nature of computation and we're going to spend a little time talking about that because i think it's an important construct to understand as a general purpose uh computer scientist and programmer and data scientist let me start by reminding you of the definition of the factorial operator so of course the factorial operator is denoted with an exclamation mark uh and it has the following definition it is defined as you can see here only on uh positive integers that are greater than or equal to zero and so the definition of factorial says that if n is zero you're trying to of course compute n factorial then n factorial is equal to one so zero factorial is one and for all integers greater than zero n factorial is defined to be n times n minus one times n minus two down to one that is the product of all of the positive integers from n down into one and of course we've seen this before we see it pops up in in set theory and in probability and then counting all the time standard mathematical operator so before we dig into the recursion that i want to be the topic of this set of lectures let's just by way of practice write some python code to compute those and if you want to you can pause the video now this is a good little exercise but if not let's just go ahead and do it together i'm going to write a function called factorial that takes this input in n now let me just say before i dig into the code here really i should have some code in here that says make sure n is an integer make sure it's greater than zero i don't typically do that in these little examples because it just creates a lot of code but generally speaking when you have functions like this that have constraints on the input you should put checks and balances in your code to make sure that what is being passed in from the outside world conforms to your expectation but again just for cleanliness i won't do this here uh this code is going to compute factorial we'll go through the step by step in a second and you can see at the very end it returns and again remember what return does it sends it back to the calling function and this distinction between return and for example print is important it has never been more important than when we are about to stop start talking about recursion in a few minutes all right until then let's go ahead and look at this code and make sure we understand it so fact of course you can see here is going to be the variable that i send back i apologize they should both be color coded the same i initialize that to be one that's going to hold on to the running product i is equal to one is a counter that is going to as you can see in my loop here while i is less than or equal to one is going to go from one to two to three to four up until n i'm of course going to compute a running product all right here is my increment i'll come back to this line in a second notice by the way i just want to introduce the shorthand um what do i want to do on each iteration of the while loop is i want to increment i by 1 i takes on the value 1 and then two and then three and then four and so on this is a little shorthand because this is such a common uh expression we say i plus equals one which simply means i equals i plus one so on each iteration i'm incrementing i by one and what do i want to do i want to keep a running product so fact starts out as one i multiply it by one that's of course one next time through i have a two multiply that product by two next time through multiply it by three next time through multiply by four and you can see i'm keeping a running product fact is equal to the previous value of fact times the current value of i i get through that whole body of the while loop including n of course because n factorial is n times n minus 1 all the way down to 1 and then i return fact uh one little point by the way notice that in the previous definition of factorialized special case zero right i said zero factorial is one and then anything greater than zero is this i don't seem to have a special case here for zero so let's make sure this works okay so let's run through the code n is zero factors at one i is one while i is less than or equal to while one is less than or equal to zero is that a value to true no so what happens i pop out here and what do i return one that's zero factorial nice little i could have put a special case i could have said if n equals 0 return 1 otherwise but it just comes out because of the way factorial is defined in this iterative scheme here perfectly fine iterative scheme let's go through and just make sure we see how fact and i are incrementing because that's going to lead us to where we want to go when we start talking about recursion let's say i want to call factorial with 5. so i want to compute 5 times 4 times 3 times 2 times 1.
good first iteration through first time through fact is one i is one so i'm gonna i'm gonna do two columns here showing these values as i iterate that boolean expression of course evaluates to true so i go into it into the body of the while loop and what do i do i say fact equals 5 times i so what is fact going to be 1 and what is i going to be 2 because i incremented by 1 right there come back up 2 is still less than or equal to 5. dive back into the body of the while loop please now fact is going to be the current value of fact times the current value of i one times two good so factors two increment i by one go back up boolean expression is true multiply those two i get six increment let's do it again uh product of six and four twenty four increment okay now we gotta start being a little careful because we're getting near the end so i is five i come back up is five less than or equal to 5 sure is come back in multiply those two values of course to get 120 now increment i by one i come back up six less than or equal to five no come back to the get out of the body of the while loop return fact and i'm done i've got 120. okay good and you can see here that what we've done is on each iteration we've computed exactly what we promised this line is computing a running product so by the time i get to the fifth iteration i've multiplied five times four times three times two times one and when i was at this iteration i multiplied four times three times two times one and so on and so forth now there's something interesting looking at this iterative process because what you notice here is that when i computed 5 factorial along the way i also computed 4 factorial and along the way i computed 3 factorial 2 factorial and 1 factorial and that sort of makes sense if you think about the nature of the product so what is n factorial n times n minus 1 times n minus 2 down to 1. well what's n minus 1 factorial and minus 1 times n minus 2 down to 1.
and so to get n factorial i sort of have to get up to n minus one and to get the n minus one i have to get up to n minus two and so i can sort of think about this definition slightly differently i can define n factorial or five factorial let's say to instantiate it as five times four factorial and what is four factorial but it's four times three factorial that sort of makes sense right cause it's four times the product of three two one well what's the product of three two one well it's three factorial that's sort of interesting so let me let me redefine this definition of factorial so our initial definition of factorial was if n is zero n factorial is one good easy if n is greater than zero then it's the running product of integers between n and one okay so let me take what we that insight that we just had from that iterative code and redefine factorial here it is recursively okay i'm going to define i'm going to tell you what i mean by recursively in a second so typically speaking recursion recursive definitions have two components to it a base case and a recursive case and sometimes you could have more than one base case by the way so the base case stays the same the simplest thing you can do is say give me uh a zero factorial and i just tell you one there's nothing to compute it's literally by definition for all other integers greater than zero instead of defining n factorial to be n times n minus 1 times n minus 2 all the way down to 1 i'm going to define n factorial to be n times n minus 1 factorial which let's start off by agreeing is absolutely 100 correct why because n minus 1 factorial is i minus 1 times n minus 2 through the previous definition okay but imagine i didn't give you the previous definition imagine you didn't know what factorial was and you came to me and said hey professor freed what is n factorial and i said oh it's really easy if you ask me for zero factorial the answer is one and for all other uh values of n factor of of n n factorial is equal to n times n minus one factorial you might say well okay but what's n minus one factorial and i'm like oh that's easy that's and minus one times n minus two factorial and you get the sense that i'm sort of screwing around with you a little bit uh because i'm sort of defining a function in terms of itself and that is exactly what recursion means but i am not in fact messing with you in fact this definition works so let's see why let's say you ask me what is 3 factorial and i say it's 3 times 2 factorial and so you've made a little bit of progress you know it's three times something but you don't know what that something is and so you ask me what's two factorial and i tell you well it's two times one factorial all right we made a little bit more progress what's one factorial oh that's easy it's one times zero factorial what's zero factorial aha the base case zero factorial is one and now what do you know you know that three factorial is three times two times one times one the base case and so it seems like this is sort of a weird definition because i'm defining a function in terms of itself but eventually if i follow down that road because notice this problem's getting simpler and simpler by decrementing by one i will eventually get to the base case and i will have built up an expression along the way when you asked me for three factorial i said it's three times two factorial and then you went and figured out what two factorial was and then you came back and said ah it's three times that quantity and then you did the same thing for two and for one and eventually for zero and that is the nature of a recursive definition and of course we can now implement that in python in very beautiful ways so let's go ahead and do now a recursive versus an iterative so i will refer to wild and for loop implementations as iterative solutions because you're iterating and what we're about to do are called recursive and you'll see in a minute why there's a difference between these two and what that difference is please uh define for please i'll write a function a recursive function factorial that takes a parameter and again i won't check if the parameters are greater than or equal to zero base case is easy if n is equal to zero return one and notice here i'm going to now make the base case explicit okay so this is easy and absolutely correct not a very useful function because for all of the values of n there's nothing to do now what do i want to do if n is greater than zero well if n is greater than zero i want to compute n times n minus 1 factorial well how do i compute n minus 1 factorial i've got a function to do it so what happens if i just say return n times factorial of n minus 1.
there's the recursion that function definition and that function call are the same thing you are calling yourself recursively now also notice this return i said earlier when we did the iterative solution this is really really really important and you're going to see in a minute why it's important but notice i'm not printing i'm not assigning in fact there's no variables here there's no fact there's no fact equals i'm just building an expression and we're going to see that in a minute put this into python and it will work it will return for you uh five factorial 10 factorial whatever you want and it seems sort of like we're cheating it doesn't seem like it should work but let's now in fact see why it works and the magic here is that while it seems like we are all we're doing is calling this function over and over again notice that we are building up an expression here so i've peeled off i've simplified the problem a little bit i've said 3 factorial is 3 times something what's that something well go ahead and figure it out and when you're done come back and put it into this expression for me and i'll tell you what the final answer is so this little this little thing right here this is it and this returning of a value that's where the nature of the computation is happening and now you can see why recursion is so different there's no variables there's no assignment operator you're building this expression up and now let's make sure we can go and see that and let's do that by calling three factorial so here's my function definition if n equals zero return one otherwise return n times a recursive call to myself with n minus one as a parameter i call three factorial and now you've just gotta follow the code it's like all everything we've done to now just write out the code what happens okay three comes in it's not equal to zero so i come into the statement and i return to the user three times factorial two but i can't quite return it to the user yet because that is not a value that i can compute multiplication on so i have to go call factorial of 2.
so it's sort of like if i said return 3 times square root of 27. i'd have to go compute square root of 27 it's not a recursive call come back can do the the arithmetic and then send it back to the user it's the same thing here the only difference is i'm calling myself and i just have to remember that when i eventually get an answer here i'm going to have to multiply by 3 and that will eventually get sent back to the calling function all right so forget about three times for now we'll keep a memory of that yeah it's called a stack uh let's compute two factorial that's what we need in order to finish this expression all right two comes into here it's not zero so we return what two times one factorial okay so we sort of got somewhere we sort of didn't yeah so 3 factorial needs to know the answer to 2 factorial 2 factorial is 2 times something but i don't know what that something is yet so i've got to okay i got to go figure that out and then i'll eventually compute this and then i'll eventually compute this all right let's go figure out 1 factorial 1 factorial comes in that's not true so return 1 times 0 factorial there it is right there all right now we're getting closer right because what's going to happen when i call 0 factorial zero comes into here and a zero return one i have a value here so this is going to go off and call something and it's going to return an actual value no more recursion we hit the base case no more recursive case all right now let's see what happens let's forget about the three forget about the two for a minute let's just look at one and below yeah so one factorial is one times zero factorial zero factorial is a function called happens to be recursive but honestly i don't care it returns one and so now that one and here it is it's a return statement why does that matter because that's a function call and that means i'm going to send a value into that function and it has to send me something back that i can use in an expression it's exactly like calling square root you can't print the square root that does mean no good i'm trying to use it in an expression you have to return it to me return it to me so that i can use it an expression all right one gets popped back into this call for your factorial and now i can do the arithmetic i can do the multiplication so i'm gonna just multiply one times one and now i have an answer to one factorial because that evaluated to an actual value and it's being returned back because of that return statement right there so now the 1 gets replaced in there and now i have 2 times 1 is the answer to 2 factorial a 2 gets returned to that the 2 gets returned to the factorial of 2 and now i have an expression that i can evaluate so eventually it took a little while eventually what happened is that that two factorial called one factorial was called zero factorial which hit the base case and then i started popping up those expressions and now i have an expression and i return of course 6.
so the nature of recursion is that we build up expressions using a recursive definition of a function and these return statements which essentially hold the memory of that expression as it is being built so you can see here it's a really really different way of thinking about the nature of computation it's not right or wrong better or worse sometimes it's a little bit better sometimes it's a little bit more elegant sometimes a little worse sometimes it's less efficient because you have to hold on to the memory of all of these things but it's a really powerful concept and i think it's an important way to think about the nature of computation so we're going to spend a little bit of time looking at some more recursive examples and make sure that we understand this paradigm paradigm of computation and we'll pick it up in a few minutes 