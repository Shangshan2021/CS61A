Tree recursion happens when one function  makes more than one recursive call.  Tree recursion creates tree-shaped processes  that arise whenever executing the body of   a recursive function makes more  than one call to that function.  And there's one example that almost every  class that includes tree recursion covers   at some point, the Fibonacci numbers.
There's our friend Fibonacci.  He indexes his numbers starting at 0.
So the 0th number is 0.  The first Fibonacci number is 1, the second is 1  as well, the third is 2. And then 1 and 2 make 3,   and 2 and 3 make 5, and 3 and  5 make 8, and 5 and 8 make 13.  So each is the sum of the previous  two, except for the base cases,   0 and 1, which are just defined as 0 and 1.
Now, growth is slow at the early stages of the   Fibonacci sequence. But as you can see,  the numbers start to grow a little bit   faster when you get around to n is 8. But what  happens if we get all the way out to n is 35?  Well, it turns out that the Fibonacci  sequence grows quite quickly. All the way   up to 9,227,465 is Fibonacci number 35.
So let's look at a tree recursive   way of computing Fibonacci numbers.
Well, define fib to take in n. If n is 0,   return 0. If n is 1, we'll return 1. Those  are two base cases. What's the recursive case?  Well, each Fibonacci number is the sum of the  previous two, which we can write as fib n minus   2 plus fib n minus 1. This is a tree recursive  function because to compute fib, I have to call   fib and fib again. So there's more than one call  to fib in the body of fib. The computational   process of computing a Fibonacci number in this  way evolves into a tree structure. So computing   fib(5), involves computing both fib(3) and fib  (4). Fib(3) involves computing fib(1) and fib(2).   Fib(2) involves computing fib(0) and fib(1).
And these are all base cases, where the   value of the function is returned  directly, without any recursive calls.  Okay. What about computing fib(4)? We're not  done with that yet. That involves computing,   fib(2) and fib(3), each of those has a very  small structured process to compute that.  And this whole diagram is tree-structured.  If you flip it upside down, and you can see   there's a root and then some branches and those  branches have their own smaller branches, etc.  So computing fib (5) actually traverses this  tree-structured computation in the following   way. In order to compute fib(5), we compute  fib(3) first. That's n minus 2. And in order   to compute fib (3), we compute fib(1). That  gives us the number 1. So I put a blue dot   here to say that this is the first return value  that we ever reach when we're computing fib (5).  We then find a return value for  fib(0) and fib(1). And finally,   this call to fib(2) can return. Now we have  the values 1 and 1 that we can sum together   to get 2, and this call to fib(3) returns.
So within fib(5), we now have computed fib n minus   2 or fib(3). But we still have to compute fib(4),  or fib n minus 1, in order to sum those two values   together and finally reach the answer that we  want. And that is another tree-structured process,   where we return from this and this and then we  can finally use those return values in order to   compute fib(2). In order to compute fib(3), we  have to compute fib(1) and fib (0) and fib(1) to   get fib(2), and then using those, we get fib(3).  And now finally, with fib(2) and fib(3) computed,   we can get fib(4) and ultimately, fib(5).
Okay. So I've told you a story about how this   recursive process makes its computations.
Let's see if we can illustrate that   using a program.
So the first thing   I'll do is I'll define fib, just like I told you.
The recursive case returns fib(n-2) plus fib(n-1).   And if we now compute Fibonacci numbers, the  base cases are what we expect. The next one is 1,   the next one is 2, the fifth one is 5. How about  number 8? That's 21. What about 10? That's 55.   What about 20? That's 6000 already. The 30th one  is 832,000. And the 35th one is still computing.   What? It's really working hard. I thought  computers were fast. What's going on? Well,   in the moment, we'll try to illustrate  the computation to try to understand why   it takes so long to compute 9,227,465.
Now, let me just stop and say there are   faster ways of computing Fibonacci numbers.  So it's not that we have to wait that long.   But this particular implementation, with  this particular tree-structured process   for computation, does take a little while.
Okay. What is it doing? Well, let me show   you a function that I've given you as part of  your project. And perhaps you want to use it on   future projects as well. It's called trace.
It's imported from the UCB module, which   I provided with your project. Trace is called  the decorator, you place it with an @ sign just   before the function that you want to define and it  changes the behavior of the function to print out   when it gets called and when it returns so that  we can see exactly what's happening and in what   order as we execute the body of the function.
So now, if I call fib(0), what trace does is it   prints out when fib(0) gets called, and then  when it returns, it shows the return value.  So fib(0) and fib(1), since they reach the base  case immediately, have very simple traces. But   fib(2), involves calling fib(0) and calling  fib(1), which returns 0 and 1 respectively. Those   two are added together. And then fib(2) returns 1.  And this one at the end is the 1 that was always   there. That's the return value of fib 2. If we  call fib(3), we see even more structure. Fib(3)   involves calling fib(1) and fib(2). And calling  fib(2) involves some internal computation as well.  Okay. So now we can call fib(5) and see a  tree-structured process unfold before our eyes. So   calling fib(5) involves calling both fib(3), and  fib(4), each of which has some internal work. So   fib(3) returns 2, fib(4) returns 3 down here. And  by the way, calling fib(4) is quite a bit of work.  So now we can see why calling fib(10) is just a  much bigger process than calling fib(5) because,   within it, we're calling fib(9), which went all  the way up to here, and fib(8), which goes all   the way up to the top. And within fib(8), there's  fib(6), and fib 4, and fib (2), and all of those   have recursive structures within them as well.  And if we call fib(15), all of a sudden, we have   really long lines that are extending off the end  of the page. And we can see that this trace just   goes on forever. And so when we computed fib(35),  well there was just a tremendous amount of work to   do, in order to compute all of these intermediate  values, in order to sum up what we wanted to sum.  Now, let's be clear. This is not an efficient  way to compute Fibonacci numbers in particular,   because there's a great amount of repetition  within this tree recursive computation.  Fib is called on the same arguments multiple  times, and the same values are computed each time.  So in particular, for fib(5), we can see that  the fib(3) computation is repeated twice.  And wouldn't it be nice if we could just do  that once? Remember the value that came out,   and not try to re-compute it. And in fact, we can  speed up this computation dramatically by doing   exactly that. And we'll do it in a few weeks.
So don't think that tree recursive processes   have to be slow. They certainly don't.
But just for the moment, this one is pretty slow.
