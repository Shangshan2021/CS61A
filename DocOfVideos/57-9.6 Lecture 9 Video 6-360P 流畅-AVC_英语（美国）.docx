welcome back at this point we've seen a number of examples of recursion um and i think it's fair to say that it's not immediately obvious why we should care about recursion because the iterative solutions looked at least as simple for most of the examples as the recursive solutions um but in addition to just being this is a powerful way to think about solving problems and computationally it is going to as you're going to see in a minute turn out that there are some really interesting examples where recursion just solves problems so beautifully and so elegantly in a way that would be very difficult iteratively and to show you just one example of that we are going to talk about the game towers of hanoi and if you're not familiar with the game it's a very simple game there are three sticks and there are discs of varying size that form a pyramid or a tower and your job is to move the discs from one peg to another peg and there's a couple of simple rules you can only lift one disk at a time and you can never put a larger disk on top of a smaller disk so that's simple rule and if i'm going to show you a couple of examples but you can go read about towers of hanoi uh but before we get into how to solve this go ahead and watch this video it's a video of me playing a version of towers of annoy with four disks and you'll get a sense of the rules and what i'm doing and then we'll come back and talk about how we solve this recursively one two peg two well there's no hard work here you just simply pick up the disc and you drop it down and the reason you can do that is you can pick up one disc and as long as you're not putting that on top of something that's bigger you're done so the case with one disc is trivial okay i think i've probably stated the obvious at this point let's do the case with two disks your job is to move these two from peg one to peg two well okay pretty obvious to do this the small one obviously can't go here because then the big one wouldn't be able to go there so we've got to move from one to three and at this point now we're sort of done we've cleared the error for one to move two is free so we simply move one uh disk from peg one to pack two and then we move three back to two and then the pyramid or the tower has moved from one to two so two is pretty easy too good let's do three okay now at this point what do we know we know how to move two disks from one peg to another i moved it from one to two right and we know that we move the small one over to here we move number two over here and we do this over here and by the way it doesn't matter which peg so if i wanted to move one two to either two or three it's the same thing if i wanted to move these two to the third peg i would move one to here two to here and then one pops over right so it doesn't really matter what this which the final peg is well okay so if i want to move all three well i already know how to move two so without going through the steps let's just go ahead and move both of those over to here okay using the same technique that we just used on the previous slides and at this point i'm free to move three over to two and again i've got to move two disks from one peg to another but i know how to do that we've already done that we've already shown that you move the small one to the to the spare peg we move the next one to where it wants to go and then you move it back and so i can just do that on mass okay and now you can sort of start to see where i'm going with this i you can think about solving a towers of hanoi with three disks as sort of solving two versions uh with two disks and then just sliding that third disk over and of course we're going to be able to scale that up okay so let's do this now with a little bit of pseudo code and then we'll actually write out the code so let me just formalize what i just said so i'm going to write a function uh hanoi and it takes three parameters how many disks what is the start peg and what is the final peg so this says please take three disks from peg one and move them to peg two okay hanoi three one two now to do that what do i need to do well i know that i need to get one and two off of this number three's uh back here so i need to move one and two over to uh peg three okay well what does that mean well it means i want to solve hanoi with two disks starting at peg one and moving to not peg two of course but to peg three so to solve this problem what i'd like to do is to solve this problem first take two disks from peg one to peg three how do i do that it's recursive don't worry about it right now we'll come back to it and at this point what am i free to do i'm free to move that disk from one to two so let's go ahead and define another function called move which is not which is simply to actually perform an operation so this hanoi as you're going to see in a little bit has to do is going to be the recursion but the move is you're actually moving a disk at this point so now i can move uh uh a disk three from one to two obviously that's from one to two that comes up here now what do i have to do well i've got to take these two disks and move them from three back to two how do i do that well just let's solve another hanoi problem what the start and the stop peg are doesn't really matter to me so now i'm going to solve please move two disks from peg 3 to peg 2. how do i do that it's recursive don't worry about it we'll get that back to that a little bit okay good so let's now start to write out this code in python so i'm sorry i changed the name of the function it's now going to be called solve hanoi it takes three parameters n which is the total number of disks start peg and peg so for example in the last example it was three one two take three uh disks from peg one to peg two okay we're gonna do this recursively obviously uh and so we have to think about the base case and then we have to think about the recursive case although we've sort of seen the recursive case a little bit we've also seen the base case the base case is that if you only have one disk if you're one disk that's a trivial problem just move it um you have to move it from so if n is equal to one just go ahead and move that disk from here to here okay so if n is one then move a disk uh uh uh numbered from numbered one uh and sorry uh from the start peg to the end peg and what does it move to mean to move a disk well i'm not going to go ahead and do all the graphics so for move i'm simply going to print out what is being done what is the move and then you can follow those instructions so i'm going to print move disk i'm going to print out the disk number from this peg to this peg okay so i take these three numbers here and i just print out an instruction that you can then see how this gets done this backslash by the way is just because i've got a line continuity here a line break all right so that's the easy part uh move this disk from here to here okay good let's do the recursive part now so if n is not 1 i have to do what well i've got to get the top discs off my back and i've got to move them to the spare pig peg and then i've got to take that one big disc that's on the bottom move it physically move it onto the end peg and then take those remaining n minus one and then move them back sounds a lot like recursion because solving towers of hanoi with three two one it's all the same right it's the same rules and since that bottom one is the big one i can put anything on top of that so there's no rules against moving anything there so first thing first we have to figure out what the spare peg is so if i want to move from say one to two what's the spare peg three if i want to move from one to three what's the spare peg two so for any start and stop n peg i've got to be able to know what the spare peg is now i could write a conditional i could say if start is one and end is two then spare is three if start is one and end is three then spare is two and so on and so forth or i can use this clever little equation here that says for any given start and end peg the spare peg is six minus the the difference between those first of all first of all let's convince ourselves that that's right and then let's ask why it's right so if start is one and end is two that's six minus one minus two which is three good if start is three and end is one that's four six minus four is two and you can convince yourself for any start n peg this will be true why is this true by the way three plus two plus one of course is six and so if i take the values associated with two of the pegs the one remaining must be six minus whatever these values are so it's a clever little trick to figure out the spare peg from these two all right so now and by the way why do i need to know the spare peg well when i move if i want to move all three from say one to three i have to move two of the disks from one to the spare peg so i'm gonna have to be able to figure what that what that is for any pair of starting end good now let's go back to our recursive code so here's my simple move disk that's an instruction here's my base recursion case and now i'm ready to go so first things first figure out what the spare peg is it's 6 minus start minus end why do i want to know that well because to solve towers of hanoi with three disks from start to end i'm going to solve a simpler problem there is my recursion solve hanoi is solvenoi with n minus 1 disks so that's the top of the thing leaving the bottom one from the start obviously that's where they started to not the end but to the spare so please solve for me take off take these n minus one discs off my back and put them onto the spare how does that happen recursively we'll walk through that in a minute once that's solved trust that it's been solved what do i do well now i've got this one disc sitting on the start and where do i want to move it to the end and i know the end is free because these n minus one are on the spare disk so i'm now going to move the nth disk from start to end good so i solved this i solved this and now what do i want to do i've got n minus one on the spare and i want to move it to where the end peg good so solve that problem solve hanoi n minus 1 from the spare to the end done this is the power and the beauty of recursion it seems like i'm cheating i'm cheating how am i how am i defining the solution of this problem with complex rules by simply saying solve a simpler version of yourself that's the power of recursion now let's convince ourselves that this actually works all right so here's my little code up here remember move disk is just a print statement and for purposes of space i won't print that out here so n equals one base case you can just move the disk if n is greater than one figure out what the spare disk is solve two uh solve two towers of hanoi with n minus one and then move the disk in between all right so let's walk through this and see how it works hanoi three one two i have three disks on peg one please move them from one two two good how do i do that go into the code does the base case hold of course not so what is the spare peg in this case the spare peg is three six minus one minus two so my job is to solve uh sorry i've abbreviated hanoi here and i think i did that for space so hanoi here should be uh the solve hanoi um i just did this because we're gonna run out of space here so uh move three from one to two i need to do three things i need to move hanoi uh two discs from one to three that's the spare so two discs from here to here move the third discs from one to two and then move two disks from what was the spare back to the original and notice that i've written all three of these out here okay because that's these three lines of code and all i've done is fill in uh the values for n and minus one start stop and end now what happens at this point i've made a call to this function that is a recursive call to this function i'm going to expand that out in a second but we can't forget that we have to come back we're going to make this recursive call which is going to lead to some more things but when it's done we have to come back and do this and then do this so that nature of the recursive call is there is a promise to come back here when this is done being executed but if this leads to another call which leads to another call you keep going down and then when you're done you come back and do this it's sort of like the examples we've done with recursion before we build up this expression so here we're not building up an expression but we're building up a series of moves that we promised to get back to okay so let's go ahead and start expanding this out this is a recursive call so let's go ahead and make it so hanoi of 213 says to solve now start all over again right the start is one the end is three so the spare is two your job is to solve a simpler problem one from one to the spare so that means move this disk from here to here and then at that point two is free to move to the end peg so two moves here and then i move one from two to three so these three steps are going to accomplish uh the following i move uh one from one to two that's the current spare i move two over to the end and then i solve hanoi one and i'm not expanding this out because that's eventually going to hit the base case and so i just move it so at this point i've i have now completed this initial recursive call which required another recursive call a move and another recursive call but at this point this function is now done i will evaluate and it is done and now i'm free to move on to the next remembered command from the first call which is to move three from one two two good and now i've sort of got to do it all over again i've got to take these two disks but now from three and move them to there well how do i do that another set of recursive calls move the first disk from three to one move the second disk to the final disk and then move back to there so let's just go ahead and do that so one moves from three to one i'm now free to move that disk so i'm going to move it over and then i do one more recursive call which of course hits the base case and then i am home good so you can see in some ways here i hope the power of this recursion that by thinking about solving this very complex problem with lots of different moves and we'll talk in a second about how many moves there are because we've been doing simple number of cases and i i thought about it as sort of recursively in terms of well what if if i can solve a simpler problem how does that help me solve the bigger problem so this is a very nice example i think i would i would argue that the best iterative solutions won't be nearly so elegant and easy to implement because this is literally the code that you need to do this to solve this problem and that's that's pretty nice now i just mentioned the number of moves and i just want to i want to sort of just talk about this very briefly because it's a it's a little bit of a hint of something that we will be talking about in 206b and is really important when you are thinking about algorithms whether they are recursive or iterative or whatever they are um which is how expensive is this algorithm so how much time is it going to take me to run so let's just think about that little algorithm we just did and there's ways of really formalizing this analysis that i'm going to do but i'm going to do this sort of back of the envelope until we get to 206b if i have one disk how many moves do i have to make well just one i just move a disc from one peg to another if i have two discs how many moves do i how many moves do i have to make well i've got to take one of the discs and put it under the spare peg that's one i've got to then move the base over to the final two and then i move the this this is the one that's on the spare back that's three moves i've had to make okay not too bad what about three discs well for three discs i've got to take two discs and move them onto a spare peg slide one over and then do it again well how much does it cost me to move two disks well three so if i've got to move two disks that cost me three i move one disk over that's four and then i've gotta do another three that's seven so notice for here i sort of did it recursively i didn't have to reanalyze move a disk move it just move a disk i know that two of those disks are going to move over and i know how much it costs me to move to the disks okay well what about with four disks well i've got to solve two versions of towers of hanoi with three disks move three onto the spare slide one over move three back onto the resting spot so that's going to be seven plus seven plus one fifteen what are you noticing here every time i add a disk how many more steps do i have to do double i'm doubling right and plus one so three uh double is six plus one seven double is fourteen plus one thirty thirty plus one uh 64 62 plus one and so on and so forth that's a little scary right because every time i increment by one here i'm doubling my workload well why why is it doubling well think about the recursion the recursion says in order to solve a problem with n disks i've got to solve n minus 1 twice move n minus 1 to the sphere slide 1 over that's the plus 1 move n minus 1. and so this is a very expensive computation so that by the time you get to 64 disks you have a very very expensive computation that you are probably not going to want to do and even with just 12 disks you've gone from only uh from 1 to 12 you've only added 12 but you've gone very rapidly this is called exponential growth and this is very very bad for certain things it's really good if something's expensive if you're trying to protect your password like breaking encryption should be exponential growth but if you're trying to actually solve a problem exponential growth is a real problem obviously so i just love this towers of hanoi for two reasons one is it shows really the power and the beauty of recursion and it also gave me an excuse to show you what exponential growth is which is something we'll be talking about uh down the line much much more and much more formally all right that's it for recursion a couple of things i want to say at the end of all of this um don't don't get too confused i i when i ask you to solve a problem i will tell you if it's iterative recursion and i don't expect you right now to know which is sort of the best i just want you to be able to solve these problems thinking about them a little bit differently but don't feel like just because recursion is weird you have to solve all the problems with that or you should you should avoid them like any design problem you have to think about what is the best most elegant most efficient uh solution and sometimes that will be recursive in nature and sometimes it won't and that's okay good all right so at this point we're now ready to transition to uh object oriented programming so the next three full lectures are going to be classes and objects and we're and at this point we really do have all of the scaffolding we need to be python programmers we have functions we have variables we have looping constructs we have conditionals we have return variables we have parameters we have recursion of course and now we really start now we're going to start thinking about data not just computation but how do we store information and make good use of that data to solve interesting problems in efficient and elegant uh ways and so when we pick it up we're going to start sort of a new chapter if you will of this class which are classes and objects and then for the last two weeks we'll talk about something a little bit different as well 