welcome to the lecture nine q a here we go the question was about what's going on with inverse cascade and would looking at it in python tutor help us understand it i'm guessing not i mean you could try and uh but most recursion problems are best understood by just understanding what the pieces do and how they fit together rather than trying to trace through it because as soon as you make the argument just a little bit bigger then tracing through it becomes yet more complicated and so the goal here this was like a exercise within one of the videos was to create this pattern um it should be the case when your goal is to print a bunch of stuff that the code corresponds to printing parts of it so this call to grow when n is one two three four corresponds to all of that and this call to string corresponds to printing all of that and what do we leave out oh well we need a print watcher before oh and we have a line to do it so um that kind of explains this implementation except for that we don't know what grow and shrink do and they're defined in this kind of complicated way but this complicated way isn't actually that complicated if we try to unpack it so it says grow involves taking in a number which at the beginning would be one two three four i think it's helpful to think about examples and then calls one function and then calls another function f then g checks to see if n is not zero and if so it calls f and then g and then we see what the f and the g are well they're grow and their print and the n that we pass in is not one two three four but instead one two three so uh if i had like rewritten grow without this higher order function business it would have just looked like grow and divided by 10 print and divided by 10. that's what do f and then do means except that these are both uh checking that if it's the case that n divided by 10 and this in python just means if this is not equal to zero that would be a good one to write either one in fact a quirk of python is that the sort of standard style guide says you should leave this part out i think it's fine to leave it in as well uh because it makes it more explicit but in any case this is the grow function that you construct by taking in a number n then calling f and g which checks to see if n divided by 10 is not 0 and if so calls f which is grow and then g which is print in order to do the work so in this alternate definition still works so i guess that's how i would suggest understanding this example is that you're using the power of higher order functions in order to write grow and shrink in a way that is a little bit more succinct by having a function that does the thing that they have in common which is basically like check for a base case call one function on and then call some other function on end but grow involves calling grow first and then printing whereas what would phrase look like well if we look at the definition it says first print dimension that works and then we can get rid of all this stuff it's not doing anything anymore because these are being redefined so let me add a couple things to this uh so i want to re-emphasize that um often when you code and i i still do this to this day i start with sort of maybe a little clunky a little long but very explicit concrete implementation i make sure it works i make sure i understand it so for example if i was doing this i would start with the ladder of these functions where i explicitly define the functions it's a little bit clearer it's a little clunky you can see you need a lot more code and then once you've got that then i can start tightening it up and writing efficient code and doing the lambda expressions and the reverse works when you're trying to understand something you know that a lambda function is just a shortcut for a defined function so rewrite it as the defined function it's often clear because now you're dealing with these sort of dual complexities you've got the lambda expressions the anonymous functions and you've got this new concept of recursion so removing um complexity by just very just unpacking that lambda is a good way to do it i'm also going to re-emphasize that i don't think for a lot of the recursion examples the environment diagrams are the best way to do it i think the better way to do it as john was saying is to look at the code think about the tree diagram of the recursive calls you can sketch these things out i call this i call this i call this i think that's a little bit more compact than trying to track these huge environment diagrams of all the variables and there was one question in the check a chat about how come this is just if n whereas this has a not zero and you could remove this zero is a false value in python meaning that if you say if and then a number if that number is zero then it will not execute the suite of the if statement if it's anything other than zero so this would do the same in python you can actually just put in it doesn't have to be an equality or inequality check you can just put in a value and so they're now asking so there's no base case um great question so where would the base case be you think about that yeah yeah so there's sort of a base case here it's just not explicit yeah so you kind of say nothing to do i think that's the base case is that you just kind of return it would be a fine way to write it but if you wanted to kind of break it out into a base case and recursive case the only action happens in the recursive case and the base case you don't do anything yeah so the base case just says stop so if you have a conditional in there or the results of the conditional i think we've broken it somehow i think you got it backwards it should be if not yeah yeah there it is so if there's no conditional you're probably going to have trouble right so that means it's going to keep recursing recursing recursion you got to have something that says only do this under certain conditions and if that certain condition is not met well then there's nothing to do so you're done now in this case in some of the other base cases like fibonacci we had to do something we had to return zero or one but here there's just nothing to do we're done we just stopped working yeah so there is an implicit base case um and i think this came up in the lecture too is i probably would have written it like this with the explicit base case just so i can see it it was per april's question is i just want to see that it's there so i don't have to infer it yeah yeah i mean the point of this example is not to say this is the right way to define this function because i think it would be much better written like this but the point of this example was to show that it is certainly possible to have sort of implicit base cases where you only define what to do in the recursive case where you could use higher order functions where the base cases like inside this higher order function and it's not here all of the things that we've learned so far in the class can be mixed in with recursion doesn't mean it's a good idea but it's worth knowing that that's possible sure good question so the question was about count partitions which was an example from lecture and what's with the with them and without them and these recursive calls with every pre-recursion problem like this one where you're taking a problem and you're solving it with kind of smaller instances of the same problem i do think it's very important that you understand what you're trying to get done before you start reading the code like reading the code just isn't very helpful unless you know what you're trying to simulate and what we're trying to simulate here is uh if you're going to write the number n as a expression of adding up a bunch of different numbers that are all m or smaller then it turns out there's a way to split that whole group of things that you're counting into two smaller groups okay so in in this case the two smaller groups well let's just fill in the values there um if we started with six four they would now be two four they would be 6 3.
now adding up to the number 2 using positive numbers up to size 4 well you can't really have a 4 in there or you're going to have a sum that's bigger than 2. so this is actually equivalent to just if we had written 2 2 assuming we get our base cases right so basically we're saying if you want to write a sum of size up to six what you should really do is figure out how you sum up to two and why is that relevant well one way to get six is to use a four and then have some other expression that adds up to two and in fact there's like two different ways to do it you could write it that way or you could write it that way but this part is represented by this recursive call where with m describes that what you're really counting is expressions that start with the number m which in this case is four if we're looking at this example so definitely think about an example when you're trying to analyze what one of these does and make sure that you know what you're counting if you're counting or what you're trying to find the maximum of if you're trying to find the biggest thing or whatever and uh in this case we're counting up expressions that look like this and we're using ones that uh have a four i think in the lecture description i said that these need to be in increasing order so let's just put the fours at the end so it doesn't make it even more complicated okay and then what about without it so this says count up all the ways of summing to six with parts up to size three well that's because we're not adding a four and so we have to get all the way to six but we'll do it with parts up to size three and we're not adding four at the end right um and uh so there might be one like that and one like that etc all of these down here are going to be counted by this recursive call if you count up all of these and you count up all of those and you add them together then they get the count of all the ways of getting to six using parts up to size four where you either used a part up to size four or you did so let me add two things here if i may so one is one of the hallmarks of recursion is that you you sort of break the problem down into sub problems and those sub problems tend to be simpler yeah so in this case for example we are looking for all partitions of six with the maximum number is four and there's this really beautiful graphic in the lecture that john showed where he showed you all the possible answers yeah and what you saw is that there's a set of those answers that have a 4 in it yeah so that's the with four recursive call so tell me how to get to six if i'm telling you one of the numbers if the maximum number is four yeah this is it and then look at everything below that there's no four in it yeah so if you if you look at the first two lines here two plus four is six one plus one plus four six those are the only two ways that you can get to six where one of the numbers is four right you can see that of course now everything below that it's as if we had asked to solve a completely different problem well not a completely different problem a different a smaller problem which is how do i get to 6 where the maximum value is 3 and let's agree that since three is less than four that is part of the solution to the first problem so all we've done with the with four and the without four is we've split the solution space here into two sets one that include four one that don't include four and then we do it again so then below there's the solutions that include three and don't include three and then there's the ones that include two and don't include two and notice that we keep simplifying the problem yeah so that's the elegance of recursion is that you sort of you sort of peel off a little bit of the problem that's easy to solve you know it's almost like almost like the base case and then everything else you just do well recursively you just sort of jump off the cliff say that you're going to do it and it happens so that's what those two things are right there if this takes a while to sync it like that is very normal um you know you might get up to this point in the course and think like isn't computer science really about just learning all the rules and then like applying them and maybe looping through stuff but it turns out that computer science is broader than that it's really about solving all kinds of problems using computation and this idea that you could use things you are building in order to build bigger things comes up over and over and over again and it's a different way of thinking and one of the trickiest parts is that you need to relate the code to what in the world you're representing that's where how most like interesting programs work is that you're representing something about the world using your code whether it's numbers or we'll learn about lists on monday or whatever it is you can represent all kinds of stuff in the world using your program but that means that like lines of code have to correspond to stuff that you're trying to represent and it takes a little while to get used to that but you'll get better at it there's a question in the chat that asks do we go all the way down to six two uh sorry to six one or do we stop at six two and you can see here that to get that last line here we have to do six one so we go all the way down to 6 1 and you can also see the base case is that when n is equal to 0 and is less than 0 which means we've gone sideways somewhere and m is 0. so the base case when you stop is either n has gone to zero or m has gone to zero in which case there's nothing to do and so that m equals one does in fact get um partitioned in the recursive call yeah so you go you go from six six four to two four but you also go from six six or six four to six three and that goes to both uh uh three three and five and six two uh it's way too early for this man but the point is like there's all these different options and they both happen each time and so you go from six four to six three to six two to six one to five one to four one to three one to two one to one one to zero one and then you finally like have built this last example but it takes it takes a bunch of recursive calls to even count one of these but you're making so many that you count them all so there's another question here which i like which is could we have done so in your with m example you said well we can't really do 2 4 this is basically 2 2. so could we have done n minus m n minus m for the with m call um yeah that would have worked for this example but not for all examples one thing you could do is you could write i want the minimum of m and n minus m to say like look if if this is getting so small that it's bigger than m why don't we just use that instead but sometimes it's not bigger in 6 6 4 it turned out it was if this was 15 4 then after using 1 4 you'd be at 11 4 but you don't want to make a recursive call on 11 11 because then you're using parts that are bigger than size 4 which is where you wanted to start so this would be a perfectly good alternative version so remember first of all so i think you're asking about the return in the else clause yeah yeah right so we're asking about the return on that size now remember that that return has to be evaluated every single time we call count partitions right there's not just one return here there are multiple multiple multiple returns right so why so let's do the first call to close count partitions what do you do you call competition that's the first line there with the with m there is a promise to come back yeah and do the without and then the return but you can't do that until you finish the with so you go off and you do a bunch of bunch of recursive calls eventually it will hit a base case in return and then you'll do the without it'll do a bunch of recursive calls eventually at a base case in return and then you do a return so there isn't just one return there is the return of everything that is being built up yeah and that's why you get all the outputs not just that last one with the one on one should we do something a little bit fun we could use a decorator to see exactly how it works i was about to ask i think we should use a decorator illustrate what honey just described so uh well let's call it trace so we'll trace a function by creating a new function that takes n and m and it's actually going to get the return value of calling that uh f on n m and then it's gonna print what happened so this is gonna print uh f that's just to get the name count partitions uh and then we had an m and then we had uh m and then we had uh what a return and what did it return result okay i'm sure there's a better way to write this but we've done what we've done uh return g and uh we actually do need to move this up here so that we can use it and i really need to make it a little wider so it doesn't look so weird get my picture out of the way and then we can trace this and then we can try to look at what happens when we call count partitions on six and four it crashes uh i think you've got ah you have to convert yeah well that was a miracle that that ran quite a crash now you got another oh result is an int okay so there are more compact ways to build a big string but we haven't talked to you about them yet so yeah uh oh you've got a return none somewhere oh yeah there it is okay we finally made it okay so here's what happened is that competitions actually returned nine when we called it on six and four so this expression actually came up with nine at the very end why did it come up with nine well it came up with two for this which are these two and it came up with seven for this i didn't list them all out but you saw them in a picture and that seven came from calling competitions on six and three and where did the two come from well long ago we counted called competitions on two and two and that's how we got the two so it added you know that two and that seven together to get this nine how does it keep track of all this stuff well that is the mechanics of the programming language how call expressions work is that they don't return until they have all of the values that they need to compute and uh then can compute the return value and then returns that so this thing is doing a bunch of work in order to find out that with m is two making a bunch of recursive calls after that to figure out that without m is seven and then finally adding two and seven together and returning and these are all the different calls that mix yeah go ahead whether we had recursion or not imagine that with them and without m just called some other function not recursively it would be it would make total sense right with them call some function you get a two back without an m call some function gets a seven back and then we return the sum of those two that's fine right all that's happening here is that in order to get that two and in order to get that seven we're calling ourselves but there's no problem with that because what john just said is that the python interpreter has has state has memory it knows that it has to after the first call return the sum of with them and without them when competition was called on six and three and so it has to go do all the work it needs to get with them recursive non-recursive don't care it has to go through all the work to do to get without m recursive not recursive don't care and then it slams them together and then the beauty here is that okay to get the with them i had to do sort of the subversion of the problem so then i had to solve exactly the same thing but there's no conflict with the original call because that's in a different environment um if you will um and so it's doing its own little thing in its own little environment when it's done it finally pops back out to the other one the next question was how do you get the competitions 0 0 when only one of n or m is being decreased at any given recursive call ah but they're not right so the with m is decreasing n and the without m is decreasing m right which means they're both getting decreased right because in the recursive call so let's do the with m yeah so with that is going to make a call to uh com partitions with a smaller n do we agree on that good that means that the pair of recursive calls for that call will both have a smaller n right don't confuse this second end here and without m with the original n it's now the end from the recursive call which is smaller yeah and then with that makes another recursive call decrementing and even again and then it goes down so that you have to remember that those end variables are with with respect to the recursive call not the original call which in which case of course it would always be the same but that's not the case i see yeah okay yeah that makes sense now good so just to finish this up i had a little bit more trace which says what happens when things get called and you know first we call it on six four and that calls it on two two and that calls it on zero zero and then finally something gets returned so you can see that like in the recursive call n is now two and m is now two and so it counts competitions on zero and zero in the second time around and so we see that call and that call is a base case and so we find there's one way to um compute two using parts up to size two where you actually use a two which is just two okay so if this example is extremely confusing and it's understandable because of the tree recursion so what i would suggest is go back to to one of the examples that doesn't have tree recursion that just does a simple like the the factorial yeah and make sure that you really understand that how every time you make the recursive call you're reinstantiating the local variables and the parameters and once you've really got your handle on that then the tree recurrence the trigger pins are a little tricky because you got to sort of build out these trees by the way the absolute right way to follow these recursions is not the environment diagram by drawing the tree right so sit at the root make a call to count partition with n m before you do anything put the promise for the three things for the two things you have to do i have to make a call here i have to make a call here okay what does this one have to do i have to do two calls two calls two calls and you'll see the diagram and then you should be able to trace the order as john did in the lecture yeah keep in mind that the environment diagram is going to have as many frames as we have calls here so it's going to be just absurdly large right and that's why the tree diagram is a little bit easier to see it's just just you're not lugging around all that extra stuff and i would also say that this trace while it's interesting to kind of watch what's happening tends not to be that useful for writing the program or understanding how the program works you really have to think abstractly about what's in here like what are these going to do what are you going to get back and what happens when you add them together the next question was could you explain why you added min n minus n m earlier on in this q a so the question is about the min function in the with m you don't actually need that um the reason we put that in there is in this particular example with six four the first call um uh would be to f uh four what was it uh let me see if i can get this right uh a two four in which case there's there's there's you don't need the second term to be larger than the first term and so i i'm pretty sure if you run like this everything will run just fine it'll just hit the base case yeah um so we just put that min in there because it sort of doubt with the with the case when m the second number is greater than the first number which of course doesn't make sense because you can't get to two using a four it doesn't do any harm you just it's just sort of unnecessary but this is something that's very problem specific like it's the the fact that you can't build up a number using a sum using parts that are bigger than that sum is basically why that man is there it's not something that's like a general fact about recreating recursive functions in general or something like that it was very probable specific the next question was what would count partitions 2-4 do so let's think about a little bit and we'll run it um 2 4 says how do you make two out of sums and there are two ways you could have just two or you could have one plus one so this should return two and fingers crossed that's what it returns so it's finding one way to do it with a two which is just two it's finding one way to do it without a two which is one plus one that's the recursive call uh two one and then it counts both of those so now the question is what would happen if john changed compartitions to four to two two same answer right so what's going on here well yes the second argument was 4 but you can't use a 4 to get to a 2.
so it ignores it and i can't use a 3 to get to a 2. so i ignore it um so and the the last number can't be greater than the first number and that's what the min there was therefore is just to sort of make that explicit but it doesn't harm to do it it just you won't be able to get to it all right any other questions i want to re-emphasize something that was said is don't don't get frustrated at the recursion it takes time it's it's it's one of these it's a little weird it's not like the the loops which are really straightforward the conditionals and all that it takes a little time you have to sort of think a little bit different by the way back in the day we used to start by teaching recursion the first day of class john and i were just talking about this the other day if we don't teach you about iteration we don't do anything we just teach you recursion in some ways that's excruciatingly painful but it also in some ways is easier because you don't have this sort of iterative construct to think about i think we're doing it the right way bringing it downstream a little bit but it's okay these will take a little bit of time to get your head around how these things are working well yeah a lot of people used to drop after lecture two and this was a lecture two example instead of a lecture nine example but still in this course we teach this much earlier than most other universities um i think it's a great way to get used to the idea of functional abstraction and to see the kind of problem-solving power of just writing simple functions and letting the computer do the work for you but it's not easy at all all right we'll be back to answer your questions at 2 10 p.m if you want to join for the unrecorded ask us anything session then see you soon i thought you were going to say unhinged but okay unrecorded is fine also might be on thanks everybody see you this afternoon 