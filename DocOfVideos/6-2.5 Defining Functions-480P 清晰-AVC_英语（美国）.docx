defining functions. one of the most important  things you will do in this class. before I talk   about the details of defining functions let's  just take a moment to appreciate this moment. so I   told you on the first day that this course is all  about abstraction and today we're learning tools   for abstraction. so assignment is a simple means of  abstraction because you can bind names to values   and of course abstraction is the process of taking  something complex, giving it a name, and treating   it as a whole without worrying about all of its  details. so function definition is a more powerful   means of abstraction because you'll be binding  a name not just to a simple value but to a whole   expression or statement or a series of statements  something that truly is complex, we give it a name   and treat it as a whole without worrying about  its details. so the functions will define today   are very simple but they'll get more complicated  soon. the way we define a function is with the   def statement which looks like this. so this is a generic version. you write def -- that's a key word in   Python. then you give the function a name and you  list its formal parameters which are going to be   names that refer to the argument values passed  into the function. then a colon, indent the next   line, and write the body of the function which in  the simplest case is just return and then a return   expression that gets evaluated every time the  function is called. this top line between the def   and the colon is called the function signature and  its most important role is that it tells you   how many arguments a function takes by listing out  the formal parameters, each of which will get bound   to an argument value. we'll see exactly how that  works in a minute. and then the function body is   everything that's indented after the first line  and that defines what the function does.  so in its simplest form is just a return keyword  followed by a return expression. and an expression   describes a computational process which will get  evaluated every time the function is called   so this def statement is a two line statement that  defines a new function there is a procedure for   evaluating a def statement. so here's the execution  procedure: first thing is that every time there's a   def statement we create a new function and that  function has the signature given on the first line   the second thing is that we set the body of  that function, which is the code that actually   gets executed, to be everything indented after  the first line. finally we bind the name given   to the function to that new function we created  in the current frame of our environment. remember   those frames? will be talking a lot about  those. okay so here's the execution procedure   for def statements. it's always the same. the most  important piece is here: number two says that we   set the body of the function to be everything  indented after the first line. it does not say   that we actually execute that body. so that means  when the def statement is executed for def square   x return mul x x, no multiplying actually happens.  the body just gets squirreled away as part of the   function without actually getting executed until  the function is called. (squirreled means to hide   in a safe place. it's also the longest word in  the English language that has only one syllable) squirreled. okay, I liked squirreled. now  functions are only useful because we can call them   so in addition to having an execution procedure  for a def statement that creates the function   we also have a procedure for evaluating a call  expression that uses a user-defined function   so here's the procedure for calling or applying  a user-defined function. we add a local frame   forming a new environment. we bind the function's  formal parameters to its arguments in that frame   and finally we execute the body of the function  in that new environment. let's see that in action   before I confuse you any more. ok: from operator  import mul define square x to be returned mul   x x and then we'll square -2. so we have  a def statement and then we have a call expression   that uses our user-defined function. the first  thing that happens is that we bind mul to the   built-in function, then we define square which  does all three things I said: it creates a new   function where the signature is the one that  I wrote down in the def statement, it squirrels away the body of that function as part of the  function that we created. so we don't show it in the environment diagram but it's there. every time  we call this function we're going to execute that   body but we haven't multiplied anything together  yet. we haven't executed the body yet. because the   next line to execute will finally be the call  expression that actually uses this thing. but we   did bind the name square to the function that we  created in the current environment. that's part of   what happens when you def square x. okay, finally,  we're going to square -2. so we evaluate   square - that is that function. we evaluate -2 is -2, and then we apply this   function to the argument value -2, which  means we follow the next three-step procedure   which is: introduce a new frame, bind the formal  parameters to the argument values in that new   frame, and then execute the body of the function  in this new environment, where x means -2,  square still means the square function and mul  still means multiply. so the next line to execute   will be the return statement of this function. when  we execute that we find that the return value of   the function is 4 which is what happens when you  multiply negative 2 and negative 2. and then we're   done. back to the slides. what exactly happened  there? so here's a screenshot of exactly what   you just saw and I'm just going to annotate some  parts that are important. so we have a built-in   function we have a user-defined function. they look  basically the same except for in the user-defined   function we actually see the formal parameter x  because we're going to need to use it. we have a   local frame that was introduced in the first  step of the procedure above. the original name   of the function is used to label that local frame  just so we can keep track. this label isn't really   that important. what is important is that we have  a binding between the formal parameter x, which   is the name of the argument, to the value of the  argument. the argument value is -2 and   then we also show return values in these frames  just so we can see what happened in the process   of evaluating this function. so the return value is  4. this is not the standard name-value binding this   is just an annotation in the environment diagram  that tells us what happened. ok that's everything   in the picture. now I mentioned that a function  signature is important. it's important because it   contains all of the information needed to create  this local frame that we've built right here. so   the signatures between the def and the colon in  the def statement first line, we copy it over here   when we create the function because the square  here lets us name the local frame and the x is   the name that we bind to the argument value of the  function. so that's why the function signature is   important as it tells us how to construct this  frame every time we call square. ok we now know   most of the story for user-defined functions but  there's one more big piece and that's looking up   names in environments. so every expression that  we evaluate is evaluated in the context of an   environment. why is that? environments are the  memory that keeps track of the correspondence   between names and values so the environment knows  what names meet. the current environment so far is   really just either one global frame, or now that  we have user-defined functions, it could be a local   frame followed by the global frame. so these are  the only two possibilities so far: a one frame   environment or a two frame environment. notice the  word 'followed' indicates that there's an order here   so here's the two most important things I will  say all day: (1) an environment is a sequence   of frames. a frame is a binding between names and  values - one of the boxes in the environment diagram   an environment is a sequence of these it could  be the local frame followed by the global frame   a name, when evaluated, evaluates to the value  bound to that name in the earliest frame of the   current environment in which that name found.  so if an environment consists of a sequence of   frames and I want to look up what does the name  mean in that environment, I check each frame in   turn. for example, to look up some name in the  body of the square function we look for that   name in the local frame first. if it's there we  know its value; otherwise, then we look for it in   the global frame because that's the next frame in  the environment. and built-in names like max are in   the global frame too even if we don't show them.  we just don't show them because we want to keep   our environment diagrams simple. okay I'll start  a Python. I'll define a first I'm going to from   operator import mul I can multiply stuff. I'm now  going to define the square function. I already used   x so why don't I use something else like square  returns the multiplication of square and square.
what have I done? I've used the name square  so square refers to some function called   square where squaring has a formal parameter  square. so what happens when I actually try to   square something? well it works just fine. why  did that work? let's take a look. okay so here   is from operator import mul def square square  return mul square square, -2. visualize   the first line's okay. the second line defines a  function called square with formal parameter square.
nothing has been multiplied yet so no  disasters have occurred. when I actually call   the square function I look up this function  I name it the local frame square and then I   bind the argument -2 to the name square  which is the formal parameter. then I return mul   square square. well, mul is mul. the important  thing is that square in this environment means   something different than it used to. now it  means -2 because the first thing I   do is I look up square here and I found it so I  never actually look up square in the global frame 