Lists contain other values, their values that  represent collections of other values. And   when you have one value that contains  another, you might ask the question,   does an element appear in a list? There are actually built-in operators   for testing whether an element appears in a  compound value such as a container. So let's   say I have digits, which is 1, 8, 2, and 8.  I can ask is 1 in digits? Python will return   true. So in is an operator that evaluates both  1 and digits, and then determines whether one   appears in digits. 8 is in digits. The fact  that it's in there twice doesn't matter. It's   in there. 5 is not in digits. So if I said 5  in digits, I'd get false. But since I said,   five not in digits, this is another operator  that's equivalent to saying not (5 in digits).  Let's look at a few other examples. So here's  digits. 1 in digits is true. 5 n digits is   false. Now, it has to be the value. Since  one doesn't equal 1, if I say one in digits,   the string one is not there, only the integer.
Also, we're looking for an individual element.   If I say, is the sequence [1, 8] in digits? It says false. But there it is 1 and 8.  That's not what the in operator does.  It doesn't look for sub sequences.  Instead, it looks for individual elements.
If I had said, is [1, 2] in the nested list that   contains 1 and 2? That would be true because there  it is right there as an element of this list.  But if it's nested too deeply,  then it's not there anymore.  So this is a simple operator that  doesn't search through a structure   trying to find anything that matches.
Instead, it just goes element by element   and sees whether it's equal to the  element that you're looking for.
