And we're going to do one more example. And  that might have to do a couple of drills,   I'm gonna have you write both an iterative and  recursive. So you can see how to think about these   two things simultaneously. Alright, here's the  first one I want us to work on. I would like us   to write a recursive function, mysum, that takes  as input a list of numbers and sums them all up,   and gives me the sum. Here's a nice drill. If  you want to do one, just do this iteratively.   Almost everything we do recursively will  have an iterative component, and vice versa.   They may be a little bit easier, they may be a  little bit harder, and or they may be the same.   So if you want to take a break, go ahead and  do that and write this. It's a good exercise.   So the first thing first, and look, this is always  true no matter when you're writing code, but more   so when you're writing recursive code, you got  to really think about what is it that you want   to do. So think about the recursive definition.  Two parts. Base case and then the recursive case.   So what's the base case here? I can think of two  possible. One is I give you a list with only a   single element in it. What is the sum of all the  elements of that list? Just that one element.   What's the other base case? Yeah, just like  before, if the list is empty. Let's do that   one. That way, we'll go ahead and deal with the  empty list. Well, now you got to ask the question,   what is my sum of the empty list? I think it's  reasonable to return 0. We can say the sum of all   of those elements is 0. So let's just go ahead and  write the base case. If the list is equal to the   empty list, so square brackets, square brackets.  I could have also said if the length of the list   is equal to 0, that would have tested for the  empty list as well. Return. Do not, do not, do   not forget that you are returning values. Because  recursively, you are building up an expression,   as we saw with both factorial and with string  reversal. So be really, really careful here.   All right, recursive. What's the recursive  definition? What does it mean to sum up 2,   4, 1, and 5? Well, one way to think about it  is the sum of all of these elements is 2 plus,   or whatever the sum of the rest of the list  is. So I can just peel off that first element,   hold on to it and add it to mysum of 4, 1, 5.  Yeah, that sounds about right. And by the way,   that sounds a lot like factorial, right? N  factorial is n times whatever the answer is for   everything else. So here, instead of decrementing  a value, I'm just taking one element off the list,   and then summing everything else. And that's  sort of like what we did with reversal.   We took one element off the list, we put it to the  end, and then we reversed everything else upfront.   Same thing here. Alright, so what I'm going to  do is I'm going to peel off that first element,   and then I'm going to add that to the  recursive call of everything else. Okay,   that should be pretty straightforward. So  if L is the empty list, return 0, else:   grab the 0 with element and add it to everything  else recursively called with mysum. So began the   one colon operator says starting at position  one, which is the second element in the list,   up until the end, grab that list, call mysum  recursively, and then this will eventually return   4 plus 5 plus 1, which is 10. And it'll add  that to 2 and I'll have my answer. And again,   that return there is important. You are building  an expression. You have to return something   to the previous function call, whether it's  recursive or whoever called you from the outside.  Alright, let's make sure we understand how  this works. So let's walk through an example   with this list with four elements. Mysum of  2, 4, 1, 5. Alright, let's go into the code.   List isn't empty. So peel off the first element  and add it to the recursive call of everything   else. So that's 2 plus mysum of 4, 1, 5. Okay,  am I done? No. I want to add two things but that   is a function call. So I eventually have to go  call some function and get an answer. And then I   can return. All right, what's mysum of 4, 1, 5? Come into here, that's not empty. Peel off the   first element, make a recursive call with  the next two element, 4 plus mysum of 1,   5. Am I done yet? No, I still need this.  Peel off the first element, recursive call,   peel off the first element, recursive call. Aha!  You can see we're getting there, by the way. Now,   this little guy is done. Why? Because it hits  the base case. And notice the base case doesn't   have to do any work. It hits the 0. So now, 5 plus  mysum of the empty lists says please return 0 to   mysum of the empty list. Now I have an expression  5. And now I have the answer to mysum of 5.   So I can pop that up to mysum of 5. Now I have  an answer to my sum of 1, 5, it's 6. Now I have   an answer to mysum of 4, 1, 5. It is 10. And  now finally, I have an answer, which is 12.  Good. All right. Let's do a drill. I'm going to  give you two back to back. So the first one is   write an iterative function that takes as input  an integer n, just a number, positive integer,   and returns the sum of the first end integer. So  sum(5), for example, return 1 plus 2 plus 3 plus 4   plus 5. So this looks a lot like factorial. So do  that, please, iteratively. While loop, for loop,   I don't care how you do it. And then when you're  done with that, please do exactly the same thing,   but do it recursively. So two drills back to  back. Go ahead and pause the video. Take some   time to do those two. I think the iterative, you  should be able to do very quickly. And then again,   think about the nature of the recursive  call, base case, recursive call,   and then come back. And we'll  do both solutions to this.   Alright, I hope you got the answer to both  of those. So let me show you my solution. The   iterative one, so sum_itter, I'm going to just  distinguish between the two types of functions,   takes us input n. And again, I'm not going  to check whether n is a positive integer,   we won't worry about that. I'm going  to initialize a variable to be some,   sorry. I'm gonna initialize a variable called sum  to be 0. And then I'm going to iterate between   the value 0 and n. And notice here, this is an  off by one error that may have bit some of you.   if I want to use a for-loop, iterating between  0 and I have to go from 0 to n plus 1 because   this last value is non-inclusive. So the value  of i inside the body of the for-loop will take   on the value 0, 1, 2, 3, 4, up until n. What do  I want to do with those? I want to sum them up.   So I'm going to say, sum is equal to the previous  sum plus i. Notice, by the way, unlike factorial   where we initialize the factorial to be 1 because  we were computing products, and 1 is the identity   for product. In sum, of course, we have to  initialize at 0. So running sum, each iteration,   we add 0, 1, 2, 3, 4, 5. And then eventually, we  return some at the very end here, and relatively   straightforward. Now, you may have done some  while-loop, perfectly fine. I would argue the for   is probably cleaner, because if you're counting  integers from 0 to some number, there's no reason   for you to do it with a while-loop. There's  no reason for you to initialize a variable,   do the condition and then increment the variable.  Let Python do the hard work for you. So I would   argue probably the for version of this is a little  tighter and a little neater, because it fits very   nicely into what exactly range designs for you.
Okay, let's do now the recursive definition. Base   case is easy. If n is zero, return zero, right?  So if I asked you to sum the first 0 numbers,   I'm done. There's nothing to do. Good. So that's  easy. So what's the recursive definition? Well,   let's see. The sum of n is, let's start from this  side, 5 plus 4 plus 3 plus 2 plus 1. So surely,   we can agree that that's 5 plus the recursion  of 4. And 4 is 4 plus the recursive call of 3.   It's exactly like factorial, it's just that  we're summing instead of multiplying. Okay, good.  So let's see what that recursive call looks like.  So if n is not 0, I'm going to take the number n,   and I'm going to add it, not multiply,  to a recursive call of n minus one.   And eventually, so I'll make a recursive call  here, I'll keep building up the expression. So   it'll be n plus n minus 1, plus n minus 2, all  the way down until we hit the 0, the base case.  Okay, good. I hope you got that. By the way,  some of you may be getting errors in Python or   Jupyter Notebook saying recursion length exceeded.  That's because it's sort of like an infinite loop.   You keep going recursive, recursive, recursive  calls, and it's not catching your base case.   It's sort of the equivalent iteration of that  you're not stopping the loop. And that just means   something's wrong with your logic, or you have  a little bit of bug in your code. So if you're   seeing this stack overflow, or cube blown out  or recursion limit exceeded, something is wrong   with the stopping condition on your code.
All right. Now at this point, we've seen   a number of examples of recursive calls. And I'll  be the first one to admit that they're relatively   straightforward. And there's no obvious benefit  to doing something recursively over iterative.  And the last example I'm going to show you, I  want to show you the power, really, the true   power and beauty of recursion. And we are going  to solve a fairly complex problem recursively   and you're going to see how truly elegant  recursion can be when it's done very, very well.  