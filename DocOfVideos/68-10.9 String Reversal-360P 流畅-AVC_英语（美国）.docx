Okay, let's pick up where we left off. And  we're going to talk a little bit more about   recursion. And you may remember that we  wrote an iterative algorithm for reversing   a string to reverse ward to draw or draw to ward.  So how did that work? We took the first letter   and the last letter and we swapped them. And  then we incremented one, decremented one, swap,   and kept going until we got to the midway point.  It was an iterative algorithm. We had either a   while or for-loop that would work its way from the  first letter to the midway point of the string,   swapping, swapping, swapping, swapping. Perfectly  fine way to swap. And I just want to think about   this, how we would do this recursively.
So what does it mean to recursively   reverse a string? Well, as you saw with the  factorial, typically what it means is that you   keep simplifying the problem until you get to a  base case. So what does a base case look like in   reversing a string? What's the easiest possible  thing? Well, a string with only one letter is   trivial to reverse. It's that letter. Or maybe  the empty string is a trivial base case. So that's   always good to think about when you think  recursive. Like, what's the simple case here?   And then your job recursively is to take a problem  that is big, reverse a string with n letters in   it, and figure out how to break that down into a  simple operation with a slightly simpler version   of it, say, reversing n minus one character.
So let's just think about that.   So what does it mean to reverse a string?  So we had been thinking about this as   I swapped the "w" and the "d", and then the  "a", and the "r". But the other way to think   about this is I can just take that "w" and put  it all the way at the end, and then reverse the   rest of the string. Yeah, that sounds about right.
So let's see if that makes sense. So can we agree   that the reverse of the string ward is the  reverse of everything but the first letter   string concatenated with the first letter? Sure.  Let's just do this in our head. If I reverse this,   it's "dra". And then I attach a "w" to  it. And that's, of course, the reversal.   So notice what I've done here? I've simplified  the problem by one letter. And I've done that   by thinking about the nature of what reverses  by just saying if I just take that first letter   and put it at the end, and then I'll worry about  the rest of the string later, that's a recursive   definition. Because notice, I've defined the  reversing of an entire string as the reversing   of a slightly smaller string, plus a simple  operation. Looks a lot like the factorial, right?   N factorial was n times n minus one factorial.
Alright, let's just do it again to make sure we   see how we reverse now "ard". It's the same game.  Take that "a", shove it to the end. Now, not the   end here, of course. The end of this, and then  reverse "rd" at the front of that. So the reversal   of "ard" is the reversal of rd plus "a". Now  eventually, so notice what's happening, this thing   has to evaluate to this. This will eventually  give me an answer when I work my way down the   recursion. I'll shove it in there, it should be  "dra". I attach a "w" to it, and then I'm done.  Okay. What's the reversal of "rda"? Now we know  what the game is. Take that first letter, shove   it to the end, and then reverse a single letter.  Ah, this looks like the base case I mentioned. If   I have a single letter, reversal is trivial. There  is no work to be done. There's no computation,   it's just the letter. So let's agree that  the reversal of "d" is just "d". Base case,   no recursive call. This is like 0  factorial is 1. No work to be done.  Alright, now what you have to do, notice  what we've done? We build up an expression   with a series of string concatenations. And now  we've just got to work our way back up this stack   in order to create the final answer. So let's  start at the bottom, of course. What is reverse   of "d"? It is "d". And so reverse of "rd" is just  the string concatenation of "dnr". Okay, that's   easy. I know how to do that. Now, there's no  recursive call here. There's no work to be done,   just do the string concatenation. So the reversal  of "rd" is "dr". And I'm going to concatenate that   with "a". Good. Let's do that. "d" plus "r" plus  "a". Reversal of "ard" is "dra". So we pop that   back up one. And now we have the reversal of  "ward" is "draw". And again, we've done that.   And notice, it's really a different algorithm  in this case, right? So instead of swapping,   swapping swapping, I'm building up an expression  of string concatenation by one at a time   peeling off one letter. And that's what I meant  when I said at the beginning of the previous   lecture, that recursion, you have to think really  quite differently about the nature of computation   and, I think, in a very elegant way.
All right, now let's do it in Python.  Reverse is a function that  takes as input a string s.  Base case, if the length of the list is 1, then  return s. There's nothing to do. I sent you in the   letter "d", the reversal of "d" is "d". Go home.  You're done. Otherwise, what am I going to do? I   want to peel off that first letter and put it at  the end and string concatenate the reversal of the   rest of the list. So remember that -- a string  rather. Remember that strings can be indexed   like lists. Here's where it's very convenient.  So s sub 0 is the first element of the list. And   you may not have seen this notation before,  but this one colon operator is shorthand for   everything from the first character, the  character in the first position of the string,   so that second letter, to the end of the list. So  I could have also done one colon, length of s, but   this is a simpler notation that Python gives  you, that just has one colon, and then you leave   a blank here. And that just give me everything,  but the 0 with element. Yeah. And that's perfect.   Because now I'm going to take, let's say,  what comes in as board. I take the w,   that's s sub 0, I take "ard". And I take "ard"  and I shove it back into a recursive call   of reverse. Okay, what does that do? That peels  off of the first letter. And notice again,   this is where it's really important to understand  these local variables, the first s coming in was   "ward". But when I make a recursive call, the  new s is "ard". And then the next time it's "rd",   and then the next time it's "d". And then this  expression, the string concatenation holds on to   the memory of all those different instantiations  of the local variable to the function reverse.  Last thing is, there's another base case, I just  want to show you what it looks like because it's   equally fine, which is you could have had the base  case be the empty list. And it would have worked   just fine, you would eventually hit the empty  list. I don't think this is really necessary   because a list with a single character is  in fact, the reversal in itself. The only   reason you might want to do this is if somebody  passes you an empty list. It'd be nice not to   choke on it. And so this is nice because  it deals with an empty list problem.
Okay. That is the second recursive example that  we've done. And I hope you now see that not only   is the code look different, but you have to think  differently about the problem. And I really liked   that. It forces you to sort of think about the  nature of computation in a really fundamental   