here's the 61a lecture 10 q a yeah the question is about what does it mean to escape a character so typically when you put something in in quotes for example every character is processed or interpreted by python when you put a backslash the not the division one the other one um essentially what python does is it takes the next character and bundles it up with that backslash so backslash t as john is writing on the screen right now is a tab so it doesn't treat it as two characters backslash t it's one character so the escaping of a character means you're essentially creating a special symbol uh there's a tab there's a new line and there's a number of other of these as well so here's a good example that john is showing you the length of hello there oh by the way when you print hello there notice that you get that nice tab it's replacing slash t that's escaped out and then the length of that list is the length of hello which is five the length of there that is five and then one more which is the tab this works really well john when you're you're keeping up with the highlighting nicely and then the length of the tab which is one character not two characters so uh so a new line or a line break is so if john writes a hello backslash and there then when you print that while the length of that is still 11 of course when you print it you just have a new line um in the in the print you know so it's the same thing that backslash and is one character and it's a new line or a line break and it counts as one character the next question was what is slicing for a string or a list and this topic was lightly covered in today's lecture but will be covered in more depth on friday yeah so this is called slicing whereas this is called item selection slicing is when you have a colon somewhere within the square brackets but both of these occur after another expression and this expression has to give you some kind of container like a list or strings behaved in the same way and then this part tells you how to get parts of this item selection will give you an individual element of whatever this is and a slice will give you some subsequence we talk about this in like some amount of detail in friday's lecture but uh slipped it in here just to give you an idea of how it works um this says starting at index one and going up to but not including index three counting upwards so that would go one two and then we're done because we hit three get all the elements of s and put them into a string so uh element zero is h element one is e element two is l so that's why you got this e and that l in the result if we make a list well let's use different numbers um selecting an element of a list will give you just an individual number in this case because this is a list full of numbers it doesn't give you back a list full of six that's a different thing so six and six are different things and this syntax this item selection which we've used a lot in this lecture just gives you one element slicing actually gives you back a new list with some of the elements but not all so if i go from 1 to 3 of t this is element zero so we're going to skip that get element one and element two and it will put it into a new list um it turns out that it's so common to go from the beginning of the list up to a point that if you leave out the first index then it just starts at zero and it's so common to go from somewhere to the end that if you leave out the second index then it just goes to the end of the string which would be equivalent to saying one to the length of t um and in fact you could leave out both of them though you would just kind of get uh equivalent list back so there are reasons to do that that we'll talk about later in the course but uh but so far like if you leave out the first and the end then you don't get a subsequence you just get the whole thing so you can think about that the slicing is just you know we did the range in for loops it's basically specifying a range of values and you are grabbing that range of values from either a string or a list um and the the bug that will bite you over and over again is that that last element in the slice range is not inclusive you go from the first element in the slice one up to one minus not including the last one and that will bite you over and over and over again it still bites me so just be warned yeah so if you say i want the six seven eight okay that starts at index one and goes up to index three and you try to go from one to three you won't have the eight that is the that's the bug you want to look at by the way there's a good reason for that um because indices because indexing starts on zero when we say zero to the length of the list the length of the list is the index of that is one more than the last element so that turns out to be pretty convenient that i can just say zero to the length of the list but when you're sort of manually doing these things you got by the way this is a classic problem in computer science we call it the off by one error um often you're off in the in the beginning or in the end by one it bites everybody over and over again uh uh somebody's asking in the chat does t colin create a new list or modify the original list um it it i'm not exactly sure i understand the question but i think what you're asking is if i assign something to t colon um what happens uh yeah so let's just try it and then we'll talk about what's going on if i say u equals t and then i slice all the way from the beginning to the end what do i get it turns out you have two lists that contain the same values five six seven and eight why does it matter that they're different well as soon as we start changing the contents of lists which we'll do uh next week i think this will matter so far it doesn't really matter at all to your life and in fact if you do project two just using what we've taught you so far um this distinction won't matter at all but it will start to matter quite a bit when we get to project three and and stuff starts changing so um yeah so this is an important distinction eventually uh not quite yet the next question was whether you could use negative numbers in a slice and if so what do they mean good excellent question uh the answer is yes do you want to do an example john yeah so actually slicing is very flexible but you don't need to know every detail for this course like we'll focus on just counting up but here are some convenient things is that for selecting an element you can actually put in a negative number and that will count from the end instead of from the beginning so negative 1 means the last element and negative 2 means the second to last element and this fact about using negative indices also applies to slicing so if i wanted to slice from element 1 which is here up to but not including the last element i could write that and get the six seven eight um and this would be equivalent to writing that so um yeah i i guess that's the story with using indices that are negative is that they count from the end there's also a way to count backwards um and this like definitely won't show up anywhere in the course except for it did show up in the first lecture so maybe we'll talk about it there um i i did some demo of reversing strings and it turns out that once you've decided where you're going to start and where you're going to end you can decide how to go from one element to the next and normally you would go by adding one but you could instead go by subtracting one and then you end up working backwards so like a less confusing version of this would be if i want to go from the beginning all the way to the end and include the last element but i want every other element then i could add a 2 there and it would give me the 5 and the 7 and the 9.
this says i want to start at the last element when i go up 2 but not including element 1 which is 6 um to get from nine to whatever's next i subtract one instead of adding one so yeah that's the full flexibility of the slice notation is that you're allowed to have negative numbers here and there to describe things counting from the end and you're allowed to have either positive or negative numbers here to tell you how to advance through the list so you can think about the the list and the string is not living on a line but on a circle yeah and so when you get to the end like the next element is the first element so if you just think about it on a circle then the negative sort of makes a little bit more sense i think it's a little weird indexing a negative one but it turns out to actually be convenient algorithmically sometimes when you want to move through the list good question so the question is for a range i said it wasn't a list so what is it if it's not a list and the answer is it's a range uh so it's its own thing um you can tell it's not a list because it certainly doesn't look like a list you could even ask python what is this thing and we'll say oh it's a range which is different than what you get when you build a list where the type of that is a list the reason it's different is mostly because you can represent a range very compactly just by memorizing where it starts and where it is then whenever you wanted you could compute stuff in the middle which means that i could create a very long list if i mean a very long range if i wanted to and you know python hasn't really done any work yet it's just remembered that here's the beginning and here's the end and if i want to know how long it is well that's obvious i just like subtract the beginning from the end and i know how long it is now if i actually wanted to compute some particular value then python's going to do some like clever tricks behind the seats if i want the thousands value then it will just add the number 1000 to the number three in order to find out that the result is 1003 and it didn't kind of count up from three to four to five to six to seven to eight it just performed addition on the other hand if i ever try to take all of the elements in this and put them into a list uh python will crash because lists are represented explicitly like all the values are allocated in memory and uh you have to have enough memory for all however many there were elements and my computer apparently does not maybe i should upgrade but the point is that the list is kind of less flexible in the sense that it can't represent such a huge range but much more flexible and that list could represent kind of any arbitrary collection of values whereas ranges have to be some sequential order you can think of it as sort of a symbolic representation the list is explicit right you've literally stuck all these values in there and they are there in memory somewhere the range is sort of symbolic it's sort of the promise when you go to ask for the values i'll be able to figure out what they are and you can see why that's so much more efficient it's going to do everything on the fly only as needed yeah great question so the question was about how do you concatenate lists with plus how do you repeat lists with the times operator like what's going on there um so maybe we'll just review those examples and talk about them a little bit um so if i have three four five and i have uh eight nine ten and i add those this doesn't do any addition instead in computer science this is called overloading an operator so that means it does multiple things and it does something special in the case that this is a list and this is a list which is to build a longer list that has all the elements of s followed by all the elements of t and you can still use this operator kind of like you would addition with numbers like you could take the result of this and add something else to it and then you get an even longer list and here we see we've added in t twice well actually we have all the elements of s and all the elements of t and then all the elements of t again um python designers decided like oh if you could add t and t together that's kind of like multiplying t by 2.
so it turns out that if you have a list and you multiply it by an integer you end up with the elements of that list some number of times and like do you need to know this well um i guess we taught it to you so now you know it and you might as well know it um it actually does show up on occasion in um in real programs and uh yeah not often i find it sort of offensive as somebody who's trained in applied mathematics because when i see that t or s i think of it as a vector and when i see a two times up front that should be a vector multiplications on matlab for example which is a numerical programming environment two times a vector or a list is you literally do p point wise multiplication so i think this is a little weird but let me just mention one thing that john said is that the plus operator and the time dot is overloaded and you've now seen three operations that can be done numeric adding integers or floating point values strings you can do string concatenation using the addition operator and now on lists as well this is one odd thing about python not being a strongly typed language is that you know if you just see a line of code that says you know s plus t you may not know what s and t are you don't know if the plus is numeric uh edition string concatenation or list concatenation so that's sort of a quirky little aspect of these non-typed languages or explicitly type languages so yeah good question so there are two parts to this question one was about the structure of list comprehensions and how they work and one was about what is meant by a literal and does something need to be a literal to be part of a list comprehension the term literal is actually just describing um cases in which you build something by just writing out its contents in the code as opposed to building it out programmatically through iteration or something like that so a string literal is when you build a string just by writing quote and then the contents of the string and then end quote and a list literal is when you build a list by just typing out its elements inside of square brackets that's what the term literal means and uh there are other ways you could build this same string like i could build it out of uh h e and llo and this was not constructed through a string literal instead this was constructed through a compound expression that had two little string literals in it and an addition operator and likewise you could do the same thing um here so um a list comprehension is a way of building up a new list from the elements of some other container so i could build up a list of uh x plus one where i need to come up with what what are the values that i'm going to add one to and then x gives you a name for each element and the result is x plus one for every element in well something and here i could write any expression so it doesn't have to be a literal it could be anything uh but it does have to have elements so i could write a list literal to do it at which point i would have bound x to 3 computed x plus 1 is 4 and put that into the result or i could have used a name if i already had 345 in a name i could have written x plus 1 for x in t and t actually isn't a literal it's a name it's like a variable name referring to some list that already exists so in that sense there's no restrictions on what expression you put here there is a restriction on the value of that expression which is that it has to be something that you can iterate over so if i just put 5 in here i'll get an error because it's going to try to assign x to every element in 5 but 5 isn't a container it doesn't have any elements and so that's what this means int object is not iterable the int object is referring to the 5 and it's not something that you can have as the value of this expression um yeah that's that's really the only uh restriction you can put any expression you want here there's no restriction on that here you just put names so this is not a place where you would put larger expressions but instead it's just saying here's the name i'm going to use to refer to an element in whatever's here and then here you can put any expression you want as long as it evaluates to something that you can iterate over and let me state the obvious here that i mean this is just a shortcut you could have written explicitly your own for loop to do this right you could have said four acts in the list create a new list where every element of that list is one plus the element in the previous list so just this is just shorthand because it's sort of a common thing that we do on lists but it's you know you could have written out the for loop all by all by yourself the python creator side this is such a common thing let's make it a little bit easy to do yeah that's exactly right it's also wonderful for bug prevention because there's no like manipulating of some list that might already exist or whatever you just like say oh here's something that exists and then all in one go you just build something new yeah so the question is what's a container what does that mean and are there other containers as well so we try to give you some examples like a range is also a container it's not a list but it's got a bunch of elements in it you can iterate over those elements you can figure out whether some element is in there so um if i have r which is a range from three to six and then i have s which is three four and five for the rest of the code it actually kind of doesn't matter that this is a range and this is a list i write the same thing either way i can say 4 and r just like in say 4 and s i can get the element at index 1.
come on the element at index one of r just like i can get the element of index one at s so when we use the term container in this course we're describing things that can be manipulated in this way using item selection using this in operator to figure out whether something's in there and it doesn't actually matter whether something's a list or a range or pretty soon we'll talk about something else called the tuple we'll talk about something on wednesday called the dictionary and all of these are kind of just ways of containing values so i guess that's the short answer is that a container isn't like something that is a particular type but instead it describes all the types that can be used in for loops used within use with element selection and in python the technical term for these uh varies a little bit depending on exactly which of these operations you can use um but the most common term is that these are iterable values meaning you can kind of uh iterate through them using a four state and you know i just want to sort of re-emphasize the power of abstraction here the fact that these things are implemented behind the scenes differently from your perspective you don't really care um and now you make here computationally and for other reasons but from the from the programmatic point of view you index you slice you do everything exactly the same that's nice that's nice that you don't have to have a different syntax for everything that'd be sort of a drag oh there was a follow-up question of this which is uh is a string a container yeah strings strings are a lot like lists they don't behave exactly the same but the best way to think about it is that it's a container of the letters that are in the string the quirky thing about strings is that when you have a string and you get an element out of it you get a string back and you could get an element out of that and you get an element out of that and like lists typically don't work this way so so strings are a little bit different than everything else but yes there's still a container yeah i think i understand the question so let me try to rephrase it so you're asking i can compute n factorial as n times n minus one times n minus two all the way down to one i can write that expression out or i can write it as 1 times 2 times 3 up to n and you're asking is there one that is preferred over the other um i'd have to think through all that i don't see a reason why first of all let's agree that the answer is exactly the same the order in which you do the multiplication or if we were doing something else with addition absolutely doesn't matter so numerically mathematically there's no difference computation i don't believe there's a difference um john do you see a difference between the order in which you go um for factorial it really kind of doesn't matter what order you go in yeah but for other problems it can so and in particular this homework problem called ping pong it's easy to figure out what the next number is if you know where you are it's hard to know like what the previous number was that's more complicated whereas with factorial you know counting up is no harder easier than counting down but let me just show you what factorial would look like if you were counting up and using recursion and then you know how to do it so first of all the version where you count down has this um nice property which is that you kind of know when you're done just by this special value zero when you're counting up that's not really true you have to know where you are and you have to know whether you're done so for this reason if you're computing a factorial kind of working your way up then you have to know where you are um so you have to know that you're going we're computing the factorial of n and right now you're at k and if it happens to be that n equals k well then you've kind of hit the end right so in this case you could return in but otherwise you would want to return well maybe we'll just do k you'd want to return k times the result of calling fact helper on n and k plus 1.
so now we're kind of counting up with k but this has the wrong signature this says uh compute the factorial of n starting at k so what does this actually do this computes k times k plus 1 times k plus 2 all the way up to n okay i should have called this n in the first case it doesn't matter because k or n they're the same so um if that's what this does then the definition of factorial is actually not this anymore but it's call return the result of calling fact helper on n starting at the number one and then we can compute factorial 4 is 1 times 2 times 3 times 4.
so that's one way to do it there's actually a third way to count up and accumulate as you go that i think we should talk about just so you know the full flexibility of what you could do with recursion is you could say um that this computes this result by accumulating the result in result well it's too much where we add in a third argument the result and if we hit the end meaning we've reached the end then we need to put and put this final k into the result but the result has everything else multiplied into it already and what this will do is call fact helper on n on k plus 1 and multiply k into whatever the result was so far let me make sure this works and then i will try to describe what just happened oh good it does so what this says is call factorial helper we're going to compute the factorial of n k is going to start at 1 and then we're going to work our way up and the result the whole factorial is going to start at 1 because we haven't multiplied anything into it yet then if we kind of reach the end then we need to multiply the k in but then we're done um otherwise we're going to make the result bigger and pass that bigger thing into the recursive call so that k gets multiplied in there this is really just to keep track of where we are and this is to um know when when we're done and in fact we can get the same result if we really wanted to be fancy by saying if k is bigger than n then we've multiplied in everything that's one more way to compute factorial so um yeah i guess the the ping pong example from homework kind of pushes you to explore some of these different ways in which you can track the result it's not always the case that you want to compute the result of the recursive call and then multiply something into it maybe you could just multiply in first since multiplication is commutative it doesn't really matter how you do it you can get the same result either way with factorial but in other problems sometimes it's hard to do it one way and it's easier to do another and by the way this is a lot like assignment statements like you said n equal to four k equal to one result equal to one uh you know it's like while k is less than or equal to n we're going to uh not change in but we are going to increment k and we're going to say result equals k times result so like this version looks an awful lot like uh setting k to one setting result to one while uh k less than or equal to n or maybe we'll make it as explicit as possible well not k greater than n which is the expression that we wrote there then we could uh reassign k and result to k plus 1 and k times result and then eventually return the result like that's uh this recursive version is basically this code just uh avoiding assignment statements by using uh function calls instead i'll add one last thing although it's i don't think it's particularly important to this class is that the order of operation can matter numerically when for example you're dealing with very very large numbers or very very small numbers the order in which you do things can create numerical instability so for example if you multiply a whole bunch of small numbers together at the very beginning you'll get these nasty little rounding artifacts so sometimes you have to think about that in these very complex numeric things for what we're doing here it won't really matter that's a good question so i think the question is the difference between a helper function and a mutual recurrence so let's look at what john has on the screen right here so this is not an example of mutual recursion this is just recursion and the only thing that the helper function is doing is sort of hiding the fact that the recursive call needs three parameters whereas the the sort of the signature of calling factorial only requires one parameter i mean for example we could have just said look if you want to call recursive factorial you have to initialize it with a one and a one for these other things but that's that's not nice to the user and so we want to sort of hide that implementation detail and so we create this sort of this this facade a little bit right call fact with n and then all that's going to do is call another function which itself is recursive right so if you look at the recursive call down here in fact helper i'm using my mouse to point to the screen by the way which doesn't work it turns out um thank you john then that is itself recursive yeah a mutually recursive was i forgot the example i think it was the credit card example where one function calls another function which and that function calls the previous function so a fact helper for some reason called fact then that would be mutually recursive this is just recursive with a little bit of sugar coating on top to hide the implementation details now that's exactly right and and this is unrelated but also might be relevant because it's a source of confusion sometimes instead of defining a new function and writing fact helper and passing in the initial values which i think is fine practice sometimes what you'll see is that people will provide default values for this and then call this thing fact and get rid of this entirely uh now this will still work will not work uh because we called this okay uh this will still work and what's going on here is that these numbers one and one only matter when you call fact with one argument as soon as you make a recursive call we're passing in two different arguments which means ignore the default values and use these values instead um and and therefore we've got a function that kind of works uh this is okay but the old version was better because the old version said you know this is what you call and you only have to pass in one argument and you don't even have to think about what k and result are those are like deep buried and some helper functions that you should never call so i i kind of like this version oh sorry i i agree with god i like that version too and also the other version where there's the default parameters the user could mistakenly call fact four was you know two and three and now you're off to the races so you don't even you don't even open the door to the to the ability to miscall the core function of facts i i do like this even though it does require a little bit more code the next question was what's a helper function a great question so this term helper function is used to describe a function that isn't really useful on its own instead it's part of the implementation of another function and whether something is a helper or not is really kind of up to interpretation so in your hog project i think i would have described uh take turn as a helper function for the play function meaning it's something that helps you implement the play function uh by describing some piece of logic within it but then again take turn is kind of useful on its own because we did some various like analysis of like which number of dice gives you the highest turn score so in that sense it wasn't really just a helper function it was useful for other stuff too so that's the kind of matter of interpretation part but in general what it means the reason i called this fact helper and described it as a helper function is that the only reason i wrote it was to help implement fact in fact was the main event and this was just uh there to help it along yeah that's how i would define it too the way i think about these things is there's sort of an inward facing and an outward facing functionality right we create a library of mathematical routines for computing sine cosine factorial tangent square root and all those things and i want users to be able to call those functions in order for me to be able to implement those i may need to do some gnarly mathematical operations the user doesn't need to know about those so those i'm going to call auxiliary or helper functions that are sort of hidden away they're for the internal workings but the external you know what are the functions that are being called that's the fact yeah yeah that's a great question so like when would you use recursion instead of iteration if there's a straightforward iterative approach then it's usually the right thing to use the only obvious advantage of recursion is that if you're trying to track how many times something happens or um uh you want to somehow set it up such that in every iteration like some other side effect happens like something gets written to a log or something like that then it can be convenient to do it recursively because then you can just decorate the function and every time it gets called like that information is uh captured somewhere so you know that's the main advantage of doing something recursively that you could do iteratively but that's a pretty thin advantage so most of the time you just want to write things iteratively if you can now the tree recursion examples that we've talked about really are quite a bit simpler if you write them recursively rather than iteratively if you want to write them iteratively then you kind of have to keep track of where you are and the computation in a way that the interpreter will do for you if you just write pre-recursion so this is like competitions or the towers of hanoi example those are cases where i think the recursive version is often just preferred because it's so much simpler yeah the only thing i would add to that is i've definitely stumbled upon a few problems in my life where just the iterative ones were just a bear to implement and the recursive ones were just so sort of elegant and beautiful but for the most part i think i think john's right is that the iterative ones are probably the way to go in terms of efficiency and ease of implementation the question was do you want to put the helper function inside the body of the main function or afterwards yeah you could have done it either way you could have made that a local function uh that um uh that had scope only within the fact yeah there were actually like there was a related question in chats maybe i can answer them both the question is like uh why is this its own function as opposed to being defined within fact and do you always need a helper function when do you know whether you need a helper function or not um and recursion in particular the way to know that you need a helper function is that you want to track more things than you have arguments for so if you want to track n and k and the result then you need n and k and result in the signature and if they're not there then you need to write a helper function should this be in here instead uh there is a tiny tiny tiny little advantage maybe not that tiny which is that we don't need to track in in this case so our code got a little simpler when we wrote it as an inner function that would be one motivation to do it this way um because this end never changed and it could always refer to that you have to get rid of it you have to get rid of that n2 right there yeah get rid of that um the other advantage of this is that no one could ever call fact helper because it's not available anymore so that's another reason that sometimes people write inner functions this is like extremely common in javascript for some reason is that like all functions are hidden within other functions just as a way of making sure that the wrong person doesn't ever call them um and it shows up every once in a while in a python code base though i think uh more rarely yeah so yeah so that's basically the story it's like if you're gonna share names then it can be convenient but also it hides hides the helper function so that no one calls the next note that's what i would have done i would have embedded in there maybe if i i don't want anybody else calling it i don't want it polluting the name space and so i i would i would have left it out but i mean they 