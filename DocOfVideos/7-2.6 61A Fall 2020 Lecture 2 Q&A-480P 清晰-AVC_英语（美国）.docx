okay um all right yeah welcome to the first q a session so raise your hand and we'll start taking questions yeah great question so the question is about what is a frame that came up in lecture and what does it mean and kind of what's the point of those frames are like a memory where the computer or the interpreter is keeping track of what names mean so it's up to you in the course of the program what names are assigned to what values is x 12 or is x 14 and the frame is there just keep track of that now in different frames the same name can mean different things and that is one of the key things to learn here is that when you're executing code that's inside the body of a function x might mean one thing and then outside the body of that function x might mean something else so let me show you kind of the simplest example of that and you can let me know if that answers your question so if we say something like x equals 12 and then we define a function of y which sets x equal to 3.
and this prints out x and then after we call this on seven we print out x we have two lines that are identical print(x) but they'll print different things we assign x to 12 in the global frame we create a function that function hasn't been called yet so we don't have any additional frames yet the additional frame comes when we call f regardless of what we call it on we're going to create a new frame an f frame so a frame is one of these boxes and here y is associated with seven or bound to seven but the assignment statement x equals three will bind x to three in the current frame which is this local frame so when we print x here it prints out three now we're done executing the body of f it's time to print out x again but when you finish executing the body you return back to the frame you were in before so now we're back in the global frame where x equals 12 if we print x in this context x is 12.
so the whole point is that in different contexts different name or the same name might mean different things and frames are the mechanism by which this is tracked inside the python interpreter if you know how that works then you can write code that takes advantage of it so you can have x mean one thing inside of f and a different thing outside of it let me add one more thing too is is if imagine a world where this was not true so what you should know about coding is we tend to reuse the same variable names like we use x and y a lot we use i j and k a lot we use f a lot and imagine a world where that wasn't true you would run out of variable names very fast first of all and imagine now you've got thousands of lines of code and somebody wrote one function and somebody else wrote another function and they used x and you used x but you don't know that they used it well then there'd be no way of keeping track of variables um and you'd constantly be colliding somebody's asking is a frame called the scope and the and the answer is yes you can think about that you you have the scope of evaluation where are you evaluating this it's within the frame that you see up on on the screen right now and and there's right now there's only two frames there's a global frame and then the function call frame eventually you'll see that there can be they can be nested a little bit deeper when you call a function a frame comes out local variables are evaluated within that when you exit the function that is done you are done with those variables you return back to the global frame by the way that means that the global frame is very powerful because any variable in that global frame has only one name right so there's only one x in the global variable yeah i'm sorry in the global frame and so we'll talk probably later on about global variables that they are considered to be dangerous when you have a lot of code because they start to annihilate each other yeah sorry i'm going to try to keep track of some of the chat questions um just to follow up on this and then we'll move on i'd say like the beauty of this design is that uh let's say i want to print x y and z anything that's defined here or inside here isn't going to be affected by stuff outside so you can kind of just stare at this function to decide what's going to happen with x once you see that x is defined within here you kind of don't care what it was before and that means you can sort of focus on on what you care about at the same time anything that's not defined within here can still be accessed so i'll show you that since the global frame has an x and a z if i've used x in here then the global x doesn't matter anymore but the global z does matter because i didn't come up with a local z uh there's no z inside this frame and so i am able to print x and y and z oh i shouldn't have used seven twice but uh we got this three this seven and this seven by accessing values that were in both the current frame and the global frame so they're both accessible uh in computer science terminology you could say that all of x y and z are in scope meaning they're in the current frame or they're in the global frame but knowing where they are means you know what to look up right so so you look up x by first looking in the local frame and then looking at the global As you program more you'll see this is quite a nice design in terms of letting you just focus on the names that you introduced and not worrying about anything else unless you really want to refer to something in the global frame and then you can we forgot to repeat the next question so here it is the question was what do you do if you want the local x to be the same as the global x good so if you wanted to use x that global x you would simply if you just if john delete thank you john if he deletes that line then what happens when you call print x y inside of f so the way it works it says what is x well is it defined locally and it starts in the local frame it says has the function f defined x for me uh yes great use it no well go up one frame is it in the global frame yes great use it if it's not what happens what do you think happens if if john deletes x equals 12 up there and i said print x y z what do you think would happen that's exactly right so it's not the local frame it's not in the global frame i have no idea what x is we're done right so it starts where the frame currently is that's the function looks for the variable and somebody asked this in the chat room is why doesn't it use the 12 and that's because there's an order there is a precedence for the evaluation of the frames though i think in this case maybe you're trying to do something different maybe you want that global x but you want to do something new to it and that's fine but then you have to give it a new name so you could say a equals x what this is going to do is create a name in the current frame which has the same value as the global x so it will be 12 and then you could do something with it you could say b is a plus one and then you could print out a and b so this is a common pattern for using something that's global but you don't want to change the thing that's global you just want to access it so here we access it by referring to it we don't have to define it as anything we just refer to it yeah and now we have our own copy we have a different name for it a but it's the same value as x was in the global frame and so we could do something with that yeah good question the question is what about environment diagrams like how much should you know about them i think it really is important to know what they mean and so knowing what all the arrows mean and all the names mean and what parent means which we haven't covered yet but we will next week is something you should learn in this class because you need to be able to predict exactly what even a complicated program will do and what happens with students is that for simple programs you can always just kind of look at it and say like oh this adds one to things it's very simple you don't need an environment diagram but as soon as something gets complicated with functions calling other functions which are calling other functions keeping track of that becomes kind of beyond the capacity of something that you can just do by staring at it and so you make wrong predictions about what the program's going to do that is a hindrance to being a programmer so environment diagrams are a precise and correct way of describing what happens inside of a program that's why we teach them they are generated just by looking at the innards of the python interpreter and and displaying them to you so this is like exactly what's going on inside the python interpreter and um yeah and you need to understand all of the mechanics if you want to predict the behavior of a python program so in that sense you have to know all the details now what about exams well actually yes on exams we used to just have people draw environment diagrams and now in the online world that doesn't work quite as well usually what we do is draw an environment diagram and ask you which piece of code would have generated this and you still have to know the same thing like maybe you won't get tripped up by drawing your arrows with the wrong thickness like that's not an issue anymore but that was never really an issue. what is an issue is understanding what all the names and arrows and values mean and why they're there so that you can understand how that corresponds to the execution of code the next question was do built-in functions like min and max create frames as well or do only user-defined functions create frames when you call them yeah good question um with built-in functions like min and max we don't really care how they work in order to be effective programmers now you might care you might be very interested and i'll tell you yes there is the same notion of a frame but we don't draw it because we're just trying to use abstraction min is something that takes them in, who cares how it does, it so we don't have to think about what the mechanics are we don't have to keep track of the frames so in these environment diagrams we only draw the frames for user-defined functions because those are the ones that we define and therefore we have to understand how they work so yeah the short answer to the question is we only draw frames for user-defined functions but they do exist we just don't draw them for the built-in functions yeah but you're absolutely right sandra there's the same thing is happening if i had written my own min function it would have a frame and have the local variables but as john said once you go down that road the environment diagrams get really complicated because that function may call another function and so anything that's built into python you just assume it does the right thing and we don't worry about mapping all that out yeah the next question was could there be more than one local frame at any moment so like things happen in an order at any moment there is a current frame. what happens if one function calls another function? now we're in a different local frame but that old one still exists we're gonna return to it when we're done but there's still kind of only one current one so let me show you just like a quick example of that. if we define f of x equals the result of calling g on x plus one and then adding two to that and what's g anyway well g is a function of y that returns y plus three let's say okay so now we call f on seven we have two different functions right now we still only have the global frame we get one new local frame when we call f. in order for f to return it needs to call g so we can't return until we know what we're returning and that involves calling g on x plus one so we call g on eight when you call g on eight you create a new frame with its formal parameter y bound to the argument eight now this is the local frame i would call this the current frame and these are both local frames but there's only one that we're using right now we're using this one for g and we're going to keep using it until g returns so we add 8 and 3 together to get 11.
when you return you return back to whatever you were doing before so now we're done with the g frame but we have to go back into the f frame in order to finish what we were doing which is that we were trying to return but we didn't know what g of x plus 1 was well now we do it's 11. so we can add two to that now we're in a different current local frame and we're ready to return from that and then we're done okay so somehow we're going to try to print the result of squaring four and in lecture it turns out this actually works now you would never write code like this no the fact that it works is kind of interesting so uh in the environment diagram you enter here um and the question was kind of something about this so i'll listen to the question and then we'll keep going yeah great question so in the question is in lecture i said that square has a new frame in this environment what's an environment is it just a frame or is it something else well here's where things get tricky is that an environment which is all the names that you can refer to is actually a sequence of frames each box here is a frame but all the names that you can refer to are not just here they're in a sequence of frames that starts here and then goes to its parent which is the global frame so actually the current environment includes both of these frames but in an order with the square frame coming first and the global frame coming next the reason we call this whole thing an environment is that it contains all the names to which we can refer and we do care about the order because when you look up what a name means for example if it's time to  mul(square, square) we have to look up the name mul which we look first here but there's no mul here so then we look in the global frame. we find it's the function that multiplies okay so we're going to multiply but we can't multiply until we know what we're going to multiply and now we need to figure out what square means so then we look here first and we find square so we use the number four without ever looking in the global frame so the environment is the whole sequence of first f1 and then the global frame these are two different frames and the reason they're they're all part of the environment is that you could refer to names in all of them but you can only refer to this square you can't refer to that square because that square is shadowed by this square and so we actually do multiply 4 and 4 together to get 16 and that's what gets printed out. let me emphasize you should never ever ever ever write code like this i mean it's a good pedagogical uh example because it sort of makes you really force you to think but this is not something you would do.
you can get away with it but you really want to pick clever and meaningful variable names and function names so that the user doesn't have to rack their brains trying to figure out what your code is doing yeah a student wanted clarification about whether order was important yeah so that's what we were saying earlier with the x's if you have a local variable x and a global variable x you start in the local frame is it there yes great use it if it's not push up into the global frame if it's there use it if not you have an error and John was distinguishing between the whole environment and the frames that are embedded within that environment.
the next question was whether a frame is created when you call a function or when you define a function the local frame is created when you call the function the function definition is just: hey, here's a promise that when you call this thing i will do this line of code but it's not until you actually call the function that the frame gets created the variables get instantiated and you start executing. that's right, so the function is defined by this whole two lines  of def and then whatever and that whole thing is kind of like one big statement. it all happens at once and now square exists you can see this is stepping through how many steps are in this program. well there was one step to import mul there's one step just to define square. it happens all at once even though it's two lines, and then there's one step to print twelve and you can see we never created a local frame because we never called square the next question was about printing strings which was covered in the supplementary videos that are linked from piazza that come from professor Farid's other course 206a these are not necessarily in scope for 61a but will be eventually so you could learn about it now or you can wait and learn about it later but anyway here's the answer to that question about printing strings and combining strings yeah so i think he's asking John: that versus print hello number comma two yeah right so that statement is printing one chunk of data right it's hello number space and then converting two to a string and then the hello number comma two you can see does exactly the same thing because when you comma-delimit your data then it just prints them with spaces in between them so you can get the same result in two ways so in my version the reason i do that example by the way is i want you to start thinking about data types that when you combine certain data types you have to be careful sometimes like you know numbers can't be added to strings but you absolutely can just comma delimit everything and get the same effective result so the other thing john could have done here is he just said print hello number comma end equals quote quote which means don't put a new line and then on the next line print two yeah so there's a couple of ways so that would have essentially that would have been thank you john and then print two so what that does is the first print statement uh prints on the line but then it doesn't bring you down to the next line and then the next number comes in uh right there ah and he just doesn't have a space after number which is why.
so the question is about this slide and what's going on with a and how come it ends up being two which is a great question here there's a case where python could have been different you could have imagined that what happens is like it figures out what b is and then it figures out what a is or something like that but that's not how the language works and you can't program effectively unless you know exactly how it works so this is just a rule you need to memorize and the rule is that when you see an assignment statement you actually evaluate everything to the right of equals before any of the names change. so that means you add one and two together to get three and you figure out that b is two so the two values you're gonna assign are three and two before you ever start changing b and a and then once you have the three and the two you assign those to b and a respectively which means a comes out to two and b comes out to three you're right that it could have been different but it's not and so you can introduce bugs in your program by not knowing this fact about multiple assignment statements and that's true melissa also of a single assignment statement if i say b is equal to a plus b i look at the right hand side of that assignment operator i evaluate it i get a value and then i shove that into the variable and if you have multiple ones you do everything on the right hand side and then you shove everything into the variable yeah great question: so is print kind of when you call print does the same process happen as if you were calling something else like min meaning do you first evaluate these operand expressions and then call the function or is there a different story and the answer is that it's the same in fact python doesn't even really know that print is special until after it gets called and it's not called until these two things happen so if you get the min of two plus three and a versus the print two plus three and a the story is very similar what happens first is that you figure out you're going to print you're gonna print whatever print does on five and whatever a equals two here we don't have an a but we could put one in and then you call print on 5 and 12. so print doesn't actually know that it's printing 2 plus 3 it only knows that it's printing 5.
and it doesn't know that it's printing a it only knows that it's printing 12. now the behavior is different right so when you print you get print output whereas if you compute the min of something you don't really get any output you just compute a value and as you rightly pointed out---call this result one and this result two--- the result of printing is that you can't really do anything after you print. that print output appears but the value that you get back is none so there's nothing really you can do next whereas with a function like min you get a return value and so you could do something else with that. so it wouldn't make sense to write res1 plus seven and try to print that out because res1 is just none you'll get an error this would give you an error but you could use res2 in order to do something so um you know that's the big difference between print versus most other functions is that print's point is to do something: to print output as opposed to give you back a value with which you could do something else later like min gives you back the value five at which point you could do something with it like add it to 7 to get 12.
so the question is does um do do all functions by default return none and the answer is yes if you don't put a return statement just like a print statement it doesn't have an explicit return it has the side effect that it shoves something onto your screen um but the default is none um that something does get returned if you don't and i think you can see it on the screen right now so it's as if there's a there's an implicit return none at the end of every function unless you replace that with return whatever you want to return yeah great question so the question is in this function value what is being stored like what is there and the best way to think about it is that it's all the code of the function so the body of the function along with information about where that function was defined so we'll talk about why this is important. it's important for scope.
this is kind of the topic for next wednesday's lecture but there's really two pieces so it's just the code plus where that function was defined because that basically tells you what other names are in scope or available when you're executing that code yeah great question so the question is in the python interpreter why is it the case that you don't have to print 24 you could just type 24 and it displays it for you this is a convenience. it is not how all python programs are run instead it's only true of this: what's called the interactive python interpreter another more formal name for this is a read eval print loop basically this lets you figure out what expressions evaluate to without having to go to the trouble of printing them all the time and the rule is that if you write an expression it will evaluate it and display the value unless that value is none in which case it doesn't display it. so there's this one edge case where if the value is none then it doesn't show you none it just kind of doesn't show you anything at all this is different from writing in a file so if you write a python program where the contents is just 24 and you run that you will not see the 24. so the fact that it displays automatically is unique to this interactive interpreter and it's not true of python programs that are stored in files.
so the interactive python interpreter automatically displays the value of the whole expression that you type in so if you type in two plus three plus four it will show you nine it doesn't show you everything that happened along the way so if i uh put a 12 in here and i returned 5 and then what i did was print f of 3 it displays 5 which is the result of calling f f really did compute the number 12 but did nothing to it, so it's just kind of lost it really did return the number 5 which is what we got displayed but if i evaluate f of 3 plus 1 i don't see that 5 anymore i only see the result of the whole thing so that's the rule of this interactive python interpreter is that it evaluates this whole expression and shows you its one value it doesn't show you everything intermediate along the way if you want to see intermediate stuff along the way then you have to explicitly print it out if i print this out and i say z is five and i print out z and i then return z and now i call g of three plus one i'm gonna see the twelve i'm gonna see the five and i'm gonna see the six. the six is the value of this whole thing good question so so the question is if you call a function and what happens? the slide says you create a new local frame and that creates a new environment creating a new frame is not different from creating a new environment every time you create a new frame that means you have a new environment that starts with that frame okay so if we call f(4) and we call g(6) let me just give some vocabulary we've created a function another function no frames yet. here in order to assign y to something we have to call f on four so we look up what f is and we create a new frame for that by creating a new frame we have also created a new environment the frame has x the environment has x and f and g in it. you could refer to any of these.
plus min and max and whatever else is in the global frame that we don't normally show here we're done with this frame and now we go back to where we were because that's what return does. it says: go back to where you were we assign y to the return value which is five and then we create a new local frame which means a new environment so every local frame is the start of an environment that starts with that frame and has some other frames in it too. so far in this course the only kinds of environments we've ever seen are a local frame followed by the global frame or just the global frame below the question is what does it mean to make a new environment? that means just to make a new frame and that new frame is the first thing in a sequence of that frame followed by the global frame. yeah good question so the question is can you access a local variable in the global frame and the answer is no there's no way. oh sorry we never called f we should do that then it's more interesting. f on seven so x is bound to seven but when we leave that local frame and return back into the global frame there's no way to access that x. it's gone and so we got this error x is not defined but the way in which you move stuff from the local frame into the global frame is by returning it, and then now this expression, which is a global expression, has the value of the local x. you then have to decide what to do with that: give it a global name and then you have access to it. so here's how you move local stuff to the global frame, is you first return it then you give it a name in the global frame and now you can refer to it in the global frame. that's a good way to think about it: is when you're passing parameters you're shoving things into that local frame by passing them as parameters you also have access to all the global variables up top and when you want something out you have to explicitly send it out with the return statement because everything that's done in that body gets annihilated when the function is done evaluating.
you know great question. so the question is what non-pure functions exist that aren't just print there are really two different kinds that you'll see in this course: ones that display things like print but in like real programs they also do other stuff like you know actually making your printer work or making an internet connection to some other computer or something like that so they're doing some kind of external communication. the second kind that we'll see later are functions that change something about the current environment or some other environment so not only do they compute a value but they also change some value somewhere else in the program.
If there's some representation of a rectangle they change it to make it bigger.
i haven't told you how to do that yet that will come actually not for a few weeks basically everything that happens in the early part of this class is based on pure functions that their only job is to return a value print is a notable exception but we'll get into the the later part of the course when we talk about values and objects where one function will end up changing something about some other value somewhere else. the next question was could you ever have a non-pure function that returns something other than none? yeah great question. you could write a non-pure function that also returns something other than none like it could print x and return 2.
because this prints it is a non-pure function but it also has a return value so what makes something non-pure is not that it doesn't return or it only returns none what makes it non-pure is that it does more than just return something it also for example prints or changes something or something like that.
a good question so: do environment diagrams get more complicated than the one on the screen? yes. they certainly do most of that complication comes from topics next week when we talk about higher order functions on wednesday and their environment diagrams on friday there are actually only so many rules that you have to learn. you have to learn how assignment statements work.
we talked about that for today's lecture.
you have to learn about how higher order functions work, which if you don't know what that is, that's fine. that's for next week.
and you have to know how return works.
but there aren't that many rules and uh you know a longer program just uses the same rules over and over again it is important that you know all the rules otherwise it's hard to be an effective programmer if you can't learn all the details of some part of something and then use them to get something done um but the the fact that it looks daunting now is probably because there are some pieces you know and some pieces you don't know and once you know them all life becomes better so uh in general students perform very well on these um kind of environment diagram based questions because they learn the rules. now they don't always learn it for midterm 1 because sometimes they just haven't done it yet, but by the time i ask the same questions on midterm 2 and the final everyone seems to get them right who's been really focusing so all you really have to do is listen to lecture, go to discussion and when you think of something that's like: oh i don't know exactly how that works, then you have to go and you have to try it and and if you still don't understand how it works then you have to ask a question.
but there just aren't that many rules you could learn them all and then you're kind of guaranteed to get it right.
a good question so the question is about environment diagrams and why is it the case that some names are bound via an arrow to some value and some things are bound via just putting the number right there? so in particular here we don't have y with an arrow to a two, we just put the two right there and here we have z with an arrow to this other thing you know a good way to think about it is this is just a shorthand the really important thing about the meaning of this environment diagram is that you might have multiple names for the same thing, and we'll find out later in the course that if this thing can change, it's important to know whether you have two names for the same thing or whether you uh just have two names for two equal values.
so it actually doesn't matter whether you have uh two names for the number two or uh you have two different number two's.
there's really only just one number two but it really does matter whether you have two names for the same function or whether you have two different functions.
why does that matter we haven't gone over that yet and it won't be relevant for several weeks, but but it does eventually matter that there's like two different functions here we created one every time we had a def statement and this assignment doesn't create a new function it just gives another name to the same function yeah, so that's  the  distinction of why we put some stuff in this objects area is that these are things that might change or are somehow compound and therefore we need to know whether there's two names for the same thing or not. the next question was if you have one function and you call it multiple times do you create a new frame every time you call that function or just reuse the old frame every time you call the function it creates a new frame and you can think of it as sort of when it's done evaluating it disappears and then when you call it again it comes back now i think in the in the environment here you'll see it get grayed out. i don't what happens john when you when you call it over does it does it overwrite the previous one or does it create a new one underneath it uh so in the environment diagram you will get a new frame every time you call something um we leave the old ones in there just so you can see what happened before but they're essentially gone completely.  like python doesn't even keep track of them and sometimes, they're effectively gone in the sense that in order to refer to something later uh you'd have to do some trickery which we haven't taught you how to do yet but basically: they were there, but now we're done with them.
once you return, in general, you don't need the frame anymore. we show it so you can kind of keep a history of what happened but every time you call f you get a new frame yeah great question so can a function create other functions that's exactly what we'll do next wednesday a function that creates another function is called a higher order function and how you do it well i'll let you either read ahead or wait for the videos a good question are higher order functions somehow anonymous not necessarily so there's a notion of an anonymous function and a notion of a higher order function and they're different. they're orthogonal.
you could have a higher order named function you could have a higher order anonymous function and any other combination that you want.
you'll learn about that on either wednesday or i think friday.
the question is are you required to do the readings? there's nothing in the readings that's not in the lecture uh students have said that the readings are helpful. you know, there's a lot of stuff crammed into the lecture and sometimes there are more examples in the readings but it's not like there's going to be something that's only in the reading and it's not in the lecture and therefore you can't know it unless you do the reading uh so do the reading. i would recommend you do the reading especially if you're pretty new to the topic i think they're going to sort of touch on slightly different things the big concepts are all there but i think it's a good way of augmenting the lectures okay but will we be ever tested on something that's not in the lecture i believe the answer is no everything that uh we'll test you on we do try to cover in the lecture, all right.
or in the discussion worksheet for a few topics that are only in discussion all right guys thanks for your patience we are at 10:20 now so i think we're gonna call it a day for those of you who want to come to the two o'clock AMA ask us anything, that could be about the class it could be about computer science as a field it can be about the major here it could be about just about anything um within bounds obviously um and we're just gonna be hanging around for about an hour or so and and just talking so um hope to see you then 