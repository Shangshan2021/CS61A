Data abstraction. A new method  of abstraction. Here we go.  Most values are compound values, in the sense that  they combine different objects together in order   to create some object with multiple parts,  such as a date, which has a year, a month,   and a day, all combined together in one thing.  Or a geographic position which have a latitude   and a longitude. An abstract data type lets us  manipulate compound objects as units. That's a   form of abstraction. What it does is it allows  us to isolate two parts of any program that uses   data. We want to separate how data are represented  and how data are manipulated. By doing this,   we separate the concerns within our  program among two different areas,   and we can change one without affecting the other.  So data abstraction is a methodology by which   functions enforce an abstraction barrier between  representation of data and the use of that data.  Now, all programmers work with compound data  at some point. But only great programmers   embrace data abstraction in order  to make their programs more modular,   and you too will be a great programmer very soon.
Let's take a look at an example. Rational   numbers. And we'll see what we mean by data  abstraction. So a rational number can be expressed   as a numerator divided by a denominator where  both numerators and denominators are integers.   And since we can represent integers exactly, this  gives us an exact representation of fractions. So   a pair of integers let us tell you exactly what  fraction we have, such as 1 divided by 3. But as   soon as we actually divide 1 by 3, then we'll get  back afloat, which is not an exact representation,   but a finite approximation of it through  a binary expansion. So we want to separate   the numerator and the denominator, not divide  one by the other, but instead have a compound   data type. So we assume that we can compose  and decompose rational numbers as follows. We   have a function rational, which takes n and d, a  numerator and a denominator, which are integers.   And returns a compound data type, a rational  number x. We have another function numer x,   which returns the numerator of a rational number  x. And likewise, we have a denom x function,   which returns the denominator. So we have a way of  combining together a numerator and a denominator.   And then we have a way of selecting those two  parts. This is called a constructor, it builds   a new value, which is an instance of an abstract  data type. And then these are selectors, which   are the functions that get back those parts of the  whole rational number. What we can do then is we   can start writing other functions that manipulate  rational numbers, such as adding them together or   multiplying them. Let's take a look. So just  to refresh your memory, if we want to multiply   3/2 and 3/5, we get 9/10. And why is that? Well,  the general formula for multiplying together two   rational numbers is that the numerator of the  result is the product of the numerators of the   first and the second, and the denominator is the  product of the denominators. Adding together two   rational numbers is slightly more complicated. 3/2  + 3/5 gives you 21/10. How do we get that? Well,   in general, we have two rational numbers, and  we multiply the numerator of the first by the   denominator of the second, add that through the  numerator of the second times the denominator of   the first, and that's our new numerator. And our  new denominator is the product of the denominators   of the first and second rational number that we're  adding together. So now we have formulas for how   to multiply and add rational numbers. How do we  write code that does that? Well, we'll write it in   terms of our constructor and selectors. So here's  a function which multiplies together two rational   numbers x and y, and returns a new rational  number, the numerator of which is the product of   the numerators of the inputs. And the denominator  is the product of the denominators of the inputs,   just like our formula says. We see that we've used  a constructor to create a new rational number,   and we need to use the selectors to select out the  parts of x and y that we need in order to complete   this formula. Likewise, we can write a function  that adds together two rational numbers. We give   names to their numerator and denominator, because  we use those multiple times in our expression,   and then we return a rational, which follows  the formula on the right. One more function   lets us really work with rational  numbers. And that is equal rational,   which returns true if x and y are the same  number. Now, we can't just compare their parts,   because 1/2 is the same rational number as 2/4.  So in order to resolve whether x and y are equal,   we multiply the numerator of the first by the  denominator of the second and check and see if   that's equal to the numerator of the second times  the denominator of the first. Tongue twister.  Okay. So what you see here is that we've  defined all of the ways in which we will   manipulate rational numbers in terms of three  functions. And these functions implement an   abstract data type for rational numbers. What  that means is, all of our manipulation of the   numbers is written in terms of these functions.  We haven't even defined these functions yet. But   since we know that these are the tools we use to  access the parts of rational numbers or create   new rational numbers, we can write functions in  terms of these and then implement them later.
