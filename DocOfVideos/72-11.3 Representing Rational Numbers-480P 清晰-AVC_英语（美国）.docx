A pair consists of two values that are  joined together, bundled together in such   a way that you can treat them as a unit, as a  whole, even though there are two parts. Now,   there's lots of different ways to represent a pair  of things. But we're going to use a built-in data   type first called the list. So I can write the  line of code pair = [ 1, 2 ] and what we have here   is what's called a list literal, which creates  a new list that contains 1 and 2 as two values.   And since we have two values in the list, we'll  call it a pair. And when I display this pair,   I see its contents written just like the literal.
So a list literal is a comma-separated expression   in brackets. Once I have a list, which is the  value of a list literal, I can access the elements   within the list through what's called unpacking  that list into different values. So by saying x,   y = pair, I'll bind x to the zeroth element,  and y to the first element. After which,   if I look at what x is bound to, I'll see 1. And  what y is bound to, I'll see 2, that's because   that's the contents of the list that I've created.  So we now have a way to bundle together values and   split them apart again. This is called unpacking  a list. Another way to access the elements of a   list is through the element selection operator,  which again, uses square brackets. So these   square brackets are different from this one,  although they're certainly related. But this   is just square brackets without anything before  it, whereas this has some expression before it. So   when you have square brackets after an expression,  that involves selecting an element from the value,   which is to the left of the brackets. So a pair  is a list value and its zeroth element is 1,   its first element is 2. Element selection using  the Selection operator is another way to access   the elements in a list. There's also a function  that does the same thing. As we've seen many   times over in Python, each operator has some  function, most of which are within the module   called operator. So the element selection operator  is called getitem, all one word. It's okay to   say a fast because it's all one word.
getitem(pair, 0) gives me the zeroth   element of the pair list. And that's 1.
getitem(pair, 1) will give me the value 2.  This is an element selection  function or the getitem function.  Okay, we now have a basic introduction  to what lists are, and so far we've used   them to create pairs. And why is that useful?  Well, a rational number is a pair of integers,   the numerator and the denominator. So here's a  definition of the constructor of the abstract   data type for rational numbers. It's a function  that takes in the numerator and denominator.   And we need some way of representing  that pair of things, we'll use a list,   so we construct a rational number that represents  N/D, just by returning the list of n, d. So this   constructs a list and the list we're using as a  rational number. Now lists can contain anything.   They don't necessarily just contain integers.  But we're using it to represent a rational   number in which both n and d should be integers.
Now, how do we get the numerator out assuming that   x is what was created by the rational constructor?  Well, we just access the zeroth element. And the   denominator is element at index 1. So we're going  to select an item from a list here in order to   implement what we want, which is selecting the  denominator of a rational number. So let me show   you the first example of why data abstraction  can be useful. Recall that we implemented   multiplication among rational numbers. And here's  an example, 3/2 x 5/3. And what do you get? Well,   you multiply the numerators together to get  15. You multiply the denominators together   to get 6. And the answer is not 15/6 but  5/2. And why is that? Well, we had 15/6,   but those were not relatively prime integers.  We can reduce the fraction to lowest terms by   multiplying both the numerator and the denominator  by 1/3. And that gives us an equivalent fraction,   5/2, that's simpler. Now, the reason we do  this is in order to keep the integers small   so that they're easier to look at and understand.
What about 2/5 + 1/10? Well, we can apply the same   procedure we had before for adding together  rational numbers. And we'll get 1/2. Now,   why is it one-half? It's because, through  the cross multiplying and addition,   we got 25/50. And so there's the 20, there's  the 5, add those together to get 25. 50 is 5   times 10. But then we can reduce that to lowest  terms by multiplying both the numerator and   denominator by 1/25, leaving us with 1/2.
So how would we change our implementation   to do that? Well, here's the idea, addition and  multiplication, actually, were correct in the   first place. What was wrong was our definition of  rational. Our rational numbers should be something   that's always represented in lowest terms or  always two relatively prime integers. So one thing   I can do is import a function that computes the  greatest common divisor. In a previous lecture,   I showed you how to write a function that does  this. But it also happens to be built into   Python. And then what I'm going to do is redefine  the rational constructor to take any numerator   and a denominator and then construct a rational  number that represents n/d. But does it in a way,   such that the numerator and denominator that are  accessed later are always relatively prime. Which   you can achieve by computing the greatest common  divisor of both the numerator and the denominator.   That's 3 in this case, or 25 in this case. And  then returning a pair that contains the numerator   and denominator, each divided by the greatest  common divisor, so that they're guaranteed to be   relatively prime. And we use integer division here  because we know that g evenly divides both n and   d. That's a property of a greatest common divisor  is the divisor evenly divides those numbers. Okay,   so we computed the greatest common divisor, we  changed the constructor. We don't have to make any   changes to add rational or mole rational or print  or anything like that, because we've been using   data abstraction, which means that everything was  defined in terms of this constructor. So changing   this constructor changes the behavior of all the  other functions as well. And that's a good thing.
