Abstraction barriers separate different parts  of a program so that each part only needs to   know so much about the rest of the program.  Now, these separations are important because   they allow you to make changes to one part  of your program and have other parts take   advantage of those changes without breaking in  any way or creating inconsistencies. So let's   talk about the abstraction barriers in the  development of a rational arithmetic system   that we've been working on for this lecture.
So there's a part of the program that uses   rational numbers to perform computation.  So I actually want to know what's 1/2   times 1/3. In those cases, we're actually  treating rationals as whole data values,   they just represent some number. We don't care  how. We just want to know what happens when you   multiply these things together. And in order to  do that, we use certain functions that are part   of the data abstraction for rational numbers.
add_rational, mul_rational, rationals_are_equal,   etc., are all things that take  in rational numbers and do things   with them, perhaps returning new ones.
But using these functions doesn't mean   you need to know much at all about how rational  numbers are represented. In the next layer down,   where we look at the implementation, instead  of just the use of these arithmetic operators,   we find parts of the program that create rationals  or implement rational operations. And they treat   rationals as a numerator and a denominator paired  together. Now, they may not need to know exactly   how that pairing happens. But they do need to  know that a rational number has a numerator and   a denominator. These two things can be selected.  And they need to know that you create a new   rational number by combining a numerator and a  denominator together. And these all happen using   the functions called rational numer, and denom.
So I drew a really thick line right there to   represent an abstraction barrier. That barrier  says anything that's using rational numbers to   perform computation should only do it in  terms of these functions, and should not   be using functions of a different layer.
In this way, the programs that we write   make as few assumptions as possible about  exactly what representations we're using,   and instead, obey the abstraction that  has been set out by the programmer.  So what if we go one layer down from that? Well, there are parts of the program that   implements selectors and constructors for  rationals. And those implementations of rational,   numer and denom treat rational  numbers as two-element lists.  So they do understand the whole data  values that they're consisting of   numerators and denominators. And then we  have a further detail that the numerator   and denominator are glued together using a list.
So for this, we use list literals and element   selection. And again, there's an abstraction  barrier. If we're in the business of creating   rationals or implementing rational operations,  we shouldn't need to know that we're using lists   under the hood. And we shouldn't cross this  abstraction barrier and use a list literal or   elements selection directly. Instead, if we write  our programs in terms of just rational, numer,   and denom, then changes to those functions  later, will be propagated throughout our   program. And we could, for instance, start  expressing every fraction in lowest terms.  Now is that it? Well, actually, there are  many layers of abstraction in a program.   And there is stuff that's even lower detail  than what we've seen so far. So lists are   somehow implemented in the Python language.  We don't really need to know exactly how that   implementation works. All we need to know is  that lists can be created with lists literals   and taken apart using element election. And so  any place where we are implementing selectors and   constructors for rationals shouldn't worry about  the implementation of lists. It should just know   that lists can be created and selected from.
So each big line is an abstraction barrier.   And you should know that when you're writing  one part of a large program, that it should   use the level of abstraction appropriate to  what trying to do. And the higher you stay   up without crossing these boundaries, the easier  it will be to change your program in the future.  So let's look at an example of violating  abstraction barriers. So I've said add_rational   1, 2 and 1, 4. So a half plus a fourth should  give me three fourths. And under the code   we've written, this will work just fine. I have a  definition of dividing a rational, which returns a   list of whatever is the zeroth element of x times  the first element of y. And then we have the first   element of x and the zeroth element of y.
Again, in our current implementation,   this will work, no errors will be raised. And  yet, we've done something terribly wrong. We   violated abstraction barriers. So for instance,  here, we've assumed in our use of add_rational,   that a rational is represented as a list of two  integers, which means if we went and changed   the rational constructor, it wouldn't be used in  this block of code, because I didn't actually call   rational here. I did not use constructors. Is that  so bad? Well, it's pretty bad. But it gets really   bad when you see that it happened twice in a row.
Okay, now I'm getting angry. That's unacceptable   that you would just violate abstraction  barriers like that. I hope we're done.  Oh, oh. Down here, we're dividing rational  numbers, which should treat rationals as   numerators and denominators, but not necessarily  assume that they're lists. So instead of using   the numer selector function, instead I've used the  elements selection that works for lists. Thereby   assuming that x is a list, instead of saying,  oh, it's something that has a numerator and a   denominator, but I don't know exactly what it is.
So I've gotten down to too low of the level. And   now, look. I did that four times and then  I returned a rational number. But again,   I did not use the constructor called  rational to do it. This is not okay.  If I saw somebody's computer with this code on it, I think I would honestly just light it on fire   and just watch it burn because code that  violates abstraction barriers should burn.
