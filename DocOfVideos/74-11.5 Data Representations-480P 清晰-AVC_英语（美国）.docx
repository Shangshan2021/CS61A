The purpose of maintaining abstraction barriers  is so that you can change your data representation   without having to rewrite your entire program.  Let's poke a little bit deeper into this idea   of data representation. What is data? What  does it mean for something to represent a   rational number? Well, we need to guarantee  that the constructor and selector functions   work together to specify the right behavior.  You don't have a representation of a rational   number unless it behaves like a rational number.  A behavior condition would read something like:   If we construct rational number x from numerator n  and denominator d, then it should be the case that   numer(x) divided by new denom(x) equals n divided  by d. Here we relate the constructor called n and   d to the selectors and an operation between them.
Data abstraction uses selectors and constructors   to define behavior. That's the  whole idea of data abstraction.  If the behavior conditions are met, then the  representation is valid. So the key underlying   idea related to data abstraction is that you  can recognize what sort of data something is,   by its behavior, not necessarily  by how you constructed it, or how   you implemented the constructor and selectors.
So let's look back at our example. We have add,   mul, an equality measurement, and a way  of printing rational numbers. All of this   doesn't assume anything about the representation  itself, only that the constructor and selectors   exist. That constructor and selectors below this  abstraction barrier are implementing rational   numbers in terms of lists. So it's the case that  I can say x and y are the rational number 1, 2,   and the rational number 3, 8. I should say,  one-half and three-eighths. So what happens   when I print the result of multiplying together  x and y? I get 3 over 16. It should be the case   that I can change my representation.  And all of this will still work.  So here we go. Instead of using a list to  couple together n and d into one thing,   we're gonna use a function. We're going to find a  function called select, which takes in some name.   If that name is n, then it's going to return  the numerator. Otherwise, if the name is d,   it will return that denominator. And what else?  We're not going to worry about those other cases.   We'll just return the select function from the  rational function. Now, it must be the case that   the constructor and the selectors are complements  of each other, that when you construct something   with the rational constructor, you can then select  its numerator using the numer function. So if x   is the result of calling rational, then it's a  select function, which I can call on n to get the   numerator. And likewise, I've called x and d to  get the denominator. Let's try our example again.   I set x and y to be one-half and three-eighths.  I then printed the result of multiplying x and   y together, and I got three-sixteenths.  Did we really change anything? Well,   certainly we did because x is now a function.  So that's a change in representation that led to   another valid representation of rational numbers,  that works just as well with our old code as what   we had before, but uses an entirely different  mechanism to keep track of the numerator and   the denominator. And notice that we did this  with just functions. We didn't actually need   that built-in list data type at all.
So what exactly happened when we   implemented rational numbers as functions? We defined the constructor and selectors,   and it was this function, the select function,  that represented the rational number. It was   returned by the constructor, which was a  higher-order function. And the selector just   called the function that resulted from calling  rational in order to get the numerator back  By defining a function within another function,  we were able to refer to the n and the d and the   enclosing scope. And so this select function  that we returned did have, carrying with it,   the numerator and denominator that we wanted  to access later as part of its parent frame.  So let's say a simpler example. We set x equal  to rational three-eights. And then we ask for   the numerator of x, which should be 3. The  environment diagram looks like this. Rational,   numer, and denom are defined. And then we call  rational on three and eight, which creates a   select function whose parent is the f1 frame where  n and d are bound. That's returned and bound to x.   X equals rational (3, 8). Once we have x, we can  ask for its numerator, which creates a new frame   in which x is bound to the select function. The  body of numer says that we're supposed to call x   on n. So that's exactly what happens in this third  frame, f3, where name is bound to n, the body of   select is executed, name is n and so it returns n.
Looking here, we see that the name n is not   defined. But if we look in the parent f1, n  is bound to 3, and so that's what's returned.
