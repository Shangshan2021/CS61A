this is the lecture 11 q a and the first question was what is an abstraction barrier they turned out to be like one of the more important concepts in this course so i get emails once in a while from students who say like oh i just took the operating systems course 162 and i never would have survived that huge project except that i remembered about abstraction barriers and so i was able to build it so this is a concept that's very important for building large programs which is quite different than what we've done in this course i mean actually your projects are pretty large but but eventually you want to build really large applications and the only way to make those manageable is to use abstraction barriers because then you can change parts without having to change other parts you can think about one thing at a time you don't have to kind of understand everything and how it interacts all at once in order to make progress so the idea behind an abstraction barrier is that you choose how you're going to describe some computation using some particular set of names or functions in this case because uh all of our names refer to either values or functions and functions actually do stuff so the story would be that when you're like doing something like performing some big computation you only use uh these operations here in order to do it that you want to add rationals together figure out whether rationals are equal if you're working with rational numbers without ever like doing anything with the representation of rational numbers like uh inspecting their components the reason you do this is so that all that code you wrote in order to perform a big computation of like uh you know the weather system or the air quality forecast or whatever doesn't need to change at all if later you decide to change the way in which you're representing numbers and this is true not just of representing numbers but representing anything if you want to like build a system that crawls the web looking for like interesting web pages you want to build that in terms of a set of functions that describes how to get the parts of a web page that doesn't assume that you know the internal data representation of that web page which might change over time so uh you know that's basically the story is that when you write part of your program you say in advance oh i'm going to write it in terms of these basic operations and then use those basic operations and and those basic operations then need to be implemented somehow and that is the next layer below the abstraction barrier is that you describe how to add rationals or multiply rationals or whatever so you're basically parts of the program that implement the things that you're using in the higher layer also need to be built out of a fixed set of components in this case functions that get the numerator and the denominator because you can't add things unless you know how to get their parts so um yeah i hope that wasn't too long-winded but the story is break apart your large program into pieces that don't depend on how the other parts are implemented let me let me add a couple things i i like that last bit i think that was exactly right so let me add a few things so first of all abstraction barriers are somewhat abstract and it's it's going to be hard to know exactly where to draw those lines until you start writing code and then you realize oh i made a change over here that trickled down and i had to go through ten thousand lines of code to make some changes which means you violated an abstraction barrier and that's you sort of learn by making these mistakes that's number one number two is abstraction barriers are built on the concept that code is not static it's constantly changing there's no notion of you write something and then you go home and that thing runs for the next 10 years and code is constantly changing and because of that you want to isolate the impact of change yeah so imagine an automobile think about all the complexity of an automobile the wheels the chassis the engine and imagine a world where you decide you're going to make a change to the windshield wipers and now you gotta change you gotta make a change in the carburetor because of that so you wanna isolate where change impacts and that's this notion of abstraction barriers that if i make a change in one of these rows here there's no ripple effect down to the rest of the code and that makes it easier to make changes and to of course debug and now the question you want to ask is well how do i know where to draw those lines and that's where it takes a little bit of time and experience and you'll see where we draw those abstraction barriers to make sure we hide things from other parts of the code a follow-up question was if you make a change to one layer in this picture does that affect all the layers above or all the layers below it depends how you make that change there are many changes that happen in within a layer that won't affect any other layer above or below if you don't change the names of the rational operations and you don't change how they're being like the basic components all you do for example is now store the numerator and denominator in terms of uh like terms by like applying a gcd uh every time you uh perform addition that change could actually be isolated at just one particular layer and not have not require you to make any changes to the code that implements all this stuff and not require any changes to the code down here so that's the ideal sometimes a change will require you to edit something above or below if you've sort of changed the name of add rational then you're going to have to change everything that calls that rational to use the new name but but many changes will be limited in their scope to just one uh layer meaning it won't cross either abstraction barrier above or below so there's a couple questions in the chat so let me just read them and then we'll see if we can answer them so as you go down the chart the function should be simpler not necessarily you can have incredible complexity in the implementation of a list hide that from me and i can use a list and i don't care so the the hierarchy here isn't really about complexity it's just about layers of abstraction and how you're doing things exactly like we talked about dictionaries in this class the implementation of dictionaries actually changed quite recently in python but no python code had to change as a result because all the python code that you write is above the abstraction layer that separates the language from its interpreter the interpreter did change like the way in which you know what is a dictionary is it a list of key value pairs is it something else well you'll learn all about it in 61b but actually i'm not sure that even in 61b you'll learn all the details of what goes into a modern python dictionary i mean it's quite a complicated data structure but it was edited and changed without really affecting any python programs because there was something complicated but sometimes the program you write that uses a dictionary can be very simple okay next question in the chat and we'll i'm sorry we'll get back to the i think we have plenty of time we'll get back to the hands raising a second but these are good questions um how do constructors and selectors come into play so what constructors and selectors they're just a level of abstraction so let's talk about a selector the selector says give me the numerator and then you don't have to worry about that it's represented as a pair as a list and get the zeroth element so the selectors are a way of abstracting out the underlying data implementation by saying look here's a function call this function call hands you back this part of the data it's none of your goddamn business how i implemented it just ask me for what you want and i will give it to you and that's that's what the selector does and it's also what a constructor does you give the constructor numbers and it builds the data type without you knowing necessarily that it's implemented as a pair or a tuple or a list or whatever so that's sort of the goal of those functions is the function themselves abstract out the underlying data type yeah in this picture the group of names that's over here on the right in the using column kind of describes the barrier just below and we'll see here there's an example of just selectors and constructors being the names that are describing this barrier so that's just one way to create an abstraction barrier is to use data abstraction constructors and selectors and together they describe how you're going to separate creating some values and operating on them from how you represent those values using something else but it's not the only way to create an abstraction barrier you could also do it by just like any collection of functions that you describe uh even if we change the implementation of a function should the arguments always stay the same as this function would be called another layer this is a really good question so ideally yes that's sort of what you want um now every once in a while you know things just something really complicated happens and you you have to make a change to the parameters being called and then you've got to ripple you know trickle that up or down the extraction barriers but ideally yes when you make a change in one of these rows nothing should change but you know we're also aware that sometimes you add a huge amount of complexity or something really radical changes in which case you're going to have to deal with that sometimes you will have to break through those barriers yeah exactly and your barrier stable in a way if your function signatures stay the same so that's the name plus the set of arguments that they take that's the whole signature of a function basically the whole def line uh and if that stays the same then you're you can make change below without affecting anything above uh this is just a very specific question about dictionaries for dictionaries do all the keys have to be one data type and all the values be one data type um so the i'm not sure about the latest uh dictionaries in python i don't believe they do right certainly the values can be any data type you want and the keys also well they can't be lists of course but they can be integers or strings yeah yeah you can have a mix of different uh types so it's very flexible in that way yeah and by the way lists are the same way obviously the the key in in a list is just the integer 0 1 2 3 4 but the values in a list can be arbitrary right you can have a list of a mixture of strings and integers and lists and lists of lists and objects and blah blah blah so the dictionaries are just even a little bit more general because you can index on anything another follow-up question was does data abstraction only apply to rational numbers or is this something more general that's just one example we're going to be doing a lot of examples of data abstraction that was just a particularly nice example of how you can hide certain implementation details from the user yeah good question so um the question is how would you convert a rational that you've created using this data abstraction to a float value so that you could perform whatever mathematics you want using the float um and where do you have to be careful about violating abstraction barriers i think a good way to handle this case would be that once you have your rational implementation that we talked about from lecture which does whatever it does you would write another function which is part of the description of how to manipulate rational numbers which converts it into a float that would be a fine way to do it so if this is our abstraction uh we could write a rational to float function which returns the numerator of r divided by the denominator of r and you know where is this in the like uh layers that we developed well i think this is actually part of the like manipulation of rational numbers the same place where ad rational is where in order to uh in order to convert this into a float you have to have access to its numerator and its denominator you can't just create think of it as a whole object you have to think of it as parts but you don't have to know how those parts are bundled together you just have to know that those parts exist and then that they give you back numbers and those numbers can be divided so um yeah if there's like three parts of the program you have your uh data abstraction you have your operations on that data and then you have your you know weather simulation or whatever is down here um that is based on rational numbers i think that converting to a float would be in here somewhere as yet another operation that you might apply to rational numbers yeah i think that's exactly right notice a couple of things notice that the function rational to float does not access r using r sub zero and r sub one it uses the selector functions because it's across a barrier right so even though it sort of knows what it's doing that's a no no because if we change the representation up at the very top here we don't want it to trickle down that's number one and number two to uh the question is if you want to create functionality for rationals do it add that functionality i can add rationals i can multiply rationals i can now convert it to return to a float and build it into your think of it as a library you're building a library for manipulating in this case rational numbers i need something to represent them i need something to manipulate them and don't let the user do it i mean the user may want to eventually do something but your job is the coder to say all right what is the user going to need give them the functionality to do that and a follow-up question is should we be assuming that this r that gets passed in was created by this function and that is exactly the assumption that you make for everything in here assume all r's uh are the return value of calling rational yeah those are think of them as those are functions that operate on rational numbers defined using what you see above right that's what they operate on that's the data type that they operate on exactly so we are making assumptions um wouldn't it be nice if we could like assert that somehow um well um you you could try to set that up we haven't really talked about how to do it but it's not terribly complicated um you could just uh add an is rational check in here which does something and that is what you would assert and you might want to set it up so that not every pair every list is this maybe you want to set it up so that the way you really build these is that you talk about it as a rational number and then you could have this be like uh return len r equals three and r zero is this special string rational or something like that so then basically not every list that has two numbers in it is a rational number instead they all have this kind of special keyword this is the kind of thing that was done quite broadly before um object-oriented programming and it is the same idea that we'll see in object-oriented programming except for that will then be kind of built into the language and happen for you automatically so this is an old idea of tagging data types and then kind of checking to make sure that you have the right thing and i think it's a good one because it helps reinforce these assumptions right by the way notice something super cool in what john just did he just made a huge change in the underlying data representation of rational numbers it's now a triple with a string in the first position and the numerator in the denominator second and third position what did he have to do to change the code to make everything work he had to change two functions right numer and denom and everything below stays exactly the same there is no impact on the rest of the code that right there what john just did is sort of epitomizes the abstraction barrier right he made a change up top and there's absolutely no impact down below the next question was how do you figure out in a tree recursion problem how to break down the problem into two recursive cases so this is a question of how to think about recursion and i think you're right there is something a little sort of twisted in the way you have to think about it so here's how i think about it and i don't know if this will be helpful either let me tell you how i think about it as i'm writing the function i tell myself this function works and i can call this function to do the thing i want it to do it's really sort of the ultimate in abstraction i say i'm writing a function that computes fibonacci assume i have it and when i have it assume i can call it and then just do it just call the function and that's sort of that's that leap of faith that we were talking about earlier you're going to jump off the cliff and hope that the parachute is is going to get configured as your fault plummeting to the earth yeah um so i think it is really thinking about the functionality first of all it's thinking about how the function is defined how the the problem is defined recursively and then just calling your function and one of the things that helps here is to use really sensible function names and variable names if you're using them so that when you say you know the fibonacci of n is the fibonacci of n minus one plus fibonacci of n minus two it sort of makes sense that you're just calling this thing in some ways you can think about it is calling somebody else's function that does the thing that you want the fact that a recursive is not really actually that important it turns out john may have another suggestion i thought that was great i i think the other one last piece to keep in mind is that many tree recursion problems involve making a choice like am i gonna you know you're trying to find the longest sequence within a list that um that all increases or something like that the choice there might be am i going to keep the current element in the answer or am i going to throw it away and figuring out what that choice is where if you stack many of these choices on top of each other make one after the other then you could get to any possible solution and this choice splits like all the possible solutions into two groups one that where this choice is true and one where this choice is false finding that choice is often the key to the implementation this was true for competitions it would be true for example in the account change problem on your homework um and it's not something that's obvious in the description of the problem instead it's part of the implementation that you have to figure out it's like how could i make one choice here and by making similar choices many many times over i'll eventually get to the answer that i want and i don't think it's uh trivial at all to come up with that choice but you can think about options like oh am i going to use this first thing or not is is often the choice and um or like how many of the first few things am i going to use one or two or three or four or whatever and then coming up with the recursive calls usually is kind of mechanical once you've figured out what the choice is so in count partitions it was about like am i going to use the biggest part or not and um when i use it then i get one recursive call and when i forget about it then i get another recursive call and and so like you can often reconstruct what the recursive calls are just by thinking about like what happens if i follow this choice path a or path b and then just like connie said in order to figure out whether you made progress or not you do have to assume that the function works and think about that recursive call as something that's got behavior it's going to do the right thing without worrying about how it does it yeah and then the less good answer here to this is it will come with experience like you just you got to do more examples you'll start to see patterns emerge there's a relatively small number of patterns emerge that in doing recursive functions and the more you do the more comfortable you'll get with it um almost so the question is about this concept of getters and setters in java and is that the same thing as constructors and selectors in data abstraction and there isn't quite a one-to-one mapping there instead what i would say is that constructors are like instructors in java and that selectors are like getters and we haven't really talked about setters at all because we haven't talked about changing a value at all yet but we will get there so if you really wanted to replicate that behavior from java then you'd need another set of setter functions in addition to the selector functions and the constructor but conceptually yes it is it's it's those the setters and the getters probably like my the the hairs on the back of my neck cringe when i hear that because i'm not a big fan of the java programming language but conceptually that what they are about is data abstraction they are hiding details from the rest of the code and so conceptually that is the same idea and you'll see that get formalized a little bit more in python too there is a not there is a notion of classes and objects in python and we'll see that well great question so the question is like what exactly is a constructor and a selector we've done one example and how does this generalize to other examples and like what counts as constructors and selectors and what doesn't the the core concept here is about data representation there's like something in the world and you want to write a program about it but your program is just full of like numbers and lists and strings how do you represent something else in the world that's um more complicated and rational numbers in some sense is a bad example because it's just more numbers but what we really should be thinking about is like how do you represent a whole um house and because you're building like a real estate site well a house like has all kinds of attributes it's got a location oh so how we're going to represent locations uh it's got a layout oh so how are we going to represent the layout well all of these are actually like different data abstractions that you could include you could have a location is represented as its longitude and latitude but that might not actually be right instead it should be represented as like it's a street address which has a number and a street name and the zip code and stuff like that so basically everything interesting in the world has multiple different attributes multiple different parts and some of those have parts and some of those have parts and data abstraction gives you a tool for managing all of this where you can say like oh a house is built out of its location and its layout and a location is built out of its uh street address and its longitude and latitude and the street address is built out of a bubble ball so the whole use of constructors and selectors in a larger program would be to define these things that you're trying to describe in your larger program so they would say like oh i'm going to give function names that associate to each one of these attributes of some concept that i'm trying to represent like a house and i'm going to say like every time i build a house i need these three things and every time i have a house already and i have a name for that i can access those attributes here's another example let's say you want to build b courses yeah so what do you need you need a course what's a course well it has a title it has an instructor it has a date and time it has a well it used to have locations where they were being taught you have students students have ids they have scores they have the year of their enrollment and then you want to be able to construct a student that's a constructor you want to be able to ask something about a student what's their student id number um what is their grade on this exam or on this homework and so john said it exactly right that the rationals is a really simple example right you just have these two little numbers in the list and you're like why am i doing all this fussiness for that but as you build bigger programs the amount of data you have can get very complex and again you want to hide that implementation detail from the user and we'll see examples of that you'll see where we start to build more complex data types and where you need to be able to use these things a follow-up question was is there a difference between constructors and selectors or are they basically the same thing there there is a difference between constructors and selectors so let's go let's do the rational example the constructor creates a rational number yeah it takes two numbers takes takes a list and hands that back to you the selector says give me one part of the data the numerator or the denominator in my example of b courses a constructor would create a record for a student it would populate everything that was passed to it and then the selector would say okay give me these little pieces of information associated with a student that has been constructed yeah the next question was is data abstraction similar to object oriented programming are they basically the same thing they are they are absolutely i mean they're object-oriented programming is designed around this notion of data abstraction that you build these classes slash objects you abstract out the underlying data with constructors and selectors you create functionality within the class and then you combine those classes to create larger programs and object when did object-oriented start john maybe 20 years ago something like that certainly became popular like 20-30 years ago i think yeah it's back to small talk so it's uh its invention was older than that but um but it's certainly become like the dominant paradigm for building applications more recently right but but you're absolutely right audrey that this is this is this is the this is the lead up to classes objects and object-oriented programming yeah and i think object-oriented programming has multiple ideas all kind of lumped into one in this course we try to isolate them a little bit to give you some exposure before we kind of throw you into everything at once so this is the biggest one thing that objects allow you to do data abstraction but it's built into the language instead of you having to decide the representation every time that kind of happens automatically the second is about changing state which we'll talk about next in the course like very soon and the third is about like relationships between types which is something that actually is used less i'd say in modern programming than these other two features but it's also an important characteristic of object-oriented programming which we'll teach as we teach you about object-oriented programming and so that's coming up as kind of the next unit in the course uh after we finish talking about data abstraction and uh what we call mutation which is basically like objects that are changing then we'll put that together and you can see how it's built into the language using objects and by the way since somebody mentioned java earlier let me just mention a few things if you've done any java programming if you haven't just ignored what i'm about to say but if you've done notice that in java everything's an object you can't really can't do anything without objects and one of the great things about python is there is you will see that there is an infrastructure for doing object programming but you don't have to use it it gives you that sort of flexibility um and that's actually by the way pedagogically one of the reasons why i like python as a first language is it it doesn't get into all of this stuff on day one you can actually well extract it out and not worry about it until you have to worry about it the next question was for the slide that lit on fire what exactly was wrong with the code that was written there how did it violate data abstraction principles oh yeah first of all can we just applaud john for how awesome that slide was um i really i was i was i i got a great kick out of that and by the way it violated the data abstraction in so many different ways i don't even think john enumerated all of them yeah i mean it's hard it's hard to think about a large program in the context of a lecture where the program is actually tiny right so um so what's wrong with this code it looks sort of fine right but it is violating these general programming principles which are really important if we were writing a larger program and so what we would expect here is that ad rational would only take as arguments the return value of calls to the rational constructor so when earlier in this discussion oh i guess i deleted it yeah you changed the representation of rationals to like include a third element a string this line of code would break as a result because it doesn't call rational on one and two instead it just builds a list of one and two which means that if you ever changed the behavior of rational you'd have to go change this line of code which we don't want to do so the idea is that every call to add rational should not be affected by changing the implementation of rational or its selectors numero and dino so that was what was wrong with this line is that we passed in the wrong kinds of arguments to add rational even though it ran it wouldn't run in the future if we had changed the implementation of the constructor and the selectors what a mess right is that like the code is wrong because one day it might be wrong but right now it's right well that's exactly the kind of thing you do have to think about if you're building large programs is that it's not good enough that this thing runs today and uh doesn't crash and passes all the dock tests or whatever it really has to be built with an eye toward the future where decisions that you made about your implementation when you're first getting started are certainly going to change because you're going to think of something new later like you want to be able to assert that something's rational so you need to change the representation well look like uh if you have to go back and edit all your code then you're never going to want to make changes and that means your code base will never improve and you'll end up with kind of a program that's stuck with all the problems that you ever inserted whereas if you write code that's sort of future proof in this way by using these abstraction barriers to isolate parts of the program then uh then you can be comfortable making changes and uh you won't have to worry about breaking anything that was already there so that was basically the story and and what you see here is true down here as well divide rational was supposed to be part of the program that assumes it's getting rational numbers and only manipulates them using the constructor and the selector so it should have returned a call to rational that got the numerator and the denominators using calls to numer and dnom and that's not what we did and therefore this would have to be entirely rewritten if we changed the implementation of the data abstraction this is this is a really important concept and it's it's understandable if it's not entirely crystal clear in your head don't worry as we do bigger examples and more examples you'll start to see that abstraction but it is something that um johnson did exactly right um is at least for me when i really learned this is when i had to either change my code or change somebody else's code and i realized that you know something i would do up here in some function had this weird effect down below and you're just going to learn by writing crappy code and you're going to realize oh this when i want to make some change to something which always happens um and it's and sometimes it's you start writing code and then you realize you you forgot something you've already got 10 000 lines of code you got to make some big change back early on and you're like oh crap this is going to trickle all the way down and so that's when you start really sort of thinking you know really hard about these abstractions and how you write code in a way that can build sort of a really solid infrastructure so it takes a little bit of time and experience so hang tight this is maybe the first topic in the course where having learned it you can't do anything no at this point some chaos ensued because of the phone call i received and i've edited that part out um well who knows what i was saying but i'm sure it was very you're saying you're saying that this is one of the concepts where you learn it it's not immediately obvious how to apply it just yet right you can't like write some program that you couldn't write before but you know also a topic that students tell me is one of the more important things that they learned while they were in 61a because it applies so much to kind of later parts yeah this is the one concept that will carry you just about every class you take when you're writing code this is probably one of the most important concepts that you'll take away from you and it's also one of the most abstract so that's okay that just means it takes 