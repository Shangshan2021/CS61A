Processing container values often involves  iterating over all of the values contained   in the list or dictionary that you're interested  in. But there are some functions built-in that   help us do this more efficiently. In particular,  there are several functions that perform sequence   aggregation. So these are functions that  take iterable arguments and aggregate them   into a single value. I'm just going to show  you the actual documentation in Python 3,   and help you understand how it works. So  there is a built-in function called sum,   which takes an iterable argument such as a list.  Now, this notation doesn't actually mean you write   square brackets when you call it. Instead, this  is something that's used in Python docs to say   that the second argument is optional. So you can  call sum with just one argument, a list, and it   will sum the values. Or you can call it with  two arguments, a list of values, and then some   start value. And it will go through all of the  values in the iterable and add them to the start.  Okay, so here it says, return the sum  of an iterable of numbers, not strings,   plus the value of parameter start, which defaults  to 0. When the iterable is empty, returns start.  sum( [2, 3, 4] ) is 9 sum( [ '2' , '3' , '4' ])  It doesn't work with strings. Now, what's the  starting value about? Well, if I started with 5,   then I would add 5 and 2, and 3, and 4.
Now, why is that useful? Well, let's say   you're adding together values that aren't  just numbers. You have to provide a value of   that type in order to get started. So remember  that I can add 2 and 3 the list to 4 the list,   and I get a longer list. Well, in the same way, I  can sum a list containing 2 and 3, as well as 4 as   long as it's the case that I start with a list in  the first place. If I hadn't started with a list,   I'd try to add this list to the number 0. And  that's not possible. So that's what would have   happened if I had some without that starting  value. But since I provided an empty list,   to begin with, and then I added in 2 and 3, and  then I added in 4, I ended up with a list 2, 3, 4.  Max takes two forms. You can pass it an iterable,  such as a list, as well as an optional key   function, and it returns the maximum value. Or  you can pass it multiple different arguments,   such as a bunch of numbers, along with a  key function. And then it will take the   max of the arguments. So it says, with a single  argument, return its largest item, that is an   element of the list that you pass in. With two  or more arguments, return the largest argument.  So the max of a range going up to five  is four. Or I could have said max (1,   2, 3, 4) with a 0 at the beginning, and  that would have done the same thing. Now,   what's going on with this key function? Well, the  documentation didn't tell me. But what happens is   that it applies a function to every element that  you're considering, and actually computes the   maximum based on the return values of calling  those functions. So you can ask things like,   what's the max value in the range from 0 through 9  if what I care about is some algebraic expression   like 7 minus x minus 4 times x minus 2. Now that's  some parabola where the maximum is right at 3. If   I designate this as my key function, then it's  going to tell me the maximum value in this range   as an output of calling this function is 3 So  if I take this function, and I apply it to the   number 3, then I get 8. What if I applied it to  2, I get something less. If I applied it to 4,   or 5, or 6 or 7, I get something less as well. So  that's why it's giving me the return value of 3.  Here's a third one called all. All takes an  iterable and returns true if you get a true   value when calling bool on every element in the  iterable. If the iterable is empty, return true.  What's this bool function? Well, bool tells me whether a value   is true or false. So 5 is a true value.  True of course is a true value as well,   even negative 1 is a true value. But zero is  not a true value. It's a false value. Likewise,   hello is a true value, and an empty string is a  false value. We learned about these when we talked   about Boolean contexts, back when we introduced  conditional statements. So what about all? Well,   let's say I have range(5) and I want to ask  is it the case that x is less than 5 for x in   range(5). I'd get true, true, true, true, true.  The goal of all is to aggregate those together   and tell me whether they're all true or not. I  don't have to pass it a list of Boolean values.   I could pass it the list of numbers 0, 1,  2, 3, and four, and it would tell me that   since 0 is false, these are not all true values.
So those are three built-in functions that operate   on sequences. There's also min and there's  any, which are complements to max and all.
