Trees are an important data abstraction for  representing hierarchical relationships. We've   drawn pictures of trees before, and discussed  how in computer science they grow upside down.   Now we'll talk about the common vocabulary  used to describe trees. There are in fact two   different metaphors used regularly. The first is  the recursive description of trees, where a tree   is like a wooden tree, like an apple tree. In this  description, a tree has a root label and a list   of branches. There's the root label, there's a  branch, there are only two branches to this tree,   and the other branches here to the right. By  the way, each branch is a tree. That means the   branch has a root label as well. A tree with zero  branches is called a leaf. So there's a leaf with   no branches, it does have a root label of its own.  Now, once you've constructed a tree recursively,   you might want to describe certain locations  within the tree. And so we say in the relative   description about family trees, that each location  in a tree is called a node. So here are all the   nodes. I have circled them. And this is the  root or the root node at the top. Each node   has a label that can be any value. So the data  stored within the tree are stored at the labels.  Now, the reason I call this a family tree  relative description is that one node can   be the parent or child of another. So we can  say that this node containing 2 is the child   of that root node containing 3. And you can  also describe other familial relationships,   such as ancestors, and descendants, and  siblings. By the way, people often refer   to the label values themselves by their locations.  So something like, each parent is the sum of its   children, which is true of a Fibonacci tree.
Now that we can talk about trees, we can talk   about implementing the tree abstraction. A tree  has a root label and a list of branches. And the   constructor is going to take close to values.  Each branch must be a tree. So if I want to   construct a representation for this small tree, I  would write the following code. It's a tree where   the root label is 3. And the branches are a tree  with 1 and a tree with a 2, 1, 1. In this case,   I'm using the constructor as I've described it so  that I can change representations however I wish.  Now, you might say, aren't I violating an  abstraction barrier because I'm using a list?  No, it's part of the abstraction that a tree has  a list of branches. So it's totally fine that   I'm using a list here. Because that's part of the  abstraction. It's not part of the representation.   Now let's come up with a representation. I could  come up with anything I want. And that will   determine what actually gets printed out by Python  when I evaluate this constructor expression.   Here's what we'll get. It's just some lists within  lists with the label values embedded within.  The way we construct this is to define a  constructor tree, which takes the label   and a list of branches. By default, the list of  branches is empty. So by default, I'll get a leaf,   which is why I'm able to call just 3 on 1 in  order to construct this leaf node here. I put   the label into a list. Branches is already a list  and so I sum them together. The label of a tree   is a selector that returns the element at index  zero in the list representation of the tree. And   the branches are the rest of the list elements  as a list. Now in order to make sure that while   I'm using the tree constructor, I don't build  something that's not a tree, I'm going to add   some checks. The first check here says for branch  in branches, assert that the branch is a tree,   as part of the abstraction. And my code is going  to make sure that I obey that abstraction as I   construct the tree. I'm also going to call the  list on branches instead of just saying label in   a list plus branches. In order to make sure that  if I pass in some other kind of sequence, it gets   converted to a list before adding to another list.  So these two lines are really just there to verify   that the tree definition is being respected  within the body of whatever program I write.  How do we know if a branch is a tree? Well, for  anything to be a tree, it has to be a list, it has   to have at least one element for the label. So if  that's not true, we'll return false. And it has to   be the case that all the branches are trees. So in  fact, is_tree is a tree recursive function itself,   that goes through every branch and the branches  of the tree. If it's not a tree, that branch,   then the whole thing can't possibly be a tree.  If these two checks pass, then it must be a tree.   Because it has a label, and it has branches that  are trees. Finally, I'll add one more function   to my tree abstraction, which is a check to see  if a tree is in fact just a leaf, which checks   that the branches are empty. If I call branches  on tree and get back an empty list, that's a   false value. So not branches (tree) will be a true  value, just as long as this tree has no branches.  Now that we have the code for our data  abstraction, we can use it. We can create   a tree that's just a leaf.
Is it a leaf? Oh, yes, it is.  If I want to create a tree with branches, then  I specify those branches in a list because every   tree should have a list of branches, which by  default, is empty. Now, if I just put a single   value in here, I'm going to get an error that  say, branches must be trees. It must be the case   that when I construct this, everything I put in  the branches list is itself a tree. If I want a   tree with branches to be one of my branches, then  I give branches to that tree. And in this case,   we'll just put a leaf. So I finished the  tree rooted at 5. I want another branch,   which is a single leaf rooted by six. Now I've  listed all the branches for the tree. And there's   the tree. Notice that when I evaluated this  constructor expression, there were no errors,   because I've built a well-formed tree. Now it  happens to be that it has this complicated nested   representation. But that's not how I will access  it. Instead, I'll just ask, what's the label of   t? It's one. What's the branches of t? Well, a  bunch of trees. If I want to get the branch of   index zero, and I just write that, that's a tree.  And I can get the root label of that branch just   by asking for the label of the index 0 branch.  By treating branches as a list, I'm not violating   any abstraction barrier because I said in my  abstraction that a tree has a list of branches.
