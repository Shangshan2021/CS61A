Functions that take trees as input, or  return trees as output are often tree   recursive themselves. Let's look at some  examples. In practice, one does not often   create trees using the tree constructor and a  set of explicit labels but instead generates   the tree programmatically. For example, if I want  to create a function that builds a Fibonacci tree,   then I would write it in the following way. If  n is less than or equal to 1, that means the   fib tree for that n is just a leaf. I create the  leaf using my tree constructor. Otherwise, I need   to build the two branches of a Fibonacci tree.  The left branch and the right branch are both   going to be constructed with recursive calls to  fib tree. Finally, I want to return a tree. That   means calling the tree constructor on some label  value and the branches, the branches are placed   into a list. And what about the label value?  Well, here I apply the Fibonacci recurrence,   I get the label of the left tree and add it  to the label of the right tree. The base case   of fib_tree(1) or fib_tree(0) is just a leaf.  Fib_tree(2) has structure within it. It's the   label and has two branches, which are both leaves.  Fib_tree(4) is the Fibonacci tree that we've been   looking at as an example so far. So its label is  treee. And then it has how many leaves? One, two,   three, four, five different leaves. Oftentimes,  we'll write functions that take in trees and do   interesting things with them. Here's a not so  interesting thing, as a simple example. If I   want to count the leaves in a tree t, I'm going  to write a tree recursive function. Processing a   leaf of a tree is often the base case of a tree  processing function. Here, if t is only a leaf,   and I count the leaves, there's one leaf. The  recursive case typically makes a recursive call on   each branch then aggregates the results. In this  case, what we're going to do is take each branch   and the branches of the tree and count the leaves  in each branch. The leaves in the total tree   are just all the leaves and the branches summed  up. There's our first tree processing function.  Let's walk through it one more time. The t comes  in, I don't know if it's a large tree or a small   tree. If in the simplest case, it's just a leaf,  then I know what to do, I just say there's one   leaf. Otherwise, I sum up all of the results of  making recursive calls on each of the branches.   Count leaves b for b in the branches of the  tree. So what's particular about the count   leaves function is what it returns in the base  case, and how it aggregates its recursive calls.   And of course, don't forget to return that result.  We saw before that fib_tree(4) has five leaves.   And let's make sure that our count_leaves function  returns 5. It does. Now by the way, fib trees get   pretty large. Fib_tree(10), which has Fibonacci  number 10 at the top has lots of leaves. How many   leaves? Let's count, 89 leaves. An interesting  fact is that 89 is Fibonacci number 11.  Here's a discussion question. Implement leaves  which returns a list of the leaf labels of a tree.   So how does it work? It takes in a SumTree tree  and you call leaves on it and it gives you all   the values of the leaves. So notice that the root  label three is not in here, only the leaf labels.   In order to implement this function, we're going  to use a fact about sum, which is that if you sum   a list of lists, you get a list containing the  elements of all of the lists in the input. Let   me show you some examples. If you sum the lists  1, 2, 3 and 4, you get one list containing 1, 2,   3 and 4. In order to call sum on a list of lists  and have it aggregate all of the values in those   lists, you have to provide a starting value of an  empty list. If I sum a list with 1, I get a list   with 1. If I sum a list that has two elements,  and the first element is a list within a list,   then what I'm going to get is still a list within  a list and the output. Notice the difference   between this structure and that structure.  1 was the value in the output. In this case,   a list containing one is a value here. So it's  not enough just to sum the whole tree and get all   the labels within it. Because sum doesn't remove  all of the nested structure, it just gets rid of   one level. Okay. Here is the implementation of  the tree processing function that takes in sum   tree and returns a list of the leaf labels. If  it's a leaf, then we get the label and put it   in a list. Otherwise, we sum up something.
Here are eight alternatives. I recommend   that you pause and think about it. I'm going  to show you the answer in three, two, one.  Our goal is to get a list of leaf labels for  each branch, and then put them all into one   long list of all the leaf labels. We get that  by summing a recursive call to the leaves of   b for every b in the branches of the tree.  So this is almost identical to count leaves,   except for we have a different base case, and a  different use of some. Meaning, a different way   of aggregating the return values of the recursive  calls. A function that creates a tree from another   tree is typically also recursive. So for example,  if I have a tree, maybe it's a Fibonacci tree,   maybe it's something different. And what I'd like  to do is return a new tree that has exactly the   same structure. But the leaf labels have been  incremented. Then I'll write a tree recursive   function to build the new tree. If I'm building a  tree that's only a leaf, I get the label, I add 1   to it, and then I need to return a tree because  that's what increment leaves does. So a quick   check is that I do have the right range here, I'm  returning trees, just like I should. In this case,   we returned a leaf because we got a leaf in.  If I've been given a tree that is not a leaf,   then I need to increment the leaves in all  the branches of that tree and then build a   new tree with those new branches. Notice that  I keep the label the same. And that's because   this function doesn't do anything with the  labels of the nodes that aren't leaves.  Here's another tree processing function,  increment(t), which returns a tree like t,   but with all labels incremented.
I'll show you a trick.  You don't always need to have a separate base  case for the leaves if every tree is treated   the same way. This is a one-liner that says  return a tree, or I've incremented the label,   and I've incremented all of the labels in all  of the branches. This is tree recursive. How do   we ever reach a base case? Well, when there are no  branches, such as in a leaf, this is an empty list   and we're done. We don't make any recursive calls  when we reach a leaf. We didn't need to use an if   statement to say that because that's built into  list comprehension that if this list is empty,   then the whole comprehension is empty and  doesn't require any work to construct.
