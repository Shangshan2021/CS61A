Let's walk through one more example about summing  all the labels along a path from the root to the   leaf of a tree, and then printing out that sum.  Some recursive functions build up their result by   manipulating the return value of a recursive call,  where other recursive functions build up their   results by passing information into the recursive  call as an argument. And both of these strategies   are useful when processing trees. So let's look  at an example of both ways of doing things.  Before working with trees, let's go back to our  old friend factorial. One way to write it is if   n equals 0, we return 1, otherwise, we return n  times the result of calling fact on n minus 1.   And if we run this example on, say, 4 then  we'll get 4 times 3 times 2 times 1 is 24.   And this is an example of taking the return  value of a recursive call and manipulating it.   In this case, we're multiplying in n. But there's  another way. Instead, I could define fact_times,   which takes in both n and k. And instead of  returning just n times n minus 1 times n minus 2,   this returns k times n times n minus 1, times n  minus 2 times n minus 3 all the way down to 1.   And we'll do it as follows. If n is 0, we'll  return k, because n factorial is just 1.   Otherwise, we're going to return the result  of calling fact times on n minus one, and k   times n. And I think what's interesting about this  example, is that we're not manipulating the return   value of this recursive call to fact_times  at all. Instead, we're just returning it,   which means that the result of the recursive  call better be the result of the current call.   And extending this reasoning, it  means the result of the base case   needs to be the same result as the original  recursive call. And that turns out to be true   in this case. So if we're trying to compute  k times n factorial, here's the expression,   it turns out that's identical to k times  n times n minus 1 factorial. Here's the k   times n. And here's the n minus 1 factorial.  So here, the result is being built up. And by   the time you hit the base case, you're done with  all the multiplying. Whereas in this version, you   haven't done any multiplying at all. When you hit  the base case, that all happens after you return.   And in fact, if we wanted to define fact,  in terms of fact_times, that wouldn't be too   hard. We just return the result of calling  fact_times on n and 1. Fact 4 is still 24.  Okay, now let's work on an example with trees.  So I have a file with all of the tree constructor   and selector functions in it already called  tree.pi So if I want to be able to use all those,   I can write an import statement that imports  them all. And now I could build a tree.   A number 3 might look like tree is at  the root and then we have a branch,   that's a leaf with 4, and we have another  branch that's not a leaf with 5 and 6.   And let's have another tree, one with  letters in it, instead. We'll put   h at the root which has a branch rooted  at a. And this will have two leaves,   the s leaf and the t leaf. And then we'll also  have an e, which is its own leaf under the h root.   So haste is a tree that has the underlying  representation of a bunch of lists within   lists within lists. But I can get its label  and that will be h and I can get its branches.  Alright, let's say we want to write a function  that takes in a tree, finds all the leaves,   and for each leaf, prints out the sum of  all the labels from the root to that leaf.   Much like the fact times function, I'm going  to add a second argument, the sum so_far.   So that I can build up the sum as I go. And then  when I get to the leaf, I just print it out.   So whether this is a leaf or not, there's going  to be a label and we should add that to so_far.   But then, we'll figure out  if we're at a leaf or not.   If we are, then we print out the sum  so_far, which includes the leaf label,   and everything above it. Otherwise,  we go through all the branches.  t is a tree, so I can call branches on it.  I get a list of trees, so each b is a tree.   And print_sums is a function that I can call  on trees. So if I call prin_ sums on numbers   starting with 0, I'll see 7. And the 7 came  from the 3 at the root followed by the 4,   which is directly below the root and is a leaf.  The other thing that should be printed out is   the sum along the path from 3 to 5, oh, but  5 is not a leaf, so we don't print yet, to 6.  3 plus 5 plus 6 is 14, which is the 14 we  got down here. And what happens when we call   print_sums on the haste tree instead, is that  I think we should start with an empty string,   so that we can add more strings to it. At which  point, we print out has that came from h, a,   s and we reach a leaf. Or hat, h, a, t, we  reached a leaf. Or he, which is this leaf below   this root. And the structure of this function  is that we're building up the sum as we go,   always passing a new value into so_far. I could  have written so_far plus label t here instead of   this assignment statement, and that would have  been fine too. Or we could just update so_far,   