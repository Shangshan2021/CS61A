this is the lecture 12 q a i actually forgot to start the recording at the beginning of the q a so i missed a few questions i'm just going to answer them quickly right now and then go into the recording for the actual q a session one question was can a tree have any number of branches more than two the answer is yes a tree can have as many branches as you want a tree where any node has at most two branches is called a binary tree and that's quite important for efficient algorithms that you'll talk about in 61b but for representing stuff in the world trees with an arbitrary number of branches are quite a bit more common so that's what we'll focus on in this course a second question was about the optional second argument in the built-in sum function why is it the case that you need that at all well when you sum three four five what you're really computing is the result of adding zero to three to four to five and why is this the case well if you sum an empty list you get zero so built into sum is this notion that you're starting with zero and then you're adding other arguments in so what about adding something besides numbers like lists you can add three four five together but if you take these two things three and the list four five and put them into a list and call sum on that you get an error unsupported operand type plus for int and list why is that well python tries to process this the same way that it processed this which is to add zero to the list 3 to the list 4 comma 5.
that gives you the same error and the error comes from adding a number to a list python doesn't know how to do that i don't know either what you'd really like to do is start with a different notion of zero the most zero-like thing in the world of lists is the empty list if i added an empty list to the list three into the list four or five then i would get the same result as if i hadn't had the empty list there at all and you can get the built-in sum function to do this by saying here are the lists that i want to sum together or add together but the zero that i want to start with is the empty list next question was about trees here's our tree data abstraction from lecture and in particular a student asked what happens if you ask for the branches of a leaf a leaf is a tree with no branches there still is a list of branches it just happens to be that that list is empty if i actually loaded this file then it would be easier to see what i mean okay so a leaf is a tree that has no branches you can still call branches on it you just get an empty list that's what i mean by no branches there is a list of branches it's just empty and you can see why that's happening the representation that we've chosen for a leaf is just a list that contains the label and nothing else and so if i were to call branches on that i would be evaluating this expression which gets all of the values in this list which has only one element starting at element number one but there is no element number one and so you end up with an empty list if i were to write for b in the branches of this leaf since branch's leaf returns an empty list b will never be bound if i were going to do something for every branch since there are no branches hello never gets printed and b is not bound to anything okay i think that's most of the questions that we covered before i remember to start the recording so from here let's see what happened in the actual q a session okay so this question was about tree processing which is confusing and whether we could do an example that doesn't involve like labels and branches and i think the answer is no the um these could be named differently like instead of calling it a label we could call it something that had more meaning for the application that we're building so um if we were representing the course website maybe the label would be the address like there's a address for homework and there's address for the main calendar and you could think of one branch of this tree rooted at the whole thing as uh anything that you can get to by following a link so there's like a we followed one branch and now we're at a new label but i think um you know that that might change the word label to be address and branches to be a list of other pages but it wouldn't change the implementation at all and so it really is worth getting used to the idea that this concept of having a label and then a list of branches which are trees is true of any hierarchical representation that you care about so anything you want to model is often built up out of a label and some branches and and if it's ever the case that the pieces of something are the same kind of thing as the whole thing so like the pages that are linked to from a page or just more web pages um then you get this kind of tree structure uh i'm guessing that's not so helpful yeah let me let me look for one more thing a slightly more general version of a tree is what's called a graph which we won't be talking about and there we often talk about nodes or vertices and edges so edges connect two things um and the vertices of the nodes have the name of something or the value associated with it so think for example uh airports around the world every airport is a node and an edge connects them if you can fly from point a to point b now that's not quite what a tree is because the tree has sort of this ancestral relationship top to bottom whereas a graph typically doesn't have that notion of hierarchy so that's why i think the branch nomenclature here is good because it reminds you of this sort of upside down tree all right interesting so the question is about this optional lab question which involves coming up with what letters you need to add to w1 in order to get to w2 assuming that um w1 is a subsequence of w2 so uh w1 might be cat w2 might be contrast and this is supposed to return the o-n-t-r-s that you need to add to cat in order to get contrast so maybe let's talk about this for a moment and how you might go about it you have a choice of whether to work through the words from the beginning or the end and there's some condition here that says like when there's repeated stuff it should happen in a particular order i think we can just ignore that for now and focus on um getting some reasonable answer and then we could worry about this kind of condition and therefore i don't think it matters whether you work through the words from beginning or from the end but the way i would approach this problem is to say these two words assuming they're not empty have a first letter and that first letter is either the same or it's not if you know that all the letters in w1 are somewhere in w-2 then if the first letter of w2 isn't the same as w1 it's one of those letters that you're going to have to add in order to transform w1 into w2 so that's kind of the key check is that you want to keep around the first letter of w2 if it's not the same as w1 if it is the same then it's not something you need to keep track of because our goal is to find everything that's in w2 but not in w1 and if we find a letter that's in both well then i think we can just leave it out of the final result so no trees needed how might we go about this well um we'll leave the base case till later so i think we can work it out pretty soon and just say like oh let's assume that w1 and w2 both have letters in them if w1's first letter is the same as w2's first letter then i kind of just don't care about it it's not supposed to be part of the result so i can just find all the letters in the rest of w1 and the rest of w2 i've kind of just like worked my way past that first letter and then i don't want to include it in the result i think if uh on the other hand if these letters are different then we actually do need to have w2 0 as part of the eventual response of letters that we want to add we don't want it twice so i think it's fine to only process the rest of w2 after that but we still haven't matched up the first letter of w1 with anything and it's supposed to be in w2 somewhere so i don't think we want to change w1 instead we'll just keep it the way that it is all right here we made an assumption that they both have letters but i guess there's a case where we might have used up all the letters in w1 so i think we need to worry about that one way to write it is that um let's leave it like that that's fine uh then what are all the letters in that you'd have to add to an empty string in order to get w2 i think you'd have to add all the letters in w2 to get that so let's see how we did and then we will uh discuss how to fix it because there might be a weird condition with this cacophony case that we'll have to worry about oh maybe we just got them all okay yeah so i think if we had like uh worked from beginning to end from the end to the beginning then um this condition where like the order matters might have come out a different way but uh turns out we didn't have to worry about that by the way this is this is sort of a classic recursion problem where you can see you know if you think about the problem as well what if i have a you know just there's one letter in each and those match what do i do right and then what do you do otherwise it's it's that classic recursion where you you sort of simplify the problem to the simplest possible cases the base case one of them is empty and then here there's there's sort of like two base cases almost not quite because that second one is a recursion but it's that really really simple case and then you build in the complexity after that um so that i that's what's sort of really cool about these recursive solutions yeah good question so i think part of the question is about uh what guarantees do you have with the tree data abstraction like how do all the pieces fit together there's actually a lot of them so let's just talk about them all when you call label on something it should always be the result of calling tree so it should never be the case that you call label on anything except for something that was created by calling tree same with branches whenever you call branches it should be on something that's a tree what does it mean to be a tree it means it was the return value of a call to tree this is not specific to trees this is true of selectors and constructors in data abstraction in general is that all your selectors should take only the result of calling the constructor the constructor for a tree cannot take arbitrary values for the label it can't a label could be anything but branches needs to be a list and it needs to be a list of trees it could be empty but if it has anything in it it's not allowed to have numbers in it or strings in it it has to have trees in it what does that mean it has to have values that were the result of calling the tree constructor so when you call tree on anything you can put whatever you want there but here you have to put calls to tree now it doesn't always look like this sometimes you're calling some other function which returns a call to tree so that would be okay if the definition of f was return a tree return tree of something but this value that ends up in here needs to be a tree and that is the recursive definition of this particular data abstraction which shows up in computer science all the time so um we're spending a lot of time on it because it is uh very useful in general notice there's a very good reason for this this is an arbitrary look at the code for example is tree it's assuming that everything as you process down has to be a tree so that assertion up top ensures that the functions that operate on trees have a data that data structure that's intact and what's so great about this is that when you do something like count the leaves or whatever and you are sure that what got passed in was a tree then you know that you know if it's a leaf there's just one leaf right there's nothing else there except for the leaf but the useful part is that if it's not a leaf then you can go through all the branches and you know that every bee is also a tree which means you could call count leaves on it because count leaves takes trees you could call any other function you want that takes trees and you have this guarantee that all of the bees that you get when you iterate through the branches of a tree are also trees and therefore you can do things with them that you can do to trees so we could you know sum up the leaves in each branch or something like that now building a tree always takes a little bit of work you got to set up the label and you got to set up the branches and those branches need to be trees this branch has only one tree i mean sorry this tree has only one branch which is a tree so that's good it's a leaf and therefore if we count the leaves of that we should find only one hmm maybe i didn't save oh wrong file oh and i need to return we're getting close folks okay one leaf if i added another leaf regardless if it's label we'd have two leaves i don't know if that answered your question so maybe i'll let you respond so branches always returns a list if that list is not empty every element is a tree but it might be an empty list so you don't know when you call branches whether you're going to get no branches or two branches or one branch or 50 branches all you really know is that you're going to get a list and that list however many elements it has in it are all going to be trees meaning they were all created by calling this tree constructor so the question was about this kind of just for fun question anonymous factorial i'd say that it's outside the scope of this course that you'll be able to like work this out on your own um but it's a it's a fun thing that you can do so the goal here is to figure out how to get recursion to happen meaning like write a recursive function without being able to assign a name to that function in this example we wrote a recursive version of fact but we referred to fact by assigning it a name and the trick to avoiding assignment statement here is the same one that we saw in ping pong which is that instead of using an assignment statement just pass in something as an argument because that's another way to give something a name is to pass it into a function and then it has a name so if we have this general structure here's a function that takes a number if n is one then it returns one otherwise it multiplies n by the factorial of n minus one and maybe we'll get rid of all these moles and just make our life easier nothing wrong with subtracting like that uh how would we give this thing a different name well instead of assigning we could have it be fact but then how would we like pass that in i guess instead of putting it here maybe maybe the best place to put it is here so basically in order to run this we need an and we need factorial i'll just let that sink in if factorial is not already defined then somebody needs to pass it in in order for us to call it i'm gonna need a little bit more space than this i'm afraid now that we have a function that takes n and factorial we need to be a little bit careful we want this to be our factorial function but it takes two arguments and here we're calling it with only one argument so that seems like a mismatch what should be the second argument every time we call fact well it should be the same function again that's kind of how we get that recursive structure is that every time we call this thing that takes in a number and the function that we're going to call recursively it needs to be called on a new number and the function that we're going to call recursively so we've actually made some progress even though all we've done is kind of like move a name in here and uh pass it around the last part is that we need to figure out how to write a function that takes only n and somehow uh calls this one instead and that's actually not so bad this says uh give me a function and call that function on both n and itself so if i have a function and i call it on n and itself where n comes from here now i just need to know which function i'm supposed to be calling on n in itself and the answer is this guy so let's see what g does now g computes n factorial if we really wanted to get rid of that assignment statement then we could compute four factorial this way by taking this function and calling it on four and then hopefully if everything went right we will have printed four factorial or five factorial or whatever so what was the key moments in figuring this out one was if we can't have fact defined already then we have to pass it in as an argument and the second was if we have a function that takes two arguments and we really want a function that takes one argument then we should write a function that takes one argument and calls the function that takes two arguments and then the last part really is kind of a trick which is to say like if you had a function and an argument you would then call the function on the argument in itself this is basically how you create recursion without using assignment statements is this little part right here man that's gnarly remember folks just for fun john has a very odd sense of humor apparently contents are fun that's pretty awesome i i think john's right here by the way look there's a couple of things that you've seen before essentially there's the helper function in here you have a function that uh only takes one parameter and you really need to pass two so you put a helper function in that's basically what you have here with the lambda um you've got sort of the notion of recursion and then there's just that little trick there um which you see with uh this uh lambda f of f of nf so don't don't get too worried if you didn't see that obvi it obvious i don't think it's at all obvious actually one thing that's exciting about this while it's not obvious at all is that it allows you to create iteration out of just functions like of course there's no assignment here there's also no while statement or for statement here but we are doing something repetitively and so um this is kind of uh this idea right here is a building block for the claim that once you can define functions you can kind of write any program that you want you can perform any computation and you might wonder well is that really true like don't i need a while statement or a for statement it turns out technically you don't that does not mean we should get rid of while statements and for statements they're a lot more readable than this i think but um they're not strictly necessary in order to perform interesting computations yes and some in the chat just pointed out scheme and lisp is this is sort of the premise of these functional programming languages that don't have looping explicit looping constructs as you do everything with these types of constructs and it's a little bit mind-bending but it turns out it's expressive enough yeah that's right those languages do tend to have assignment statements so at least you can you could write uh this instead of uh instead of that yeah and and to the chat room we do still need conditionals the next question was what was the purpose of the fact times example from lecture um yeah so the reason we did something a little bit different here was so that we could show an example of a recursive function that just called itself without doing anything with it so there kind of wasn't anything outside of the call everything happened inside the call where we subtracted one from n and we multiplied k by n but we didn't like add anything or multiply anything afterwards which was different than the original version of factorial which did multiply the result of the recursive call by n the original one looked like this right it was like if n equals zero return one else return n times fact n minus one so here we make the recursive call and then we like do some work afterwards and that means the recursive call doesn't really know where it came from it doesn't know anything about which factorial result you're constructing whereas this one does at the end when you hit the base case you have computed k times n factorial for whatever n in k you started with and that is now named k which is a little confusing but that's how it goes sometimes with recursion but the point is that the whole answer is uh built up by the time you hit the base case at which point you just have to return return return return all the work is and notice by the way in that first one that's not true as you're doing recursion there is a delayed gratification of the evaluation of that product so when you hit the base case in the first fact you then have to go back and now multiply all those numbers between n and one yeah because you built an expression whereas in the fact times you basically have an assignment operator it's that you're you're just using the parameters as the assignment operator and so when you hit that base case done i've got the answer so so you're right of course we could have done it differently we didn't have to do it this way but you see that the structurally the recursion is subtly different here and and it turns out this has a real implication too by the way downstream and i think i think we'll eventually do that right john yeah so this is called uh tail recursion and this is not and we'll talk about this later when we talk about interpreters um so the goal here wasn't to implement fact times it was actually to re-implement fact but in order to re-implement fact you'd have to have a helper function that's what fact times is that keeps track of two arguments instead of one the thing you're trying to compute the factorial of and the result the answer of computing n 