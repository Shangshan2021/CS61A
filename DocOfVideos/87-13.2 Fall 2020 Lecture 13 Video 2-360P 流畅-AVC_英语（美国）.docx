welcome back we spent the better part of this semester talking about python data structures algorithms classes object-oriented programming and if you recall one of the themes in all of this is the power of abstraction the power of compartmentalizing either data or code so that the nitty-gritty details of it don't have to be part of our work in writing code around that and there's a really powerful notion of abstraction and in the last part of this course i want to talk in some ways about the ultimate abstraction which is a computer we use these things routinely whether they're handheld devices laptops or desktops and they're remarkable they do incredible computations and do we know exactly how it works well for the most part no it's an abstraction we know that when we turn on the computer and save a file something happens we know when we turn on a computer and ask the computer to add two numbers or divide two numbers just sort of works but how how is that nature of that computation working and because i think it's important to understand this very tool that we were using on a daily basis we're going to spend the last part of this class talking about that obstruction which is how do modern day computers work now obviously this can't go into every little bitty nitty gritty detail of how a modern day computer works but i'm going to show you the building blocks of a modern day computer and what is i think really truly remarkable about that is how incredibly simple they are okay so let's go ahead and dive in first and uh and see see how computers actually work all right so let me first start talking about the language of modern day computers which are binary numbers but before i do that let me talk about the numbers that we all know and love which are base 10 numbers okay and then we'll we'll talk a little bit about binary numbers so when i say the number 723 uh you and i have a common language what do i mean by that the language is that we know that this number is in base 10. what does that mean that means that the 7 corresponds to the 100th position 10 to the power 2. the 2 corresponds to the 10th position 10 to the power 1 and the 3 corresponds to the 1th position 10 to the power 0.
and we don't we don't i don't have to say 723 base 10 it's assumed right we all work in base 10 unlike languages metric versus non-metric there are many other conversions that we always have to worry about so when i say a temperature fahrenheit or celsius when i say a distance kilometers or meters and so but one of the nice things about numbers is that we've agreed on a base 10 okay and that's the language of numbers and it's it's implicit but really there is a rationale behind this number which is that this is 7 times 100 plus 2 times 10 plus 3 times 1.
um and i'm going to because this is how we're going to be doing things in base 10 is remind you that the 100th place the 10th place and the 1 place are just successive powers of power of 10. so 10 to the 0 1 10 to the 1 10 10 to the 2 100 and obviously 10 to the 3 1 000 and so on and so forth and that's what we mean by base 10 is that this base is being raised to an exponent and that forms the base and then we multiply by whatever number is in that position so for example if i had the number 5 349 that would correspond to 5 times 10 to the 3 plus 3 times 10 to the 2 4 times 10 to the 1 and 9 times 10 to 0.
and again i when i give you this number i don't have to tell you base 10. it's agreed upon we've sort of pre-agreed on this but we should agree that it's it's sort of arbitrary why base 10 well you know some people think it's because of this that's a pretty good fit actually base 10 because this is how we count our fingers one two three four five six seven eight nine ten right but there are if you look through history other civilizations that use different numbers my favorite example this is my father my father when he counts he does one two three four five six seven eight counting with the thumb i don't know what he does when he gets to nine and ten he can only count to eight base eight is a perfectly fine number right so what does it mean for 257 to be represented in base 8.
it means that the base is now not 10 there it is right there and they're there it's 8 so it's this 2 corresponds to 2 times 8 to the power 2.
this 5 corresponds to the base 8 to the power 1 and 8 to the 2. so notice that this number this number and this number are exactly the same except i've simply replaced in the previous example 10 with 8 and then of course the exponents work out and so 257 base 8 can be converted to base 10 by simply working through this arithmetic and that's 175 so you could imagine a world where some societies work in base 8 and some work in base 10 and we'd have to convert units the same way we convert temperature distance weights between metric and non-metric it'd be annoying but we could do it and there's nothing fundamentally wrong with this base and there's nothing fundamentally right about this base you can represent all the numbers they just have a different meaning now base 2 is a perfectly valid base as well notice by the way that numbers in base 2 only have two numbers 0 1 so numbers in base 10 have 10 numbers 0 1 2 up to 9.
numbers in base 7 only have 8 numbers 0 to 7 and numbers in base 2 only have two numbers 0 and 1. so if i give you the number zero one one zero and i ask you what is that in say base ten well then we play the same game this leading zero is multiplied by two to the power three this one is multiplied which of course is that one right there times two to the two two to the one two to the zero work out that that uh those powers of two so it's eight four two one those two are multiplied by zero so they go away the one and the four multiplied by one four plus two is six so that's base 10.
nothing right or wrong about base 2. i can represent any number that i can represent in base 10 which i can represent in base 8 or base 4 or base 16 for that matter okay so the bases are arbitrary that's the point here they are arbitrary we can represent all the numbers they just have a different representation that's all and the reason of doing this is because modern computers talk in binary numbers they have two numbers that they can represent zero and one and i'm going to talk in a little bit about why that is and then we're going to see how we get from that language of modern day computers to actual computations on binary numbers but of course we have to understand the language before we understand what's actually being done on that language all right so for example um because computers are have finite memory and finite precision we always have to specify how many bits we will be talking about in our binary number so unlike base 10 i can just give you a number all right 5 371 27 8. i don't have to say this is a four bit or a five bit or a 1-bit but in binary numbers because everything has to have the same length representation we're going to always specify how many bits are available to us and simply by bits i mean how many bases how many powers of 2 do i have so a two-bit binary number says that you can have a bit in the in the first position two to the power zero and you have a bit in the second position two to the power one and that's it okay now with a two-bit binary numbers you can walk through and figure out how many possible numbers can i represent if i only have two bits well i can represent zero zero zero i can represent one zero one uh two one zero and three one one and that's it there's no other bits so now when i when i restrict the number of bits in my binary numbers now i do have a restriction i can only represent numbers between 0 and 3.
that's true of base 10 too i could have said you have no more than two decimal places or two positions then you can only represent numbers between 0 and 99. there is no 100. so the same thing holds true i'm just going to now start fixing the bits and you'll see in a little bit why that is so let's just make sure we understand this so why is this 0 because this number in base 10 is 0 times 2 to the 0 plus 0 times 2 to the 1 0.
what's this number 1 times 2 to the 0 that's 1.
0 times 2 to the 1 so that's 0. so that's the 1.
okay zero there and then the one times two that's that and then of course i have two plus one is three and notice that with a two-bit binary number i will always if they're always positive we'll get to negative numbers in a little bit i can always go from zero to two to the power two minus one so in this case that's four four two to the two minus one is three okay so if i give you a three bit binary number my maximum value is two to the power 3 that's 8 by the way if you're going to be a computer scientist you have to get really good at powers of 2.
1 2 4 8 16 32 64 128 256 5 12 10 24 you can stop there 10 20 48 is after that that one's easy too okay so maximum power of two is uh maximum sorry largest number is two to the power three that's eight minus one by the way why the minus one because i'm starting to count at zero so notice i have three bit binary number starting from the right this is the two to the zero position two to the one position two to the two position okay and you should be able to convince yourself that you can get every number here by doing the conversion i just did so let's let's do say five here so how do i know that this is five this is two to the zero what's that one that's a zero so i don't care this is two to the two that's four four plus one is five go through each one of these please at least in your head and makes you convince yourself that you get these numbers here okay so that's a three bit binary number i can count between zero and four bit binary number same same game two to the four is 16 16 minus one is 15 that's the maximum number we have all fours there minimum number is all zeros of course so again 2 to the 0 2 to the 1 2 to the 3 2 to the 4. so let's look for example at this number right here 11.
why is that 11 well let's go from this side so this is two to the four which two to the four is eight plus two to the two that is sorry two to the one that's two that's ten and two to the zero is one that gives me eleven and again pick a couple numbers here and convince yourself that these are the decimal base 10 numbers correspond to these four bit binary numbers okay now the question you want to ask is why am i doing this is it fundamental to computers um or is it that there's a reason for it and it is not fundamental computers but there's a really good reason for it which is that representing binary numbers in a computer is incredibly reliable and let me tell you what i mean information of course on the computer is stored but in terms of electrons that's how computers are powered and so we have to be able to represent different numbers so imagine i want to represent say base 10 let's say i wanted my modern computer to be base 10 which means i have to represent the number zero one two three four five six seven eight nine okay and let's say that the way i'm going to rub it let me do an analog to how the electrons work is i have a little test tube and i'm going to fill that test tube with water to the level that corresponds to the number and then that test tube will correspond or represent that number so here's a zero it's filled up to level zero here's a four it fills to four six and seven okay nothing wrong with that perfectly fine but what if that water level was a little unstable what if it what if it was shaking around and it was moving around a little bit and that means a zero might accidentally look like a one every once in a while and a seven may accidentally look like a six or an eight because of a little bit of instability now obviously this is not water in a modern computer but these are electrons electrons have a little bit of instability it's difficult to keep that level at exactly the right level and so to distinguish between 10 distinct levels is just not very reliable in a computer and what is reliable is distinguishing only between two things so here's my test tube again with water in it if it's empty it's a zero if it's full it's a one and now you can imagine if there's a little slop here this goes down to eight and this goes up to one and it slops around i can still distinguish between those so we want representations that are incredibly distinct from each other and when you have to do 10 levels you have to have a much finer resolution if you will and if you only have two levels it's actually easier to deal with fluctuations in the internal physical representation and that's in a nutshell why we use binary numbers okay good so what have we done at this point we have we've said that binary numbers are the language of modern computers now it's not entirely clear what i mean by that still what do i mean by language right so when it comes to numbers sure i'm going to use base 2 instead of base 10 but what about letters and strip strings and other things we'll get all to we'll get to that in a little bit so the language of modern computers is we are going to talk in base two the reason we're going to talk in base two is because of the reliability with only having to store two states zero one okay now at this point i've shown you how to represent using an n-bit binary number numbers between zero and two to the n minus one that's the maximum number you can represent but obviously there's other things i'd like to represent what about negative numbers what about floating point numbers what about strings so what we're going to do when we pick it up after this lecture is we're going to start talking about how to do things like negative numbers and then we'll talk about fractions and then once we get that once we understand the language of modern computers binary numbers we're going to talk about the nature of computation how do computers actually compute on these binary representations all right that's it for now we'll pick it up in a 