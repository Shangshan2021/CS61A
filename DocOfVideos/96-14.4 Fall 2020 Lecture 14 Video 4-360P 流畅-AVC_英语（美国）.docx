we're now ready to do our first meaningful computation we have now all the infrastructure we know what gates are we know what circuits are we know how to go from a truth table input output sub-expressions expressions draw a circuit okay so now let's actually build first small but at least meaningful computation so we're going to build what's called a one bit compare for equality a c e circuit so what do i mean first of all by one bit i mean i have my inputs are a and b which are each a single bit it's either 0 or 1. a 4 bit compare for equality which we'll do in a little bit would be that i have a is 0 1 1 0 and b for example is one one zero zero and all i want to do is ask are these two one bit values a and b equal or not and so here's my little pseudo code for the computation if a and b are equal then return one otherwise return zero notice everything's binary a and b can either be zero or one because everything's in binary representation and my output is either a one or zero depending on if those two bits are equal or not so pretty straightforward so now let's start turning the crank let's figure out how to design a circuit that does this so step one is what build a truth table what are the first two columns of the truth table they are my inputs i have two one bit inputs a and b and i have a single output c which is going to be equal to one when the two bits are equal and zero otherwise okay so the first part of this is easy simply enumerate all possible set of inputs zero zero zero one one zero one one and you should do it in this order by the way because it makes sure that you don't miss anything it's just good discipline and it's the way everybody else does it so the inputs are trivial just count in binary from zero to 2 to the n minus 1. now you got to tell me what the output is so this is the work tell me what you want to compute well what do i want to compute let's go back to the previous slide i said i want this to be a 1 when these two bits are equal and 0 otherwise all right so here they're equal not equal not equal not equal so now i know what my output is it's a one in the first row zero zero it's a one in the last row one one and it's a zero otherwise so this is now a meaningful computation it's telling simple but meaningful it's telling me if these two bits are equal or not okay good we've done step one of our four-step circuit design let's do step two what does step two say to do is to build for each output column there's only one output now a sub expression okay so let me remind you how we do that we isolate where there's ones we go figure out what is the combination of and and not that gives rise to that one and then we move on to step three and then step four so let's just do the sub expressions for now all right so there's a one here and a one here so this is the only place i have a sub expression so what do i do i go back to the input that's a zero so i not a there it is right there that's a zero so i not b i and those two together and again remember that why this works because when a is zero not a is one when b is zero not b is one so when i and 1 and 1 i get 1 and that is the only place i get 1.
there is no other possible values of a and b that will give rise to 1. so this is this very surgical strike this little sub-expression it's going to evaluate one here and only here this is somebody else's problem down here and this is nobody's problem because the default is going to be that everything evaluates to zero if it's not this or not this all right let's build that sub expression again go back to a and b that's a one so we bring the a over that's a one we bring the b over and again this sub expression is one if and only if a is one and b is one and it is zero everywhere else so again notice these why we like the ands here because for any value that is not 0 0 and any value that is not 1 1 these expressions are going to value to 0. so here for all other values of a and b this evaluates to 0 here all other values of a and b are value to zero so i get these two for free by simply these being so surgical and evaluating to one if and only if we're here or we're here good so step two is done i now have the sub expressions so let's do step three combine the sub expressions with ors for each output column of course we only have one output column so c my output is going to be equal to not a and not b there it is right there or a and b and again you you have to convince yourself that this is exactly what you want okay so again this can be one in only one situation this row right here this can be one in only one situation this row right here so this entire expression will be one in this case in this case and again notice it's zero everywhere else we sort of came for free because of the nature of the and so there it is i've got a little boolean expression that is what one bit compare for equality so at this point you're sort of done drawing the circuit is just the fun part it's just to sort of prove the point that you can actually implement this thing but i've now got a computation one bit compare for equality using logical land logical or and not all right let's go ahead and just draw the circuit okay again input on the left output on the right there's two in this is a two a one bit compare for equality i'm only comparing two binary numbers and here's my output and i've brought over my expression here just so we can carry it over okay so we know there's gonna be an or somewhere over here there's gonna be two ands here and i need a couple of not gates for the a and the b okay so let's go ahead and just start pulling these pieces together all right so let's see i'm going to take a and b and i'm going to shove them into this and gate that's the sub expression right here okay that's the easy part i don't need any knots and now i'm going to peel off a and b again filled circle when i peel the signal off open circle when i cross the wires you have to do this so you can follow the inputs so when you follow this line you know to keep going here you can ignore that and then it goes into a not gate and it goes into an and gate same thing with b i'm going to peel it over drive it into a not gate shove that into an and gate don't forget the dot on the and gate so we can see what you're doing and this of course is not a and not b this is a and b i again like drawing these ex the actual expressions here because it sort of reminds me that you know what i'm doing and i can go back and check my work nicely now these two of course so this sub expression corresponds to this this sub expression corresponds to this and what do i want to do with those two i'm going to shove them into an or gate and then i have my output all right good shove them into an or gate that's now the full expression and i have my output and now we have our first meaningful computation it's incredibly simple um it is simply a one bit compare for a quality but it's meaningful it actually does something okay and notice here in some ways there's something i always think magical about these uh designing these circuits because notice that you're not really computing one bit compare for equality what do i mean by that what i mean by that is you've sort of memorized one bit compare for equality that truth table in step one gave the computer the answer what did you say you said look here are all possible sets of inputs zero zero zero one one zero one one and here's all the outputs associated with that so when you see zero zero output one when you see one one output one and then all the other times output zero you gave it the answer and now what it's doing is simply i mean it is computing it because it's pushing it through the circuitry but you're the one who did all the hard work you're the one who told it what the answer is and now it's simply doing that for all possible inputs using these operations so in some ways this is sort of the magic of circuitry is you're actually doing a lot of the hard work and the designing of that truth table building the sub expressions building the expressions eventually we'll see how to simplify those things to make them more efficient and then this is just sort of turning the crank it's just simply implementing the machinery that you actually designed you gave it the answer okay all right good so this is the the first and simplest now where we've actually done a meaningful computation using our four steps input output build the truth table sub expressions combine the expressions draw the circuitry and what we're going to do now for a little while is we're going to just do a lot of examples we're going to see how you get more and more complex computations and then near the end i'm going to show you because i'm sure some of you are already thinking about this is you know there's going to be at some point there's going to be a lot of these gates and how can i make them simpler is this really the best way to design circuits and the answer is absolutely not this is not the best way to design certain circuit design is incredibly complex and you really want to optimize it so that you get the most amount of bang for your buck on a circuit we're going through the simplest possible circuit design i'll show you a couple of optimization techniques uh near the end of the of the class here but until then we're going to do a bunch of examples to make sure we understand this four-step process all right that's it for now and we'll 