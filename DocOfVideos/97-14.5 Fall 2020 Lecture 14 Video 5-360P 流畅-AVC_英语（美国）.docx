in the last lecture we built our first meaningful computation starting from a truth table through building sub-expressions expressions and eventually find a circuit for one bit compare for equality so we asked if we have two one-bit numbers a and b can we build a circuit that tells me if they're equal they're both zero or they're both one okay incredibly simple maybe not very useful so let's see a few more examples of this and and the next example is going to be a four bit compare for equality so what do i mean by that so remember that when we specify binary numbers we specify how many bits and whether they're signed or unsigned so for now let's just do unsigned four bit binary numbers i have two four-bit binary numbers and i want to return true one if those two numbers are the same and zero otherwise okay so let's just start turning the crank so the first thing and this is really where all the hard work is is figuring out what is the truth table what does the truth table look like how many how many input columns what is the output and then populating that truth table so let's of course start there well okay so first of all what does a four bit binary number look like so here it is let me label them a0 a1 82 a3 this of course is the most significant this will be significant so that's my first binary number four bits let's call that a but notice that there's actually four numbers there and then of course i have b which has b3 b2 b1 b0 and i want to know are these two equal well what does it mean for those two numbers to be equal well it means that a3 is equal to b3 a2 is equal to b2 and so on and so forth okay so notice that even though i only have two numbers they're each represented in terms of four bits so i actually have eight input columns right a3 to a0 b3 do b0 so don't get confused by numbers and bits because we are living in binary world we have to always think about the underlying bit representations okay so i have let's see four here four here that's my input and i of course have one output which is c it's one when they're equal and zero everywhere else okay if i have eight input how many rows do i have remember the the relationship two to the power the number of inputs so in this case it's 2 to the power 8 which of course is 256. that's a lot of rows you have to populate so you have to go through every single of the 256 possible inputs write out a row tell me what the output value is and you could do that it'd be a little tedious but you can do it but let's think about whether we really need to go to all this trouble or not because when we think about it in this two-bit written this and this two four-bit numbers there's really i'm sort of doing a very simple computation over and over again so what is that well i sort of said it i said that this 4-bit number a and this four bit number b are equal if a3 is equal to b3 and a2 is equal to b2 and a1 is equal to b1 and a0 is equal to b0 so really if i could just figure if i could solve this one bit problem and then this one bit problem and this one big problem and this one big problem well then i could just logically combine them using an and operator so maybe we can simplify this calculation a little bit and not have to populate that full 256 row table so let's let me remind you what the one bit compare for equality looks like i take two single bits so uh careful with the switch and notation here this you can think of this as a zero and b b0 and this is telling me whether those two bits are equal so these are just two one bits and remember that the way the circuit works it says if they're both one so if they're both one then this and will respond one if they are both zero they go into knock gates they flips to ones here this will respond to one so if this is a one or this is a one then i get a one out here otherwise i get a zero so this is the one bit compare for equality that we did before let me let me um draw this with a little bit of abstraction because this is a lot i don't want to have to keep drawing this over and over again so i'm going to represent the one bit compare for equality with this little box here with a 1ce one bit compare for equality and done now there's two levels of abstraction right because here there's two transistors here there are two transistors and i but i don't draw that every single time i just draw this little abstraction for what a gate looks like in terms of transistors and now i can draw another abstraction for the entire circuitry and underneath it is this and underneath that is a bunch of transistors so again that power of abstraction and now let's think about how do we combine those little one bit compare for equalities to get a four bit compare for equality well again i want to compare a3 and b3 and i want to compare a2 and b2 and so on and so and of course i still only have a single output which is if these are equal and these are equal and these are equal and these are equal then i want to say yes otherwise i want to say no all right so let's start pushing the bits through the compare for equality so a3 and b3 go through a one bit compare for equality and out comes what a one or a zero if it's it's one if those two are zero zero or one one and it's a zero otherwise and similarly i can push a two and b two a one and b one and a zero b zero so each of the bid positions each through their own one bit compare for quality notice the power of the abstract here i don't have to write an entire circuitry i can just write that little box and i know what it is from the previous slide now what i want to do is so i have four outputs here and what do i want to do well let's think about what the rule is the rule is that this should be a one the output to the entire circuit if this is a one and this is a one and this is a one and this is a one i know how to do ands i just need an and gate now so this should be pretty easy notice by the way the and gates only take two inputs so i can't shove all four of those into an and gate so i have to do them two at a time and it doesn't matter what the order is of course so these two go into an and gate and now this will tell me if they're both one and then i'll take the output of that and i'll shove it into the and gate an and gate where it's the the the bit down here and then i'll do that one more time so let's just think through the logic here let's say that these are let's say they're all ones just to make it simple so out of here will come a one because they're equal a one goes into the and gate out of here will come a one it'll go into here so this is a one coming out the first two bits are equal this is a one coming out here because they're equal out of here comes a one this will go into here this will be a one here and eventually one and notice if any one of these are not equal so let's say these are not equal well then a zero comes into this and gate and that means a zero comes out of here and if a zero comes out of here a zero comes out of here and a zero comes out of here so once one of these and gates flips any of them because one of the bits is not zero we get zero on the output and the only way we get a one on the output here is if these are equal and these are equal and these are equal and these are equal and so now look at the power of the circuitry i've got a really simple circuitry here here and here i've got three and gates so instead of having to build a true table 256 entries build all those sub-expressions build the expression then draw a fairly complex circuitry with eight inputs and one output with the power of a little bit of abstraction i was able to do something a little bit nicer so i used this example because one of the things we'll be talking about is yes we'll want to turn that crank on the circuitry truth tables sub expressions expressions but sometimes it's really inconvenient sometimes we have to be just a little bit more clever okay so that's it for now when we come back we're going to design a couple more circuits and we're going to keep sort of seeing how these things are built and how to build more and more meaningful computation so see in your 