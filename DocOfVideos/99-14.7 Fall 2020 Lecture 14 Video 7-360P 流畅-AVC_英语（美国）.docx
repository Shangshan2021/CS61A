as promised we're now going to build uh circuitry for doing four bit addition so we're going to take two four bit numbers and we are going to add them in the same way that we did in the previous lecture we just stack them on top of each other we sum we carry we sum we carry we sum and we keep going and we do binary arithmetic or addition and obviously we're going to use the one bit adder that we just built because we know that n bit addition is just a series of these one bit edition so we're going to build them we're going to build this in a smart way all right so please build for me a circuit that adds two four bit numbers and again i want to emphasize pay attention to the bits because the inputs is not two it's now well at least eight but we know we have all those carries too right so we always have to be thinking in terms of bit representations because everything we do operates on bits all right well we know how to do one bit addition so notice here i've done something very similar to what i did with the one bit compare for equality i've taken that full circuitry that i showed you in the previous lecture i've got digits i have the carry in that's what's coming in from the previous column and i have two outputs the sum what drops down below and the carry out what carries over okay so three in two out and now i've simply drawn a little box and i've written one ad which is a one bit edition and that is that full circuitry and again this is the power of abstraction once i know what's in here the same way that i know it's inside of a gate i simply can draw it in this abstract way and i don't have to worry about it anymore i've built it i've tested it i know it works and now i can simply use it and so now what we want to do is wire up a bunch of these things in order to do four bit addition and of course we could do six eight et cetera et cetera we'll stop at forks i think you'll get the point so let's start thinking about how we want that to work and you just got to think about how does it work i take these two things in and then i'm going to shove that next carry to the next one which should be the input to the next one bit adder and we keep repeating that over and over again so let's see how that works all right so first of all here are my four bits for a and my four bits for b so that's what i want to sum up got those carries i've got to bring in that's fine we'll do that in a minute here's my one bit addition right here here are my two outputs there's a carry and then there's the the digit the sum notice by the way that this is the thing that's coming out this carry is for internal purposes i don't report that to the summation i just need that to propagate the bits down so the output outside the circuitry is here now okay so here's a0 here's b0 those are the two ends but i also need a carry in so what's the carry in for the right most bit well it's zero okay good so we just shove a zero in there that's fine that's easy to do so now i've got three in i'm going to get a carry which again internal purposes is going to be used for the next bit a1 and b1 and the output is really just d0 that's the only thing i care about that will actually come out all right so how do we add the next one well i want to take a1 and b1 and what is the carry in it was the carry out from the previous bit so that's simply going to go into the one bit adder good so i've got a1 here again cross wires open circle here comes b1 right here the carry came in from above this adder the output is the same d1 and now i've got the next carry good now we see the pattern right started with a carry of zero and we keep dropping it down shoving it into the adder associated with the column that is to our left all right good a2 here it is cross wire cross wire into the adder here is b2 into the adder carry in carry out my next sum is right there and now we're almost home we've got the last one right here and we got the last uh sum what do i do with the carryout well i can only have four outputs that's how i've designed it so i have four in and four out so if these two things sum up to something that is bigger than four bits i'm going to have what's called an overflow and for now i'm going to ignore it there's other ways of dealing with this which we won't get into fifth output and summed and said i have four in two four bit numbers and please allow me to have a care an overflow but i'm going to ignore that so that carry just goes into junk and gets ignored okay so notice again the power of abstraction notice how much easier this was to do once we understood we had this building block here it's a lot like functions once you build these simple functions that have functionality you can use them over and over again to build more and more and more complex things okay and of course i can take two four-bit adders now and make an 8-bit adder and then i can take two 8-bit adders make a 16-bit adder and each time i can keep abstracting out the complexity of what's underneath it all right so this again is the circuitry for a one-bit adder and if you remember in the last lecture i said that's a lot of gates to do something as simple as a one bit adder i just want to sort of run through a little back of the interval calculation with you here imagine i'm trying to build a 32-bit adder that's a reasonably rep allows you to represent reasonably large numbers well then what i would need are 96 not gates 512 and gates and 192 or gates how did i get to that well this thing over here for the one bit has six or gates 16 nand gates and three not gates okay and so i just multiplied that by 32 each so i have 800 gates to do only only only addition right multiplication division all those things can't be done so is that a lot is 800 gates a lot well that 800 gates corresponds to about 1500 transistors because when you're building circuitry you're building gates but really underneath it it's transistors right so now look at what i'm doing i'm popping out the levels of this abstraction i'm pushing through the the one bits i've got the circuitry for the for the 32 bit adder that's made up of a bunch of one bit adders that's made of a bunch of gates and that's made up of a bunch of transistors i need 1500 transistors to do one single mathematical operation which is 32-bit edition now if we were in 1945 i would need roughly a refrigerator size computer to do that single calculation that's insane and that's because transistors were not these tiny minuscule things we have today they were big physical things um that occupied a lot of space so the magic in today's computers that if i have for 1500 transistors i can put that on something that is much much much smaller than a printed period on a piece of paper this is the magic of modern day computers that these transistors can now be made incredibly small and so you can pack more and more transistors onto a circuit board which means you can pack more gates which means you can pack more circuitry which means you can have now in your in your jacket pocket a cell phone that is the equivalent of a super computer from uh 60 years ago and so this is you know what's sort of amazing about this to me when you do these calculations is you see the complexity of a modern computer all we've done is built addition not even a calculator and look at how much work we've had to done but look at the power of these tiny transistors okay all right so in the next two lectures these are the last two we're going to talk a little bit more about circuitry we're going to talk about optimization how do you make these things because of how big they can get if you do this sort of very simple design you may end up with prohibitively large circuitry and there's some smart things that you can do and i'm going to give you a couple of examples of that just to sort of round out the circuit design here alright see 